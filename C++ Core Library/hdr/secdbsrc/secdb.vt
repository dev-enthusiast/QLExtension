@Classes
	*

@Log
	$Log: secdb.vt,v $
	Revision 1.0  1994/09/08 05:17:18  GRIBBG
	Initial revision

   
      Rev 1.0   08 Sep 1994 01:17:18   GRIBBG
   Initial revision.


Cash Payment

	Data Type:		Double (Boolean)

	Classes:  		Options
	
		
	True if this object will exercise into cash instead of the Denominated()
	and Quantity Unit().

Compounding Frequency

	Data Type:		String

	Classes:  		Market Forward Curve
					Market USD
					Market Rate Curve
					Rate Curve
	
		
	The compounding frequency of curve that the Curve value type is, i.e., 
	one of the following from StringTableCompoundFreq:
	
		"Continuous"
		"Simple"
		"Annual"
		"Semiannual"
		"Quarterly"
		"Discount"
		
	If the value type returns "", then the value is	assumed to be 
	"Continuous".

Contract Month

	Data Type:		String

	Classes:  		Cmdty Contract
		
	An obscure letter denoting the month of contract expiration.  The values
	are as follows:
	
	F = Jan		J = Apr		N = Jul		V = Oct
	G = Feb		K = May		Q = Aug		X = Nov
	H = Mar		M = Jun		U = Sep		Z = Dec


Cross

	Data Type:		String

	Classes:  		Generic Commodity Cross
					Market Curve
					All tradable & reportable objects
	
	GobValueFunc:	GobValueFuncCross

		
	Denominated + "/" + Quantity Unit.


Current Market Assembly

	Data Type:		Array of structues where each structure is
						Curve		String
						Until		Relative Date
						
	Classes:		Generic Commodity Class
					Market USD
	
		

	The Current Market Assembly is a copy of Market Assembly where each
	Curve component is prepended with the current Market Prefix.  For
	example, with Market Prefix( Market ) of NYC Close and Market Assembly
	as follows:
	
		Curve							Until	
		------------					--------
		DEM Cash Curve					2s
		DEM Forward Curve				2y
		DEM Swap Curve				
	
	then Current Market Assembly would be:
	
		Curve							Until	
		------------					--------
		NYC Close DEM Cash Curve		2s
		NYC Close DEM Forward Curve		2y
		NYC Close DEM Swap Curve				
	

Current Source for Reference Spot 

	Data Type:		String

	Classes:  		Generic Commodity Class
	
		
	Name of the object that supplies Reference Spot.  It is constructed
	by concatenating the current Market Prefix, i.e. 
	Market Prefix( "Market" ), to the user provided Source for Reference
	Spot.  For example, when:
	
		Source for Reference Spot			= "DEM Forward Curve"
		Market Prefix( "Market" )			= "NYC Close"
		
	then the Reference Spot is obtained from:
	
		Current Source for Reference Spot	= "NYC Close DEM Forward Curve"



Current Source for Volatility

	Data Type:		String

	Classes:  		Generic Commodity Cross
	
		
	Name of the object that supplies the market volatility curve.  It is 
	constructed	by concatenating the current Market Prefix, i.e. 
	Market Prefix( "Market" ), to the user provided Source for Volatility.
	For example, when:
	
		Source for Volatility				= "DEM/USD Volatility"
		Market Prefix( "Market" )			= "NYC Close"
		
	then the Reference Spot is obtained from:
	
		Current Source for Reference Spot	= "NYC Close DEM/USD Volatility"



Current Value

	Data Type:		Curve

	Classes:  		Market Curve
	
		
	The Relative Value resolved to Spot Date, i.e.,
	
	
		Current Value[ i ].Date  = Spot Date + Relative Value[ i ].Date
		Current Value[ i ].Value = Relative Value[ i ] * Multiplier
		
	For the Market Forward class only, Spot is also added to the Value:
	
		Current Value[ i ].Value += Spot




Curve

	Data Type:		Curve

	Classes:  		Market Forward Curve
					Market USD
					Market Rate Curve
					Rate Curve
	
		
	The main output value type supplied by the object.  The type of Curve
	must be supplied by Curve Type value type.  The day count basis, if
	applicable, is supplied by the Day Count Basis value type.  The 
	compounding frequency, if applicable, is supplied by the 
	Compounding Frequency value type.




Curve Type

	Data Type:		String

	Classes:  		Market Forward Curve
					Market USD
					Market Rate Curve
					Rate Curve
	
		
	The type of curve that the Curve value type is, i.e., one of the
	following from StringTableCurveType:
	
	// FIX -- Oliver pls document
	
		"Forward, American quoted"
		"Forward, European quoted"
		"Zero Curve"
		"Coupon Curve"
		"Discount Curve"
		"Discount Factor Curve"
		"Eurodeposit Future Curve"




Database Created

	Data Type:		String

	Classes:  		All Classes
	
		
	The name of the database in which the object was created.  This
	string might be null if the database was later removed from
	DATABASE.DAT.

	See Also:		Time Created, Database Updated




Database Updated

	Data Type:		String

	Classes:  		All Classes
	
		
	The name of the database in which the object was last updated.
	This string will be null if the object has never been updated.
	It might also be null if the database was later removed from
	DATABASE.DAT.

	See Also:		Time Modified, Database Created




Day Count Basis

	Data Type:		String

	Classes:  		Market Forward Curve
					Market USD
					Market Rate Curve
					Rate Curve
	
		
	The day count basis of curve that the Curve value type is, i.e., one 
	of the following from StringTableDayCount:
	
		"Actual/365"
		"Actual/Actual"
		"Actual/360"
		"30/360"
		
	If the value type returns "", then the value is	assumed to be 
	"Actual/365".




Days To Settle

	Data Type:		Double

	Classes:  		All tradable objects
	
	
	Days To Settle is the number of calendar days this object requires to
	settle from either Arg1 or Pricing Date( "Security Database" ) if Arg1
	is not provided.

	This value type is used by the early exercise report.




Days To Spot

	Data Type:		Double

	Classes:  		Generic Commodity Cross
					Generic Tradable Class
	
	
	If no argument is specified Days to Spot is the number of business days 
	to spot date.  If an argument is specified, i.e.,
	
		Days To Spot( SecPtrObj, Now )
		
	the value type is the number of Julian days from Now to Spot Date if
	Pricing Date were Now.
	
	Example:  Days To Spot( "DEM/USD" ) is 2 but 
	Days To Spot( "DEM/USD", Date( "30Apr93" )) is 5 since 3May is a DEM
	holiday and 1May and 2May are weekend days.
	
	Note: Use of this value type is obsolescent.  The value types Spot Date
	and Spot Days are recommended instead.




Denominated

	Data Type:		String

	Classes:  		Generic Commodity Cross
					Generic Tradable Class
	
		
	Currency/commodity in which prices are given for the object.  If
	Price( Sec ) is 2.15 and Denominated( Sec ) is "DEM", then Sec is worth
	DM 2.15.




Description

	Data Type:		String

	Classes:  		Generic Commodity Class
	
		
	A detailed name or description of the object.




Discount Curve

	Data Type:		Curve

	Classes:  		Generic Commodity Class
	
		
	The present value of one unit of the given commodity/currency on Pricing
	Date in the same units.  The knot dates are the same as the Reference 
	Curve.  The knot values are the reciprocal of the Ref. Fwd.
	Curve knots times the Ref. Fwd. Curve's value on Pricing Date.
	
	Diddles to Discount Curve are passed through as diddles to the 
	Reference Curve such that recalculation of Discount Curve
	results in the diddled value.  Therefore knot dates in the diddled
	Reference Curve are the same as the diddle to Discount Curve.




Dollar Cross

	Data Type:		String

	Classes:  		All tradable & reportable objects

	ValueFunc:		GobValueFuncDollarCross
	
		
	Denominated + "/" + "USD"

	This value is used to convert Price to Dollar Price.  I.e.,

		Dollar Price( Sec ) = Price( Sec ) * Price( Dollar Cross( Sec ) )





Dollar Price

	Data Type:		Double

	Classes:  		All tradable & reportable objects
	
	ValueFunc:		GobValueFuncDollarPrice

		
	Price of security in USD.  Note:

		Dollar Price( Sec ) = Price( Sec ) * Price( Dollar Cross( Sec ) )




Edit Info Alternate

	Data Type:		Array

	Classes:  		All classes, but optional

	ValueFunc:		GobValueFuncEditInfo
	
		
	The alternate editor table for the object.  This is the editor pulled
	up in SecView when pressing Alt-F6, instead of F6.




Edit Info Generic

	Data Type:		Array

	Classes:  		All classes

	ValueFunc:		GobValueFuncEditInfo
	
		
	The default editor table for the object.  This is the editor pulled
	up in SecView, for instance.




Expected Transaction

	Data Type:		String

	Classes:  		All tradable objects
	
		
	Expected Transaction indicates what transaction this object expects
	should happen on Pricing Date.  Legal values are empty string and
	any legal trade type for this object.  Empty string means nothing
	should happen to this object.  All objects should provide a non-empty
	value on Expiration Date( object ).  Other objects such as American
	options and knockout options might provide a non-empty value on
	other dates.

	Up knockout example:
		On any date:
			If Spot( Knockout ) > Knockout Price( Knockout )
				return "knock out";
			else
				return "";
		On expiration date:
			If Spot( Knockout ) > Knockout Price( Knockout )
				return "knock out";
			If Spot( Knockout ) > Strike( Knockout )
				return "exercise";
			else
				return "expire";




Expiration Date

	Data Type:		Date

	Classes:  		All tradable objects
	
		
	All tradable objects must have an expiration date.

	Aside from normal pricing uses, the expiration date is also used
	for two operational purposes:

		1)	On the expiration date, each position is asked for its
			Expected Transaction() and a trade is generated if necessary.

		2)	Any object in the database that is more than 30 days expired
			may be deleted by automatic database cleaning scripts.

	In the future, another value type "Expected Transaction Date" may be
	added to serve purpose #1.




Expiration Location

	Data Type:		String

	Classes:  		Options
	
		
	The location at which this option will expire.  The value should be
	selected from one of the Location objects in the database:  "NYC",
	"CHI", "TKO", ...
	



Expiration Settlement Date

	Data Type:		Date

	Classes:  		All tradable objects
	
		
	Expiration Settlement Date is the date on which payments made at
	expiration will settle.  This is usually Days To Settle( obj )
	spot days beyond Expiration Date( obj ).

	Typically, this value is both IN_STREAM and CALCULATED.  The calculated
	value is Days To Settle( obj ) spot days beyond Expiration Date( obj ).
	However, the value is also IN_STREAM to allow for custom settlement
	periods.  The usual code for Expiration Date clears the value for
	Expiration Settlement Date to cause it to be recalculated.




External Forward Curve

	Data Type:		Curve

	Classes:  		Generic Commodity Class
	
		
	The Forward Curve of the Generic External Cross which depends on this
	Reference Curve.  See description of Source for External.




External Spot

	Data Type:		Double

	Classes:  		Generic Commodity Class
	
		
	The Spot of the Generic External Cross which depends on this
	Reference Curve.  See description of Source for External.




Forward Curve

	Data Type:		Curve

	Classes:  		Generic Commodity Cross
	
		
	The future value of one Quantity Unit from Pricing Date in Denominated
	currency/commodity.  The curve is the Reference Curve of the
	Denominated divided by the Reference Curve of the Quantity Unit.
	Knot dates of the resulting curve are those of the lesser commodity's
	Ref. Fwd. Curve with the missing values linearly ??FIX?? interpolated.
	The lesser commodity is defined by Primary Currencies( Market ).
	
	Diddles to Forward Curve are passed through as diddles to one of the
	two Ref. Fwd. Curves.  The one diddled is the lesser of Quantity Unit
	and Denominated according to Primary Currencies( Market ).  If they
	are incomparable then Denominated is chosen as the lesser.




Forward Point

	Data Type:		Double

	Classes:  		Generic Commodity Cross
	
		
	Single point on the Forward Curve.  The value type is only
	supported when given at least one non-zero argument which is
	the date on which the forward point is desired.
	
	Interpolation for all values is done linearly from the Reference 
	Curve (not from the Forward Curve).	
	
	Diddles to the Forward Point value type effectively allow diddling
	of an individual point in the Forward Curve.  Diddles are handled
	as follows:
	
		"Forward Point( cross, PointDate ) = Value" inserts (or overwrites)
		a knot on PointDate on the lesser of the two child Reference Curves 
		s.t. Forward Point( cross, PointDate ) is Value.  A side effect of
		this is that Forward Curve( cross ) will have a knot on PointDate
		with value of Value.

		


Forward Points

	Data Type:		Relative Curve

	Classes:  		Market Forward Curve
	
		
	The list of forward points making up the Forward Curve.  The knot dates
	are relative to Market Date + Spot Days.  The knot values are converted
	to a future value in the Market Curve by multiplying by Multiplier and
	adding Spot.




Forward Resolution

	Data Type:		String

	Classes:  		Market Parameters
	
		
	The name of the object currently used to resolve all forward curves
	into implied interest rates.  The value is calculated as
	Market Prefix( Market ) + " " + Forward Resolution Base( Market ). 



Forward Resolution Base

	Data Type:		String

	Classes:  		Market Parameters
	
		
	Base part of the Forward Resolution name, by default 
	"USD Discount Curve". 



Growth Curve

	Data Type:		Curve

	Classes:  		Generic Commodity Class
	
		
	The future value of one unit of the given commodity/currency from 
	Pricing Date in the same units.  The knot dates are the same as the
	Reference Curve.  The knot values are those of the Ref. Fwd.
	Curve knots divided by the Ref. Fwd. Curve's value on Pricing Date.
	
	Diddles to Growth Curve are passed through as diddles to the 
	Reference Curve such that recalculation of Growth Curve
	results in the diddled value.  Therefore knot dates in the diddled
	Reference Curve are the same as the diddle to Growth Curve.




Implied Name

	Data Type:		String

	Classes:  		All classes
	
		
	This string is the name the object would call itself.  If the object
	is asked to rename itself, the Implied Name is gotten and used after
	any name conflicts are resolved.  The Implied Name may have one "%d"
	(or equivalent sprintf format directive, e.g., %03d would be ok)
	embedded in it.  This is used to resolve naming conflicts.  First the
	%d is replaced with "0".  If there is already an object in the
	database with the same name but which has different in stream values,
	then the %d is changed to "1".  This process is repeated until a name
	is found that doesn't conflict or an existing object is found which
	has the same in stream values.
	
	For objects where there is a great chance of name conflicts, the
	Implied Name should contain a hash string composed from all its in
	stream values.  This can be done using GobValueFuncImpliedName in
	conjunction with GobMushString and GobMushInStreamValues.  
	
	Note that any in stream values which can change without changing the
	identity of an object must be marked with the GOB_NO_MUSH flag on the
	value type.
	
	Please note that once an Implied Name algorithm is used in production
	it is quite tedious to change it, since all existing objects (and
	trades or other references on these objects) have to be changed.

	Following is an example of a typical Implied Name value function:
	
	/****************************************************************
	**  Routine: ValueFuncImpliedName
	**  Returns: TRUE or FALSE indicating success or failure, resp.
	**
	**  Value Type: Implied Name( opt )
	**
	**  Children:   All SDB_IN_STREAM Values( opt )
	**
	**  Action :    Return appropriate name
	**
	**              1234567890123456789012345678901
	**              O Cros TS K..... 22Jan92 HSHS%2d
	**	
	**				where %2d is later filled in by Gob's rename code
	**
	****************************************************************/

	static int ValueFuncImpliedName(
    	GOB_VALUE_FUNC_ARGS
	)
	{
    	SDB_VALUE
            	TempValue;

    	char    TmpBuf1[ 16 ],
            	TmpBuf2[ 16 ],
            	TmpBuf3[ 16 ],
            	TmpBuf4[ 16 ],
            	Buffer[ 2*SDB_SEC_NAME_SIZE ];  // Size checked higher up


    	switch( Msg )
    	{
        	case SDB_MSG_GET_VALUE:
            	sprintf( Buffer, "O %4.4s %.1s%.1s %s %s %4.4s%%2d",
                    	SpotCrossOut( TmpBuf1, GobGetString( SecPtr, "Cross" )),
                    	GobGetString( SecPtr, "Option Type"      ),
                    	GobGetString( SecPtr, "Option Style"     ),
                    	SpotSigOut( TmpBuf2, GobGetDouble( SecPtr, "Strike" ), 6 ),
                    	DateToString( TmpBuf3, (DATE) GobGetDouble( SecPtr, "Expiration Date" )),
                    	GobMushString( TmpBuf4, GobMushInStreamValues( SecPtr, GOB_CHILD_DATA ), 4 ));
            	TempValue.Data.Pointer  = Buffer;
            	GOB_ASSIGN;
            	return TRUE;
    	}
    	return( GobValueFuncImpliedName( SecPtr, Msg, MsgData, ValueTypeInfo ));
	}
	




Interest Rate

	Data Type:		Double

	Classes:  		Generic Commodity Class
	
		
	Single point on the Interest Rate Curve.  The value type is only
	supported when given at least one non-zero argument.  The arguments
	are as follows:
	
		Rate = Interest Rate( SecPtrCom, ToDate, FromDate )
		
	where FromDate is optional and is defaulted to 
	Pricing Date( "Security Database" ).
	
	Interpolation for all values is done linearly from the Reference 
	Curve (not from the Interest Rate Curve).  For example, in general,
	
	Interest Rate( SecPtrCom, NotAKnotDate ) 
		  			!= Interest Rate Curve( SecPtrCom )[ NotAKnotDate ]
	
	since the right hand side is interpolated from the interest rate
	curve and the left hand side is interpolated from the discount 
	curve.
	
	Diddles to the Interest Rate value type effectively allow diddling
	of an individual point in the Reference Curve.  Diddles are handled
	as follows:
	
		"Interest Rate( com, To ) = Value" inserts (or overwrites)
		a knot on To on the Reference Curve s.t. Interest Rate( com, To ) 
		is Value.  
				
		"Interest Rate( com, To, From ) = Value" inserts (or overwirtes) 
		a knot on To on the Reference Curve s.t. 
		Interest Rate( com, To, From ) is Value and 
		Interest Rate( com, From ) is unchanged.

		


Interest Rate Curve

	Data Type:		Curve

	Classes:  		Generic Commodity Class
	
		
	The continuous compounded, Actual/365 basis annual interest rate 
	from Pricing Date.  The knot values are those of the Reference 
	Curve.  The knot values are given by:
	
		knot[ i ] = ln( rfc[ i ] / rfc[ pd ] ) / Years( pd, i ),
		
		where
			knot[ i ]	is the knot value for date i
			rfc[ i ]	is the Reference Curve for date i
			pd			is Pricing Date
			Years(a,b)	is number of years from a to b, Actual/365 basis

	Diddles to Interest Rate Curve are passed through as diddles to the 
	Reference Curve such that recalculation of Interest Rate Curve
	results in the diddled value.  Therefore knot dates in the diddled
	Reference Curve are the same as the diddle to Interest Rate 
	Curve.




Invertable

	Data Type:		Double (Boolean)

	Classes:  		All tradable objects
					Crosses
	
		
	True if this object can be inverted.

	See Also:		Inverted




Inverted

	Data Type:		Double (Boolean)

	Classes:  		All tradable objects
					Crosses
	
		
	True if this object is inverted from the way the object is normally
	quoted.  The "DEM/USD" cross is not inverted, but the "USD/DEM" cross
	is inverted.  An regular option is inverted if its cross is inverted.
	An average rate option can not be inverted, so Inverted() for an
	average rate option is always 0.




Inverted Cross

	Data Type:		String

	Classes:  		Generic Commodity Cross
					Market Curve
	
		
	Quantity Unit + "/" + Denominated.
	
	E.g. Inverted Cross( "DEM/USD" ) is "USD/DEM".




Market Assembly

	Data Type:		Array of structues where each structure is
						Curve		String
						Until		Relative Date
						
	Classes:		Generic Commodity Class
					Market USD
	
	
	This value describes how to build the Reference Curve from
	market curves.  The market curves should be from Market objects, i.e.,
	objects of Market Commodity or Market Cross classes.  The idea is to
	build the generic Reference Curve which is the same for each
	commodity or currency from possibly very different market data based on
	what data we are able to observe to build the curve for that particlar
	commodity or currency.
	
	An example layout of the value for the DEM object:
	
		Curve						Until	
		------------				--------	
		DEM Cash Curve				2s
		DEM Forward Curve			2y
		DEM Swap Curve				
		
	This would instruct the Reference Curve to construct itself
	(assuming Market Prefix( Market ) is NYC Close--see value type
	Current Market Assembly) from:
	
		- Current Value( NYC Close DEM Cash Curve ) until two days from now, 
		- Current Value( NYC Close DEM Forward Curve ) resolved with 
			Current Value( NYC Close USD Discount Curve ) from two days 
			through two years from now,
		- Current Value( NYC Close DEM Swap Curve ) after two years.
	
	The source, type, basis, and compounding frequency of each curve is 
	also obtained from each respective object.



Market Cross

	Data Type:		String

	Classes:  		Generic Commodity Cross
	
		
	Name of corresponding market object, e.g. "Mkt DEM/USD" for "DEM/USD".




Market Curves

	Data Type:		Array of structures where each structure is
						ObjectName	String
						Until		Date
						Type		Double from Q_INSTR_TYPE...
						Day Count	Double from Q_ACTUAL_365...
						Frequency	Double from Q_CONTINUOUS...
						Spot Date	Date

	Classes:  		Generic Commodity Class
					Market USD
	
		
	An internal value used to create the child list of Reference
	Curve.  Market Curves contains a list of the objects used to create
	the Reference Curve (or Current Value in the case of Market USD class).
	This is constructed by inspecting Current Market Assembly.
	The type, daycount basis, and compounding 
	frequency, and spot date are obtained from each object and retained
	in Market Curves.  In addition, the Until relative date from 
	Current Market Assembly is resolved with Market Data Entry Date 
	to get the appropriate absolute date.

	An example layout of the Current Market Assembly for the DEM object:
	
		Curve								Until	
		------------						--------
		NYC Close DEM Cash Curve			2s
		NYC Close DEM Market Forward Curve	2y
		NYC Close DEM Swap Curve				
		
	would, with Market Data Entry Date of 15Mar93, produce a Market Curves value as
	follows:
	
 ObjectName  					Until    Type		 			 DayCount	  Frequency
 ------------------------		-------  ------------			 ------------ ---------
 NYC Close DEM Cash Curve		17Mar93  Q_INSTR_ZERO 			 Q_ACTUAL_365 Q_SIMPLE
 NYC Close DEM Forward Curve 	15Mar95  Q_INSTR_FORWARD_EURO
 NYC Close USD Discount Curve	15Mar95  Q_INSTR_DISCOUNT_FACTOR
 NYC Close DEM Swap Curve		DATE_ERR Q_INSTR_COUPON			 Q_ACTUAL_365 Q_ANNUAL




Market Data Entry Date

	Data Type:		Date

	Classes:  		Market Parameters
	
		
	The date that all the market data was entered, e.g., data in Market USD, 
	Market Currency, and Market Currency Cross classes.




Market Date

	Data Type:		String

	Classes:  		Market Date
					Listed Option
					Future
	
		
	The name of the Market Date object referenced by the given object.




Market Prefix

	Data Type:		String

	Classes:  		Market Parameters
	
		
	The name of the current set of market data to be used by the market
	objects.  This string is the prefix for all market objects within the
	set.  Any number of market data sets can exist simultaneously in a
	database.  The currency objects will use one of these sets based on
	the value of Market Prefix.  They do this by prepending the Market
	Prefix to all market object references.  
	
	For example, the currency object would store the general names:
	
		DEM Forward Curve
		USD Discount Curve
		
	and the database might contain several sets of market data
	
		NYC Close DEM Forward Curve
		NYC Close USD Discount Curve
		
	and
		
		TKO Close DEM Forward Curve
		TKO Close USD Discount Curve
		
	where which set to use is determined by Market Prefix.  (See also
	Current Market Assembly, Current Source for Reference Spot, Current
	Source for Volatility).	



Methods

	Data Type:		Structure

	Classes:  		Trade
					All tradable objects
	
	ValueFunc:		GobValueFuncMethods
		

	On a Trade, the Methods() structure records the how the price or
	quantity was entered for the trade.  For example, if the trader enters
	the quantity normally, but uses the Percent Premium tap field to enter
	the price, the Methods() structure will contain two entries like this:

		Quantity:	Quantity
		Price:		Percent Premium

	This information is retained so that the information can be sent to
	the mainframe and ultimately to the customer during the confirmation
	process.

	
	On a tradable object, the Methods() structure contains the default
	value for the Methods() structure for a trade on this object.  Thus,
	the Methods() structure for a tradable object usually looks like this:
	
		Quantity:	Quantity
		Price:		Price



Methods Map

	Data Type:		Structure

	Classes:  		All tradable objects
	
	ValueFunc:		GobValueFuncMethods
		
		
	The Methods Map() structure indicates which changes to the trade must
	be recorded in the Methods() structure.  Here is an example from the
	option tradable object:
	
		Strike:                     Strike
		Inverted Strike:            Strike
		Quantity:                   Quantity
		Inverted Quantity:          Quantity
		Premium:                    Price
		Inverted Premium:           Price
		Percent Premium:            Price
		Inverted Percent Premium:   Price
		Total Premium:              Price
		Inverted Total Premium:     Price
		Total Price:                Price
		Implied Volatility Percent: Price

	This structure indicates that whenever the Strike or Inverted Strike
	values are set on the trade, the Strike component of the Methods()
	structure should be updated with "Strike" or "Inverted Strike".

	This structure must contain an entry for each possible method of
	changing the price, quantity, or strike on the Tap screen.



Multiplier

	Data Type:		Double

	Classes:  		Generic Commodity Cross
					Market Forward Curve
	
		
	Factor to get normally quoted points, i.e.,
	
		Points = ( Forward Point( cross, FwdDate ) - Spot( cross )) 
				* Multiplier( cross )




Name

	Data Type:		String

	Classes:  		Generic Commodity Cross
					Market USD
	
		
	The commodity name, e.g. "DEM" for the "DEM" object, "USD" for the
	"Mkt USD" object.  This value is used by the Market Curves value type
	to pass to MktCurveDescription.




Normal Cross

	Data Type:		Double

	Classes:  		Generic Tradable Object
	
		
	If the tradable object is invertable (a normal option can be inverted
	by changing it from a put to a call, swapping the Denominated and
	Quantity Unit values, and inverting the strike), this value type
	indicates whether or not the security is inverted.  For a normal option,
	Normal Cross( option ) is the same as Normal Cross( Cross( option ) ).

	If the tradable object is not invertable, the object must still provide
	this value type with a constant value of TRUE (1.0).

	This value type is being replaced by the Inverted() and Invertable()
	value types.

	See Also:		Inverted, Invertable



Normal Quote

	Data Type:		Double

	Classes:  		Generic Commodity Cross
	
		
	Non-zero means that the cross is the usual way for spot and forward
	prices to be quoted.  Zero means that the Inverted Cross is the usually
	quoted.




Option Style

	Data Type:		String

	Classes:  		Options
	
		
	Style of option, "American" or "European".




Option Type

	Data Type:		String

	Classes:  		Options
	
		
	Type of option, "Put" or "Call".




Premium Account

	Data Type:		String

	Classes:  		Generic Commodity Class
	
		
	Profit center used by back office to track non-USD premium payments.
	Note, this profit center does not exist as a book in SecDb--it is only
	used to send premium pseudo-trades to the mainframe.  Examples are
	DMPR for DEM, JYPR for JPY, etc.




Price

	Data Type:		Double

	Classes:  		Generic Commodity Cross
					Generic Tradable Class
	
		
	Value on Pricing Date of one Quantity Unit in the Denominated currency.

	Price is usually calculated by discounting Spot Price from spot date
	to Pricing Date using the interest rate for the Denominated currency.
	GobValueFuncPrice does all of this work for you.




Quantity

	Data Type:		Double

	Classes:  		Trade
					Generic Tradable Class
	
		
	For a tradable object, Quantity should be a constant value 1.0.  For a
	trade, Quantity will be the quantity of Security Traded that has been
	traded.

	The parent trade will diddle Quantity( Security Traded( trade ) )
	before getting any value from the Security Traded which depends on
	quantity.  The tradable object should include Quantity in all value
	types which depend on quantity.  For example, Price( obj ) should
	depend on Quantity( obj ).  Also, Inverted Quantity( obj ) should
	depend on Quantity( obj ).




Quantity Unit

	Data Type:		String

	Classes:  		Generic Commodity Cross
					Generic Tradable Class
	
		
	Unit of which one is being priced by the object.  Typically a currency
	or commodity.




Reference Curve

	Data Type:		Curve

	Classes:  		Generic Commodity Class
	
		
	The future value of one unit of commodity/currency on Reference Spot
	Date( Market ) in the reference currency.  The reference currency
	(often referred to as Martian Rigolis) is an arbitrary currency that
	always has an exchange rate of one USD on Reference Spot Date( Market) 
	and pays no interest.  
	
	The Reference Curves are the repository for all diddles used
	for risk determination.  Other market values calculated from Reference
	Curves pass through any diddles on themselves down to the 
	Reference Curves.  This insures a constantly consistent model
	under any set of diddles.
	
	The Reference Curve is calculated from observable market data
	in a manner described by the Market Assembly value.  This allows the
	creation of a generic symmetrical basis for pricing and diddling, i.e.
	the Reference Curves and above, and separating out the 
	idiosyncracies of each market below Reference Curve.  The glue
	between this "messy" market stuff below and the "pretty" model above
	is the Market Assembly instructions.




Reference Spot Date

	Data Type:		Date

	Classes:  		Market Parameters
	

	The date on which USD is fixed to the reference currency at an exchange
	rate of exactly one.  
	
	Reference Spot Date is arbitrarily set to one week after Market Data Entry Date(
	Market ) using a USD calendar.  The rationale for this is to make
	sure that it is after any spot date for any USD cross and to hit a
	knot date as often as possible within the Market Forward Curve
	against dollars.  More specifically, the Reference Spot( ccy ) value
	for each currency (except USD) has to be pulled from the Market 
	Forward Curve( ccy/USD ).  This will typically have its first knot on
	Market Spot Date( ccy/USD ) and trying to interpolate before this
	knot would cause serious interpolation errors.  The Market Forward 
	Curve( ccy/USD ) will also typically have a one week (USD calendar)
	knot.




Reference Trade

	Data Type:		String

	Classes:  		Trade
	
		
	Another trade which is related to the given trade, e.g., when modifying
	prior day trades, the prior day trade's Reference Trade is the name of
	the replacement trade, and both the backout and replacement trades'
	Reference Trade are the name of the original trade.

	


Reference Type

	Data Type:		String

	Classes:  		Trade
	
		
	A text description of what relationship the Reference Trade has to the
	given trade.
	
	


Reference Volatility Curve

	Data Type:		Curve

	Classes:  		Generic Commodity Cross
	
		
	Volatility from Current Date.  The Reference Volatility Curve holds the
	diddles to Volatility Curve so that Volatility Curve can still be
	sensitive to Pricing Date.




Relative Value

	Data Type:		Relative Curve

	Classes:  		Market Curve
	
		
	Entered market values with relative and/or fixed dates.  Relative dates
	are from the Spot Date of same object.




Securities

	Data Type:		Array of Structures

	Classes:  		All tradable objects
	
		
	Actually, there is no Securities() value type, but there are
	Exercise Securities(), Assign Securities(), ... value types.  These
	value types are referenced by the Trade Types Binary() value type
	and contain information about additional securities associated with
	the trade.  For example, Exercise Securities() of an currency Option
	will contain two forward objects, Quantity() of Quantity Unit() and 
	-Strike() * Quantity() of Denominated() because the owner of the
	Option will get 1 of the Quantity Unit() in exchange for Strike() of
	the Denominated().  Note that when the Option is cash settled, there
	will be only one forward of Quantity Unit() whose quantity is
	determined by the current spot rate.

	There is no Buy Securities() because Trades use the information in
	Trade Types Binary() to automatically include the proper effect for
	the primary security traded.




Security Name

	Data Type:		String

	Classes:  		All Classes
	
		
	The name of the security.




Security Type

	Data Type:		String

	Classes:  		All Classes
	
		
	The type of the security.




Smallest Valid Fraction

	Data Type:		Double

	Classes:  		Generic Commodity Class
	
		
	Smallest valid unit amount, e.g. 0.01 for USD, 1 for ITL or JPY, etc.
	This is used when making a payment, amounts are either truncated or
	rounded to the nearest valid fraction.  See Truncate Fraction value
	type.




Source for External

	Data Type:		String

	Classes:  		Generic Commodity Class
	
		
	Name of object that has its Spot and Forward Curve values flagged as
	External which are calculated from this object.  The Source for External
	is the object that would typically be diddled for Spot and/or Forward
	Curve sensitivities to the given object.
	
	Example:
	
	Say a tradeable object, Foo, depends for its Dollar Price on 
	Spot( DEM/GBP ).  Typically, when reporting Foo's sensitivities we would
	like to list not Spot( DEM/GBP ), but Spot( DEM/USD ) and 
	Spot( USD/GBP ), i.e., when getting the External children of 
	Dollar Price( Foo ) we want to see Spot( DEM/USD ) and Spot( USD/GBP )
	and not Spot( DEM/GBP ).  This works because Source for External( DEM )
	is DEM/USD and Source for External( GBP ) is USD/GBP.  How it works
	is that Spot( DEM/GBP ) has included in its child list redundant entries
	for External Spot( DEM ) and External Spot( GBP ) which each in turn
	depend on the External flagged spots:
	
	Dollar Price( Foo )
		...

		Spot( DEM/GBP )
			...
			
			External Spot( DEM )
				Spot( Source for External( DEM ))
					== Spot( DEM/USD ) [Flags include: SDB_EXTERNAL]
					
			External Spot( GBP )
				Spot( Source for External( GBP ))
					== Spot( USD/GBP ) [Flags include: SDB_EXTERNAL]
			




Source for Reference Spot

	Data Type:		String

	Classes:  		Generic Commodity Class
	
		
	Name of corresponding market object that supplies Reference Spot, e.g. 
	"DEM Forward Curve" for "DEM".  The	class of the market object is 
	not fixed, allowing different underlying models.  However, the market 
	object must support Reference Spot.  The Source for Reference Spot
	value is appended to the current Market Prefix( "Market" ) to get the
	actual name of the object supplying the reference spot--this is the 
	Current Source for Reference Spot value type.




Source for Volatility

	Data Type:		String

	Classes:  		Generic Commodity Cross
	
		
	Name of corresponding market object that supplies the market volatility
	curve, e.g. "DEM/USD Mkt Volatility" for "DEM/USD".  The class of the 
	market object is not fixed, allowing different underlying models.  
	However, the market object must support Current Value which is the
	volatility from Market Data Entry Date.  The Source for Volatility
	value is appended to the current Market Prefix( "Market" ) to get the
	actual name of the object supplying the vol curve--this is the 
	Current Source for Volatility value type.




Spot

	Data Type:		Double

	Classes:  		Generic Commodity Cross
					Many tradable objects

	ValueFunc:		SpotValueFuncSpot	(for tradable objects)
	
		
	Future value on Spot Date of one Quantity Unit from Pricing Date in 
	the Denominated currency.
	
	Diddles to Spot (of crosses) are passed through to ...FIX

	For a tradable object, Spot() is usually calculated as Spot( Cross() ).




Spot Date

	Data Type:		Date

	Classes:  		Generic Commodity Cross
					Market Curve
	
		
	Given Pricing Date as now, date on which spot transactions settle.




Spot Days

	Data Type:		Relative Date

	Classes:  		Generic Commodity Cross
					Market Curve
	
		
	Number of days from now to spot date.




Spot Price

	Data Type:		Double

	Classes:  		Generic Tradable Class
	
		
	Value on Spot Date of one Quantity Unit in the Denominated currency.
	Spot Price should include a dependency on Quantity.

	Spot Price can also be thought of as the "Traded Price".




Strike

	Data Type:		Double

	Classes:  		Options

	ValueFunc:		SpotValueFuncStrike
	
		
	Strike of option.

	See Also:		Normal Strike(), Inverted Strike().




Tap Display Values

	Data Type:		Array of EditInfo

	Classes:  		All tradable objects

	ValueFunc:		GobValueFuncEditInfo
	
		
	Tap Display Values() is an array of EditInfo structures.  Each structure
	names a value which will be displayed by default for this type of
	tradable object in the main Tap window.




Tap Edit Information

	Data Type:		Array of EditInfo

	Classes:  		All tradable objects

	ValueFunc:		GobValueFuncEditInfo
	
		
	Tap Edit Information() defines the edit table used by Tap.  This is
	changing and will soon be stored in an object in the database.




Time Created

	Data Type:		Time

	Classes:  		All Classes
	
		
	The local time when the object was created.  This value will be 0
	if the object has not been written to disk yet.

	See Also:		Database Created, Time Created




Time Modified

	Data Type:		Time

	Classes:  		All Classes
	
		
	The local time when the object was last updated.  This value will
	be 0 if the object has not been never been updated.

	See Also:		Database Updated, Time Created




Trade Types Binary

	Data Type:		Binary

	Classes:  		All tradable objects

	ValueFunc:		GobValueFuncConstant
	
		
	The Trade Types Binary() value type contains information about possible
	types of trades on this tradable object.  All objects should support
	Buy and Sell.  Options also support Expire, Exercise, and Assign.  This
	value is initialized from an array of TRADE_TYPE_INFO structures which
	is documented in <trade.h>.

	See Also:		Securities




Truncate Fraction

	Data Type:		Double

	Classes:  		Generic Commodity Class
	
		
	A non-zero value means that payment amounts less than Smallest Valid
	Fraction should be truncated.  Typically 0, i.e. FALSE, except for 
	JPY.



		
Unit Name

	Data Type:		String
		
	Classes:  		Generic Commodity Class
	
	
	The name of one unit of the object.




Volatility

	Data Type:		Double

	Classes:  		Generic Commodity Cross
					Options

	ValueFunc:		SpotValueFuncVolatility
	
		
	For crosses:
		Single point on the Volatility Curve.  The value type is only
		supported when given at least one non-zero argument which is
		the date on which the volatility is desired.
	
		Diddles to the Volatility value type effectively allow diddling
		of an individual point in the Volatility Curve.  Diddles are
		handled as follows:
	
			"Volatility( cross, VolDate ) = Value" inserts (or overwrites)
			a knot on VolDate on the Volatility Curve which in turn inserts
			the knot on the Reference Volatility Curve s.t. 
			Volatility( cross, VolDate ) is Value and the other knots on
			Volatility Curve are unchanged.

	For options:
		Typically, this is the volatility of the option on expiration date.
		Of course, for average rate options, it is different.

		


Volatility Curve

	Data Type:		Curve

	Classes:  		Generic Commodity Cross
	
		
	Volatility from Pricing Date.  Diddles to Volatility Curve are passed
	through to Reference Volatility Curve so that Volatility Curve remains
	sensitive to Pricing Date even with diddles on it.



