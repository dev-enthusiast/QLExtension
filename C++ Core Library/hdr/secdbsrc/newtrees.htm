<h1>New Trees</h1>
<p>
The upcoming SecDb installation contains extensive changes to the core SecDb
implementation and to many of its major API points.  The crux of these core
changes is the way it performs calculation graph traversal for calculated
values--hence the name <em>New Trees</em>.
<p>
More than a million lines of C code alone depend on SecDb, so any API change
is dramatic.  But sometimes maintaining backward compatibility severely
hampers the ability to make far-reaching changes and keeping two concurrent
API sets is confusing and ugly.  Anyway, this is one of those cases where
change is better.
Our apologies for the upheaval, but we trust you will love the new features.


<h2>Motivation</h2>
<p>
Most of the changes revolve around the desire to greatly enhance a value
type's
ability to specify complex children.  Utmost was our desire to handle
argmuments to value types in the full generality available to someone
calling a C or Slang routine and at the same time to 
also be able to use that as a value's
child.  Concurrently, we wanted to redesign the core calculation graph
traversal to use an invalidation mechanism instead of the current time-stamp
method.

<h3>Arguments</h3>
<p>
Value types can now accept any number of arguments of any type.  Previously
the number of arguments was limited to two and constrained to fit in a long
integer.  The arguments are each named and have their datatypes specified
by the value type code.  A default value (typically another calculated value
of the object) is also always specified on a per-class basis.

<h3>Child Lists</h3>
<p>
Each calculated value in SecDb provides a list of the child values it needs
in order to calculate itself.  Previously the specification of these
children was severely limited.  A lot of ugly code was written to bypass
these limitations.  We couldn't do recursive where clauses, conditional
children, dependencies across databases, or multiple children on the same
value but with different args.  All this is now possible (and more!).
New functionality includes:
<ul>
<li>
Accepting
arguments to supplant certain children and/or to pass along to child values.
(Note the supplanted children are exactly the default values for the
arguments.)
<li>
Passing arguments to children.  These arguments in turn can be other complex
(or simple) children, passed-in arguments, or constants.
<li>
The value type and/or the object name of the child can be calculated in the
same general way that arguments are.
</ul>

<h3>New Graph Traversal Method</h3>
<p>
The new graph traversal algorithm is invalidation based instead of
time-stamp based and, of course, provides full native support for all
the new argument functionality (including caching values with arguments).
Previously a calculated value had to
recursively check the validity of all its antecedants before deciding
wether to recalculate.  The new algorithm marks all the affected cache
nodes as invalid when a value is changed anywhere in the SecDb graph.
<p>
This new algorithm has several advantages: 

<ul>
<li>
One can argue that it
is more intuitive and therefore easier to understand when diagnosing
unexpected behavior (even when it is correct).  And a lot of tools have
been added to see exactly what is going on in the SecDb engine.
<li>
Any query will tend to be as fast as possible without any tuning.  Previously
a developer had to iteratively redesign reports and object classes to obtain
the desired performance.
<li>
Invalidation bugs have been eliminated.  Previously, severe tuning of the
time-stamp code in combination with the contortions used to bypass the
lack of arguments in child lists exposed some obscure invalidation bugs
in the SecDb engine (which came up in not-so-obscure applications).
</ul>

<h3>General Cleanup</h3>
<p>
Of course, whenever sweeping changes are being made to millions of lines
of code, it's a great opportunity to clean up old stuff and tack on those
great enhancements which might affect a lot of code, but in themselves
wouldn't be worth the effort.  In addition, we are using some of the
new features to fix some of the most egregious work-arounds.
<p>
Cleanup and ambulance-chasing stuff in this installation includes redesign
of Trade internals, using conditional evaluation in fx options, and
spiffing up argument handling for Slang built-in functions.  And, last but
certainly not least, the big cleanup of tsdb (not included in this doc).

<h3>Developer Transparency</h3>
<p>
As more and more people are using and developing for SecDb, and as people
start taking advantages of the new features to make more complex models,
and as current SecDb folks want to understand why everything is suddenly
broken, we thought it best to put a lot more tools in place to see just
how everything works.  Along this vein are:

<ul>
<li>
Tracing capability.  See what SecDb is calculating, why, and when.  This
is available in Slang (new TraceOn function) and thoughout SecView (e.g.,
F7 from the value type list for an object).
<li>
Graph viewing.  Secview now can take you anywhere in the value cache
graph and show everything you want to know (and more!).
<li>
Child list descriptions.  Use the ValueTypeChildDescription or
ValueTypeChildInfo functions in Slang or hit F5 from the value type list
for an object in Secview.  Also available from the graph viewer.
<li>
Miscellaneous stuff throughout the changes, e.g., FunctionInfo.
</ul>

	
<h2>API Changes Quicklist</h2>
<h3>Obsolete and Changed</h3>
<Table>
	<tr><th colspan=2>C Functions
	<tr><td>GobCacheValue					
	</td><td>now a macro instead of a function
	<tr><td>GobChildIsLiteral				
	</td><td>obsolete
	<tr><td>GobChildListAdd					
	</td><td>obsolete
	<tr><td>GobChildListAddWhere			
	</td><td>obsolete
	<tr><td>GobChildPassErrors				
	</td><td>obsolete
	<tr><td>GobClearRetainedValue			
	</td><td>now a macro instead of a function
	<tr><td>GobFreeChildList				
	</td><td>obsolete
	<tr><td>GobGetCacheFlags				
	</td><td>now a macro instead of a function
	<tr><td>GobRemoveCachedValue			
	</td><td>now a macro instead of a function
	<tr><td>GobSetValue						
	</td><td>now a macro instead of a function
	<tr><td>GobSetValueByType				
	</td><td>now a macro instead of a function
	<tr><td>
	<a href="http://stratwww.jany.gs.com/techdocs/auto/secdb5.html#secdbchangediddle">
	SecDbChangeDiddle	 
	</a>			
	</td><td>arguments changed
	<tr><td>
	<a href="http://stratwww.jany.gs.com/techdocs/auto/secdb5.html#secdbduplicate">
	SecDbDuplicate
	</a>			
	</td><td>additional SetFlags argument
	<tr><td>
	<a href="http://stratwww.jany.gs.com/techdocs/auto/secdb5.html#secdbgetvalue">
	SecDbGetValue
	</a>
	</td><td>arguements and return type changed
	<tr><td>SecDbRemoveCachedValue			
	</td><td>obsolete
	<tr><td>SecDbSetCachedValue				
	</td><td>obsolete
	<tr><td>
	<a href="http://stratwww.jany.gs.com/techdocs/auto/secdb7.html#secdbsetdiddle">
	SecDbSetDiddle					
	</a>
	</td><td>arguments changed
	<tr><td>
	<a href="http://stratwww.jany.gs.com/techdocs/auto/secdb7.html#secdbsetvalue">
	SecDbSetValue					
	</a>
	</td><td>arguments changed
	<tr><td>SecDbSetValueWithFlags			
	</td><td>obsolete
	<tr><td>
	<a href="http://stratwww.jany.gs.com/techdocs/auto/secdb7.html#secdbshutdown">
	SecDbShutdown					
	</a>
	</td><td>has new FastAndDirty argument
	<tr><td>SecViewShowChildren				
	</td><td>arguments changed
	<tr><td>SlangArgError					
	</td><td>arguments changed
	<tr><th colspan=2>Gob child macros
	<tr><td>GOB_CHILD_DATA					
	</td><td>changed
	<tr><th colspan=2>C Data Structures
	<tr><td>SDB_CHILD_INFO					
	</td><td>changed
	<tr><td>SDB_CHILD_LIST_ELEMENT			
	</td><td>obsolete
	<tr><td>SDB_DIDDLE						
	</td><td>obsolete
	<tr><td>SDB_DYNAMIC_CHILD_LIST			
	</td><td>obsolete
	<tr><td>SDB_DYNAMIC_FIXUP				
	</td><td>obsolete
	<tr><td>SDB_OBJECT						
	</td><td>changed
	<tr><td>SDB_TIME_STAMP					
	</td><td>obsolete
	<tr><td>SDB_VALUE_CACHE					
	</td><td>obsolete
	<tr><td>SDB_VALUE_CACHE_ELEMENT			
	</td><td>obsolete
	<tr><td>SDB_VALUE_PARAMS				
	</td><td>obsolete
	<tr><td>SDB_VALUE_TYPE_INFO				
	</td><td>changed
	<tr><td>SDB_VALUE_TYPE_MAP				
	</td><td>changed
	<tr><td>SLANG_RET						
	</td><td>changed
	<tr><td>SLANG_SCOPE_DIDDLE				
	</td><td>changed
	<tr><th colspan=2>C Value type flags
	<tr><td>SDB_DYNAMIC						
	</td><td>moribund
	<tr><td>SDB_HIDDEN						
	</td><td>moribund
	<tr><th colspan=2>C Cache flags
	<tr><td>SDB_CACHE_PASS_THROUGH			
	</td><td>now multiple bits
	<tr><td>SDB_CACHE_STATIC				
	</td><td>obsolete
	<tr><th colspan=2>Object messages
	<tr><td>SDB_M_DIDDLE					
	</td><td>changed
	<tr><td>SDB_M_GET_CHILD_LIST			
	</td><td>obsolete
	<tr><td>SDB_M_GET_VALUE					
	</td><td>changed
	<tr><td>SDB_M_LOAD						
	</td><td>changed
	<tr><td>SDB_M_SET_VALUE					
	</td><td>changed
	<tr><th colspan=2>UFOs
	<tr><td>GetValue						
	</td><td>changed semantics
	<tr><td>SetValue						
	</td><td>changed semantics
	<tr><th colspan=2>Miscellaneous
	<tr><td>datatype.dat					
	</td><td>now checked for dups
	<tr><td>SDB_OBJECT_SET					
	</td><td>obsolete
</Table>
	
<h3>New</h3>
<Table>
	<tr><th colspan=2>C Functions
	<tr><td>GobArgA							
	</td><td>Used by GOB_ARG_A macros
	<tr><td>GobArgC							
	</td><td>Used by GOB_ARG_C macros
	<tr><td>GobArgL							
	</td><td>Used by GOB_ARG_L macros
	<tr><td>GobArgV							
	</td><td>Used by GOB_ARG_V macros
	<tr><td>GobChildConstant				
	</td><td>Used by GOB_CHILD_C macros
	<tr><td>GobChildIntermediate			
	</td><td>Used by GOB_CHILD_V macros
	<tr><td>GobChildIntermediateIndirect	
	</td><td>Used by GOB_CHILD_VI macros
	<tr><td>GobChildLiteral					
	</td><td>Used by GOB_CHILD_L macros
	<tr><td>GobChildSelf					
	</td><td>Used by GOB_CHILD_R macros
	<tr><td>GobChildSelfIndirect			
	</td><td>Used by GOB_CHILD_RI macros
	<tr><td>GobMemoryUsage					
	</td><td>Report memory used by Gob
	<tr><td>
	<a href="http://stratwww.jany.gs.com/techdocs/auto/secdb5.html#secdbsanitycheck">
	SecDbCacheSanityCheck			
	</a>
	</td><td>Check that there are no cache graph errors
	<tr><td>
	<a href="http://stratwww.jany.gs.com/techdocs/auto/secdb5.html#secdbchangediddlewithargs">
	SecDbChangeDiddleWithArgs		
	</a>
	</td><td>Change a previous diddle to a value with args
	<tr><td>
	<a href="http://stratwww.jany.gs.com/techdocs/auto/secdb5.html#secdbgetvaluewithargs">
	SecDbGetValueWithArgs			
	</a>
	</td><td>Get a value with args
	<tr><td>
	<a href="http://stratwww.jany.gs.com/techdocs/auto/secdb5.html#secdbinvalidate">
	SecDbInvalidate					
	</a>
	</td><td>Mark a value and all its decsendants invalid
	<tr><td>
	<a href="http://stratwww.jany.gs.com/techdocs/auto/secdb5.html#secdbmemoryusage">
	SecDbMemoryUsage				
	</a>
	</td><td>Report memory usage by SecDb and its components
	<tr><td>
	<a href="http://stratwww.jany.gs.com/techdocs/auto/secdb5.html#secdbnodeenumclose">
	SecDbNodeEnumClose				
	</a>
	</td><td>Close cache node enumeration
	<tr><td>
	<a href="http://stratwww.jany.gs.com/techdocs/auto/secdb5.html#secdbnodeenumfirst">
	SecDbNodeEnumFirst				
	</a>
	</td><td>Start cache node enumeration
	<tr><td>
	<a href="http://stratwww.jany.gs.com/techdocs/auto/secdb5.html#secdbnodeenumnext">
	SecDbNodeEnumNext				
	</a>
	</td><td>Continue cache node enumeration
	<tr><td>
	<a href="http://stratwww.jany.gs.com/techdocs/auto/secdb5.html#secdbnodetext">
	SecDbNodeText					
	</a>
	</td><td>Text name of a cache node
	<tr><td>
	<a href="http://stratwww.jany.gs.com/techdocs/auto/secdb5.html#secdbremovediddlewithargs">
	SecDbRemoveDiddleWithArgs		
	</a>
	</td><td>Remove a previous diddle to a value with args
	<tr><td>
	<a href="http://stratwww.jany.gs.com/techdocs/auto/secdb5.html#secdbsetdiddlewithargs">
	SecDbSetDiddleWithArgs			
	</a>
	</td><td>Set a diddle on a value with args
	<tr><td>
	<a href="http://stratwww.jany.gs.com/techdocs/auto/secdb5.html#secdbsetvaluewithargs">
	SecDbSetValueWithArgs			
	</a>
	</td><td>Set a value with args
	<tr><td>SecViewShowCacheNode			
	</td><td>Interactive display of cache node
	<tr><td>SecViewTraceEnd					
	</td><td>Stop tracing
	<tr><td>SecViewTraceStart				
	</td><td>Start tracing, SecView style
	<tr><td>SlangArgParse					
	</td><td>New function called by SLANG_ARG_PARSE()
	<tr><td>SlangFunctionInfo				
	</td><td>Return structure of info about a built-in Slang function
	<tr><th colspan=2>Gob child macros
	<tr><td>GOB_ARG_A						
	</td><td>Pass along a passed-in arg
	<tr><td>GOB_ARG_CN						
	</td><td>Pass a numeric constant
	<tr><td>GOB_ARG_CP						
	</td><td>Pass a pointer constant
	<tr><td>GOB_ARG_L						
	</td><td>Pass a literal
	<tr><td>GOB_ARG_L1						
	</td><td>Pass a literal with one arg
	<tr><td>GOB_ARG_L2						
	</td><td>Pass a literal with two args
	<tr><td>GOB_ARG_NULL					
	</td><td>Pass a DtNull
	<tr><td>GOB_ARG_R						
	</td><td>Pass a reflexive value
	<tr><td>GOB_ARG_R1						
	</td><td>Pass a reflexive value with one arg
	<tr><td>GOB_ARG_R2						
	</td><td>Pass a reflexive value with two args
	<tr><td>GOB_ARG_V						
	</td><td>Pass a value
	<tr><td>GOB_ARG_V1						
	</td><td>Pass a value with one arg
	<tr><td>GOB_ARG_V2						
	</td><td>Pass a value with two args
	<tr><td>GOB_CHILD_A						
	</td><td>GOB_CHILD_R that can be supplanted by next passed-in arg (same as GOB_CHILD_RA)
	<tr><td>GOB_CHILD_CN					
	</td><td>Numeric constant child
	<tr><td>GOB_CHILD_CNA					
	</td><td>GOB_CHILD_CN that can be supplanted by next passed-in arg
	<tr><td>GOB_CHILD_CP					
	</td><td>Pointer constant child
	<tr><td>GOB_CHILD_CPA					
	</td><td>GOB_CHILD_CP that can be supplanted by next passed-in arg
	<tr><td>GOB_CHILD_DATA0					
	</td><td>Uncast ChildData (what previously was GOB_CHILD_DATA)
	<tr><td>GOB_CHILD_L1					
	</td><td>Literal child with one arg
	<tr><td>GOB_CHILD_L2					
	</td><td>Literal child with two args
	<tr><td>GOB_CHILD_LA					
	</td><td>GOB_CHILD_L that can be supplanted by next passed-in arg
	<tr><td>GOB_CHILD_R1					
	</td><td>Reflexive child with one arg
	<tr><td>GOB_CHILD_R2					
	</td><td>Reflexive child with two args
	<tr><td>GOB_CHILD_RA					
	</td><td>GOB_CHILD_R that can be supplanted by next passed-in arg
	<tr><td>GOB_CHILD_RI					
	</td><td>Indirect reflexive child
	<tr><td>GOB_CHILD_RI1					
	</td><td>Indirect reflexive child with one arg
	<tr><td>GOB_CHILD_RI2					
	</td><td>Indirect reflexive child with two args
	<tr><td>GOB_CHILD_V1					
	</td><td>Value child with one arg
	<tr><td>GOB_CHILD_V2					
	</td><td>Value child with two args
	<tr><td>GOB_CHILD_VA					
	</td><td>GOB_CHILD_V that can be supplanted by next passed-in arg
	<tr><td>GOB_CHILD_VI					
	</td><td>Indirect value child
	<tr><td>GOB_CHILD_VI1					
	</td><td>Indirect value child with one arg
	<tr><td>GOB_CHILD_VI2					
	</td><td>Indirect value child with two args
	<tr><td>GOB_CHILD_VPE					
	</td><td>Value child, pass errors
	<tr><th colspan=2>C Data Structures
	<tr><td>SDB_CHILD_ITEM_REF				
	</td><td>Used for constructing child lists
	<tr><td>SDB_CHILD_REF					
	</td><td>Used for constructing child lists
	<tr><td>SDB_CHILD_REF_DATA				
	</td><td>Used for constructing child lists
	<tr><th colspan=2>C Value type flags
	<tr><td>SDB_ALIAS						
	</td><td>Same as only child
	<tr><td>SDB_STORED						
	</td><td>SDB_IN_STREAM | SDB_SET_RETAINED which are almost used in combination
	<tr><th colspan=2>C Cache flags
	<tr><td>SDB_CACHE_DIDDLE				
	</td><td>Cached value is a diddle
	<tr><td>SDB_CACHE_NO_FREE				
	</td><td>Do not free value when invalidating cache node
	<tr><td>SDB_CACHE_SET_NO_MESSAGE		
	</td><td>Set value without calling value function
	<tr><th colspan=2>C Slang macros
	<tr><td>SLANG_ARG_BLOCK					
	</td><td>Argument is a bound block
	<tr><td>SLANG_ARG_LVALUE				
	</td><td>Argument is an lvalue
	<tr><td>SLANG_ARG_OMITTED				
	</td><td>Shortcut for oft-used SLANG_VAL(n).DataType == DtNull
	<tr><td>SLANG_ARG_VARIABLE				
	</td><td>Argument is a variable (VAR_FLAG | ARG_BLOCK)
	<tr><td>SLANG_ARG_VAR_FLAG				
	</td><td>Argument is a variable
	<tr><td>SLANG_BLOCK_EVAL				
	</td><td>Evaluate block
	<tr><td>SLANG_BLOCK_RET					
	</td><td>Where the result of block evaluation is stored
	<tr><td>SLANG_LVALUE					
	</td><td>Use evaluated lvalue (for SLANG_ARG_LVLAUE)
	<tr><th colspan=2>Data types
	<tr><td>DtDynamicNumbers				
	</td><td>Used internally by SecDb for GOB_CHILD_V type children where vt is DtSecurityList
	<tr><td>DtDynamicPointers				
	</td><td>Used internally by SecDb for GOB_CHILD_V type children where vt is DtSecurityList
	<tr><td>DtPassThrough					
	</td><td>Used internally by SecDb for duplicate values
	<tr><td>DtSecurity						
	</td><td>New datatype to represent a SecPtr
	<tr><td>DtSecurityList					
	</td><td>New datatype to represent a list of SecPtrs
	<tr><td>DtValueType						
	</td><td>New datatype to represent a value type
	<tr><td>DT_SECURITY_LIST				
	</td><td>Data structure for DtSecurityList
	<tr><td>DT_SLANG						
	</td><td>New alias for SLANG_DATA_TYPE
	<tr><th colspan=2>UFOs
	<tr><td>UfoArg							
	</td><td>Function for handling arguments to UFO value functions
	<tr><td>UfoChild						
	</td><td>Function for using a variable as an alias to a child in a UFO value function
	<tr><th colspan=2>Slang built-in functions
	<tr><td>ForCacheNode					
	</td><td>Iterate through all the CacheNodes
	<tr><td>FunctionInfo					
	</td><td>Get structured information about built-in function
	<tr><td>GetValueWithArgs					
	</td><td>GetValue with arguments (extra args to GetValue already mean something else)
	<tr><td>MemoryUsage						
	</td><td>Report memory usage by component
	<tr><td>TableInit						
	</td><td>New additional functionality -- recursive tables
	<tr><td>TraceOn							
	</td><td>Trace all SecDb activity
	<tr><td>ValueTypeChildInfo				
	</td><td>Return child list data
	<tr><td>ValueTypeDescription			
	</td><td>Return value type description
</Table>
 

<h2>How To Change</h2>

<h3>SecDbGetValue</h3>
<p>
SecDbGetValue (and its new companion function SecDbGetValueWithArgs)
now returns a pointer to the DT_VALUE value cache within SecDb.
<p>
A simple example of getting a value which is a String (i.e., data type <em>String</em>).
<br><em>Before:</em>
<pre>
	SDB_SET_VALUE_PARAMS( &ValueParams, ValueType, 0, 0 )
	Status = SecDbGetValue( SecPtr, &ValueParams, &Data, NULL );
</pre>			
<em>After:</em>
<pre>
	Value = SecDbGetValue( SecPtr, ValueType );
	Status = Value != NULL;
	Data = (char *) Value->Data.Pointer;
</pre>			
<p>
An example of getting a value which is a Double and has one Date arg.
(If you are doing this in a value function, DON'T!  Use GOB_CHILD_V1
or whatever similar GOB_CHILD macro is appropriate.)
<br><em>Before:</em>
<pre>
	SDB_SET_VALUE_PARAMS( &ValueParams, ValueType, TradeDate, 0 )
	Status = SecDbGetValue( SecPtr, &ValueParams, &Data, NULL );
</pre>			
<em>After:</em>
<pre>
	Argv                  = &ArgArray;
	ArgArray[ 0 ]         = &TmpValue;
	TmpValue.DataType	  = DtDate;
	TmpValue.Data.Number  = TradeDate;
	Value = SecDbGetValueWithArgs( SecPtr, ValueType, 1, Argv );
	Status = Value != NULL;
	Data = Value->Data.Number;
</pre>			


<h3>SecDbSetValue</h3>
<p>
SecDbSetValue (and its new companion function SecDbSetValueWithArgs)
now take a DT_VALUE and cache flags.  The new flags argument makes
SecDbSetCachedValue and SecDbSetValueWithFlags obsolete.

<p>
Simple SetValue example--setting a string value.
<br><em>Before:</em>
<pre>
	SDB_SET_VALUE_PARAMS( &ValueParams, ValueType, 0, 0 )
	Status = SecDbSetValue( SecPtr, &ValueParams, &Data );
</pre>			
<em>After:</em>
<pre>
	Value.DataType     = DtString;
	Value.Data.Pointer = Data;
	Status = SecDbSetValue( SecPtr, ValueType, &Value, 0 );
</pre>			
	
<p>
Simple SetCachedValue example--setting a string value.
<br><em>Before:</em>
<pre>
	SDB_SET_VALUE_PARAMS( &ValueParams, ValueType, 0, 0 )
	Status = SecDbSetCachedValue( SecPtr, &ValueParams, &Data, SDB_CACHE_SET );
</pre>			
<em>After:</em>
<pre>
	Value.DataType     = DtString;
	Value.Data.Pointer = Data;
	Status = SecDbSetValue( SecPtr, ValueType, &Value, SDB_CACHE_SET | SDB_SET_NO_MESSAGE );
</pre>			

<p>
Simple SetValueWithFlags example--setting a string value.
<br><em>Before:</em>
<pre>
	SDB_SET_VALUE_PARAMS( &ValueParams, ValueType, 0, 0 )
	Status = SecDbSetValueWithFlags( SecPtr, &ValueParams, &Data, SDB_SET_INTERACTIVE );
</pre>			
<em>After:</em>
<pre>
	Value.DataType     = DtString;
	Value.Data.Pointer = Data;
	Status = SecDbSetValue( SecPtr, ValueType, &Value, SDB_SET_INTERACTIVE );
</pre>			



<h3>SecDbSetDiddle</h3>
<p>
SecDbSetDiddle and SecDbChangeDiddle (and their new companion functions SecDbSetDiddleWithArgs and SecDbChangeDiddleWithArgs)
now take a DT_VALUE and cache flags.  The new flags argument allows for
efficient value managment (with SDB_CACHE_NO_COPY, SDB_CACHE_NO_FREE) and 
special interactive diddle functionality (with SDB_SET_INTERACTIVE).

<p>
Simple SetDiddle, ChangeDiddle, RemoveDiddle example--diddling a structure value.
<br><em>Before:</em>
<pre>
	DTM_ALLOC( &StructVal, DtStructure );
	DTM_ALLOC( &NewStructVal, DtStructure );
	...
	Data = StructVal.Data.Pointer;
	SDB_SET_VALUE_PARAMS( &ValueParams, ValueType, 0, 0 )
	DiddleID = SecDbSetDiddle( SecPtr, &ValueParams, &Data, SDB_DIDDLE_ID_NEW );
	DTM_FREE( &StructVal );
	if( DiddleID == SDB_DIDDLE_ID_ERROR )
		// Handle error
	...
	Data = NewStructVal.Data.Pointer;
	if( !SecDbChangeDiddle( SecPtr, &ValueParams, &Data, DiddleID ))
		// Handle error
	DTM_FREE( &NewStructVal );
	...	
	SecDbRemoveDiddle( SecPtr, &ValueParams, DiddleID );
</pre>			
<em>After:</em>
<pre>
	DTM_ALLOC( &StructVal, DtStructure );
	DTM_ALLOC( &NewStructVal, DtStructure );
	...
	DiddleID = SecDbSetDiddle( SecPtr, ValueType, &StructVal, SDB_CACHE_NO_COPY, SDB_DIDDLE_ID_NEW );
	if( DiddleID == SDB_DIDDLE_ID_ERROR )
		// Handle error
	...
	if( !SecDbChangeDiddle( SecPtr, ValueType, &NewStructVal, SDB_CACHE_NO_COPY, DiddleID ))
		// Handle error
	...	
	SecDbRemoveDiddle( SecPtr, ValueType, DiddleID );
</pre>			


<h2>Object Changes</h2>
<h3>Where clauses</h3>
<p>
Where clauses (the old and still supported mechanism for passing a number
of arguments) implementation has changed which has caused a slight change
in semantics.  Previously, where clauses used specific value type names in
the target object to tag each argument, thus making the order of 
specification irrelevant.  With new trees where clauses are
implemented as mere arguments and thus are order dependent.  Therefore,
where clause specifications (the GOB_WHERE_INFO array) must be made in
the same order as the arguments are specified in the target value.  
<em>We
have found that this is the top cause of problems once a project compiles.</em>
<p>
Note that UFO handling is changed for the same reason.  Previously, where
clauses in UFOs where specified as a structure which has no ordering.  Now
they must be an array.  There is a new UFO function @WHERE to handle the new
where clause arrays.

<h3>UFOs</h3>
<p>
UFOs Slang code typically needed to be modified to work with new trees.  This
is because both 1) current code does illegal things which are now checked and
complained about, and 2) to handle new functionality regarding arguments.

<p>
In the first category is code that does explicit GetValues or uses
intermediate variables.
Here is a typical example:
<pre>
x = Dollar Cross( Self );
Normal = Normal Cross( x );
</pre>
This caused SecDb to not pick up Normal Cross( Dollar Cross( Self )) as a
dependency.  New Trees correctly complains about this.  
The fix, which works in both old and new trees:
<pre>
Normal = Normal Cross( Dollar Cross( Self ));
</pre>
And now with New Trees, a new Ufo function has been added for
convenience, UfoChild:
<pre>
UfoChild( x, Dollar Cross( Self ));
Normal = Normal Cross( x );
</pre>

<p>
In the second category is the where clause handling (discussed above)
and the new UfoArg function for accepting arguments:
<br><em>Before:</em>
<pre>
Foo UFO::ExerciseSec = Func(
	Self,
	VTI,
	TradeDate
)
{
	if( !Defined( TradeDate ))
		TradeDate = Pricing Date( "Security Database" )
	:
		TradeDate = Date( TradeDate );
</pre>
<br><em>After:</em>
<pre>
Foo UFO::ExerciseSec = Func(
	Self,
	VTI,
	TradeDate
)
{
	UfoArg( TradeDate, Pricing Date( "Security Database" ));
</pre>

<p>
With New Trees, SetValue calls in UFO value function must be of the form
SetValue( ValueMethodName, SecPtr, Value ).  The more common form
SetValue( ValueMethod( SecPtr ), Value ) is not supported within UFOs.

<h3>Trade</h3>
<p>
The Trade class internals have been reimplemented to take advantage
of the functionality available with New Trees.  Previously, Trade went
through a lot of acrobatics to selectively subclass the class of
the security traded.  Trade now explicitly inherits from the class
of the security traded.  This allows the security traded class to 
supply its own side effects, which were done previously with rather
arcane and limited mechanisms.

<p>
These changes primarily require the tradable class to handle set values
for which side effects are desired.  Typical examples are where
multiple value types can be used to set the unit price of the trade.
Each of these value types must pass any set values through to Spot Price.
E.g., set value messages to Percent Premium are translated to pips and
then passed to Spot Price( Self ).


<h3>Spot</h3>
<p>
Changes for trade side effects.
<p>
Fx options now take advantage of New Trees functionality by using
a conditional child.  If Volatility Wings are turned off, that part
of the Dollar Price tree is completely excluded.  These speeds execution
and reduces memory used.

<h3>Ancestors</h3>
<p>The ancestors value type structure layout has changed slightly.

<h3>~Value Types</h3>
<p>
When a value type is used as the source of an object name in a child
list, a new value type is automatically created.  This happens when
the child list says to get the name for the object it wants to depend
on from one of its own value types and this other value type returns
a string (as opposed to a DtSecurity).  Under these circumstances
SecDb automatically creates another value type on the parent class
whose name is just the name of the
string-returning value type with a ~ character prepended.  This ~
value type takes the string value type as a child and converts it
to a DtSecurity via SecDbGetByName in the same database as the parent.
This accomplishes two things: the SecPtr for the child object is
held in the cache graph (as a DtSecurity in the ~ value type) and
the parent gets the needed DtSecurity even though it is using a DtString as
a child.
<p>
For example:
<br>
<pre>
	ChildValue = Spot( Cross( Self ));
</pre>
but Cross( Self ) returns a string not a security.  SecDb in this case
will automatically change the dependency to:
<br>
<pre>
	ChildValue = Spot( ~Cross( Self ));
</pre>
and will also add a new value type to the class of Self (written here,
for demonstration purposes, as though it were an UFO value function):
<br>
<pre>
TildeValueFunc = Func(
	SecPtr,
	Vti,
	PassErrors
)
{
	UfoArg( PassErrors, FALSE );
	
	UseDatabase( Database( SecPtr ))
		ChildSecPtr = GetSecurity( Cross( Self ));
		
	if( !ChildSecPtr && !PassErrors )
	{
		ErrMore( "Getting Cross( Self )" );
		Abort();
	};
	
	return( ChildSecPtr );
};
</pre>
Similarly if Cross( Self ) returned an array or structure, ~Cross( Self )
would be created to return a DtSecurityList.

<p>
Note that SecDb will automatically handle String to Security conversion
in more complicated cases, too.  (Actually, SecDb will do conversion to
DtSecurity/DtSecurityList and/or DtValueType whenever necessary during
the child list evaluation phase.) In these cases the ~ value type
mechanism is not appropriate for various reasons, e.g., it is not on
Self:
<br>
<pre>
	ChildValue = Spot( Cross( Contract( Self )));
</pre>
in which case SecDb has no way of knowing definitively what class to
put the ~Cross value type on (since Contract( Self ) just returns a
string and does not say anything about what class the object it names
could be).  In this and other mandatory converion situations, SecDb 
creates a conversion node in the graph.  The dependency is changed
(on a per-object basis) to:
<br>
<pre>
	ChildValue = Spot( String to Security( , Cross( Contract( Self ))));
</pre>
where the String to Security is a special node on the <em>conversion object</em>
 (whose name is the empty string--hence the naked comma).


<h2>Implementation</h2>
<p>
Each value gotten from SecDb (including those gotten recursively as
children) is stored in a cache node (SDB_NODE in secnode.h) in memory.
This policy of one value, one node is adhered to without exception.
Nodes are linked together by edges thus forming the SecDb cache graph.
(This graph is entirely in memory and separate for each client.)
<p>
Each node contains a DT_VALUE which is (if valid) the last calculated
or set value for that node.  This is the only place this value resides
in SecDb.  If the node is not currently valid, the value is freed and
the node is marked as invalid.
<p>
The defining elements of each node are its object, its value type, and
its arguments, i.e., vt( obj, arg1, ..., argn ) where vt, obj, etc are
just pointers to other nodes.  The edges of the graph are the <em>literal
nodes</em>.  These are special nodes that are have no value type,
no object and no args, i.e., NULL( NULL ) but whose value is the
literal value.  Here's an example of a node (and all other nodes in the
graph that are part of its definition):
<pre>
H: Interest Rate( ~Denominated( DEM/USD ), Expiration Date( Trade 10 ), 1Jan96 ) with value: (Double) 0.04
	which is: A( B, C, I )
	where
		A: literal node with value: (Value Type) Interest Rate
		B: Denominated( DEM/USD ) with value (Security) DEM
			which is: D( E )
			where:
				D: literal node with value: (Value Type) ~Denominated
				E: literal node with value: (Security) DEM/USD
		C: Expiration Date( Trade 10 ) with value: (Date) 3May97
			which is: F( G )
			where
				F: literal node with value: (Value Type) Expiration Date
				G: literal node with value: (Security) Trade 10
		I: literal node with value: (Date) 1Jan96
</pre>
or in tabular form (where A, B, C, etc. each represent some memory address):
<table border>
<tr>
	<th>Node Address
	</th><th>Value Type
	</th><th>Object
	</th><th>Argc
	</th><th>Argv
	</th><th>Value
	</th><th>Node Name
	</th><th>Node Type
	</th>
</tr><tr>
	<td>A
	</td><td>NULL
	</td><td>NULL
	</td><td>0
	</td><td>
	</td><td>(Value Type) Interest Rate
	</td><td>Interest Rate
	</td><td>Literal
	</td>
</tr><tr>
	<td>B
	</td><td>D
	</td><td>E
	</td><td>0
	</td><td>
	</td><td>(Security) DEM
	</td><td>~Denominated( DEM/USD )
	</td><td>Terminal
	</td>
</tr><tr>
	<td>C
	</td><td>F
	</td><td>G
	</td><td>0
	</td><td>
	</td><td>(Date) 3May97
	</td><td>Expiration Date( Trade 10 )
	</td><td>Terminal
	</td>
</tr><tr>
	<td>D
	</td><td>NULL
	</td><td>NULL
	</td><td>0
	</td><td>
	</td><td>(Value Type) ~Denominated
	</td><td>~Denominated
	</td><td>Literal
	</td>
</tr><tr>
	<td>E
	</td><td>NULL
	</td><td>NULL
	</td><td>0
	</td><td>
	</td><td>(Security) DEM/USD
	</td><td>DEM/USD
	</td><td>Literal
	</td>
</tr><tr>
	<td>F
	</td><td>NULL
	</td><td>NULL
	</td><td>0
	</td><td>
	</td><td>(Value Type) Expiration Date
	</td><td>Expiration Date
	</td><td>Literal
	</td>
</tr><tr>
	<td>G
	</td><td>NULL
	</td><td>NULL
	</td><td>0
	</td><td>
	</td><td>(Security) Trade 10
	</td><td>Trade 10
	</td><td>Literal
	</td>
</tr><tr>
	<td>H
	</td><td>A
	</td><td>B
	</td><td>2
	</td><td>C,I
	</td><td>(Double) 0.04
	</td><td>Interest Rate( ~Denominated( DEM/USD ), Expiration Date( Trade 10 ))
	</td><td>Non-terminal
	</td>
</tr><tr>
	<td>I
	</td><td>NULL
	</td><td>NULL
	</td><td>0
	</td><td>
	</td><td>(Date) 1Jan96
	</td><td>1Jan96
	</td><td>Literal
	</td>
</tr></table>

Note that the non-literal nodes are called terminals if the object and 
value type are
both literal nodes and non-terminals if the object or value type is not a literal node.  Note
also that there are new datatypes <em>Security</em> and <em>Value Type</em> 
which are
used to represent the values of the object and value type nodes.  The
object node must always have a value whose datatype is Security (or
Security List--another new datatype) and the value type node must always
have a value whose datatype is Value Type.

<p>
There is only one node for any unique set of definitional data.
For literals the definitional data is the value itself, but for the
non-literals the definitional data is its object, value type, and
argument nodes.  A node's definitional data can never change.  Thus,
for example, there is only one literal node with the date 1Jan96, there
is only one ~Denominated( DEM/USD ) even if it used as the object node
for many other nodes.  Before a node is ever created, the current graph
is searched (efficiently of course) for the node first.

<p>
Non-literal nodes are only destroyed whenever any of its definitional 
nodes are destroyed.
The only literals that are ever destroyed are Security literals when the
pointed to object is removed from the SecDb object cache (typically by
being removed from the deadpool).  Thus freeing an object causes the
literal with the corresponding Security value to be destroyed which in
turn causes all the terminals using that literal to be destroyed (i.e.,
all the values for that object) and all the other nodes which use any
of these nodes as object, value type, or arguments.

<p>
In addition to the definitional links of the graph.  There are causal
links as well.  These consist of the children of each calculated value.
Typically these links are stored in both directions.  The calculated
node has links to all its children nodes (and each child is, of course,
just a node) for fast calculation and each of the children
have pointers to the parent for fast invalidation.  (There are exceptions, some children do
not know their parents--all literal nodes and nodes whose parents are
on the same object and the node has its LocalParent bit set.  These are
merely space optimizations; for practical purposes you can consider that each
node knows all its parents.)

<p>
When a value is set (e.g., with a call to SecDbSetValue or SecDbSetDiddle)
the node stores the new value and invalidates all its parents.  
The parents in turn recursively invalidate all
their parents, etc., until all the nodes that depended on the node
being changed have been invalidated.

<p>
When a value is gotten (e.g., with a call to SecDbGetValue or as a child)
its validity is checked.  If the node is valid, no traversal of its
children is necessary and the nodes value is returned immediately.  If
the node is invalid, the value is gotten from each of its children (each
child that is invalid will have to do the same thing recursively of course) 
and
the value function is called to calculate a new value which is then returned.

<p>
The list of children can be invalid also (as is the case when the node
is first created).  If that is the case, the children are found/created
according to the childlist given by the value function and links are made to each.  The list of
children is never invalidated for a terminal node.  For a non-terminal
node, the list of children is invalidated whenever the object or
value type nodes become invalid.

<p>
There is a little additional magic for things like pass errors, alias nodes,
local parents, datatype mismatches, etc., but I'll explain those later.
	
