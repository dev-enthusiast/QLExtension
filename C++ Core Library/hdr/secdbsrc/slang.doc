      FUNCTION: Slang - Security Language API

		  TAIL: SLANG API - $Revision: 1.1 $ - $Date: 1994/07/15 17:21:02 $ - Copyright 1993 GS & Co.

		 COVER: Slang

				Security

				Language

	SORT ORDER: 0

      FUNCTION: Quick Function Index - Orig

   DESCRIPTION: Function description:

				SlangScopeFreeDiddles	- Free diddles associated with a scope
				SlangScopePopDiddles	- Pop diddles from scope stack
				SlangScopePopFunction	- Pop functions from scope stack
				SlangScopePopVariables	- Pop variables from scope stack
				SlangScopePushDiddles	- Push diddles onto scope stack
				SlangScopePushFunction	- Push functions onto scope stack
				SlangScopePushVariables	- Push variables onto scope stack
				SlangRegisterFunction	- Register a slang function
				SlangVariableDestroy	- Destroy one or all variables
				SlangVariableGet		- Get a variable by name
				SlangVariableSet		- Set a variable to a value

	SORT ORDER: 01

      FUNCTION: SLANG_CONTEXT

	   SUMMARY: typedef struct SlangContextStructure SLANG_CONTEXT;

		 USAGE:	typedef struct SlangContextStructure
				{
					struct SlangContextStructure
							*Next;

					struct HashStructure
							*Hash;

					long	UpdateCount;

					SLANG_ABORT_FUNC
							AbortFunc;			   // "Abort Function"

					void	*AbortHandle;		   // "Abort Handle"
	
					int		AbortCheckGranularity; // "Abort Check Granularity"

					time_t	LastAbortCheck;				
	
				} SLANG_CONTEXT;

   DESCRIPTION:	The SLANG_CONTEXT structure contains a
				pointer to the Print function, and a handle
				that the print function can use.  The print
				function is called by the Slang 'Print'
				function.

				The SLANG_CONTEXT structure also contains
				a pointer to an Abort function.  The abort
				function is called within loops, if the
				function returns TRUE, then evaluation is
				aborted, otherwise evaluation continues.

	SORT ORDER: 2

      FUNCTION: SlangEnumFirstFunction

   DESCRIPTION: Application programs can use SlangEnumFirstFunction,
   				SlangEnumNextFunction and SlangEnumFunctionClose to obtain
   				a list of functions supported by Slang.

				The enumeration of function names is not done in alphabetical
				order.

				The SlangEnumFirstFunction function obtains a pointer that
				can be used in subsequent calls to the SlangEnumNextFunction
				function.

				SlangEnumFunctionClose must be called at the end of
				enumeration, even if SlangEnumFirstFunction or
				SlangEnumNextFunction returns NULL.

      SEE ALSO: SlangEnumNextFunction, SlangEnumFunctionClose

       EXAMPLE: /*
       			**	Print a list of all functions supported by Slang
       			*/
       			
       				SDB_ENUM_PTR
       						EnumPtr;


					if( FuncName = SlangEnumFirstFunction( &EnumPtr ))
						do
						{
							print( "%s\n", FuncName );

						} while( FuncName = SlangEnumNextFunction( EnumPtr ));

					SlangEnumFunctionClose( EnumPtr );

      FUNCTION: SlangEnumFirstVar

   DESCRIPTION: Application programs can use SlangEnumFirstVar,
   				SlangEnumNextVar and SlangEnumVarClose to obtain
   				the current list of variables.  Variable are created
   				and modified when expressions are evaluated.

				The enumeration of variables is not done in alphabetical
				order.

				The SlangEnumFirstVar function obtains a pointer that
				can be used in subsequent calls to the SlangEnumNextVar
				variable.

				SlangEnumVarClose must be called at the end of
				enumeration, even if SlangEnumFirstVar or
				SlangEnumNextVar returned NULL.

      SEE ALSO: SlangEnumNextVar, SlangEnumVarClose

       EXAMPLE: /*
       			**	List all variables
       			*/
       			
       				SLANG_VARIABLE
       						*Variable;


					if( Variable = SlangEnumFirstVar( &EnumPtr, NULL ))
						do
						{
							print( "%s\n", Variable->Name );

						} while( Variable = SlangEnumNextVar( EnumPtr ));

					SlangEnumVarClose( EnumPtr );

      FUNCTION: SlangEnumNextFunction

   DESCRIPTION: Application programs can use SlangEnumFirstFunction,
   				SlangEnumNextFunction and SlangEnumFunctionClose to obtain
   				a list of functions supported by Slang.

				The enumeration of function names is not done in alphabetical
				order.

				The SlangEnumFirstFunction function obtains a pointer that
				can be used in subsequent calls to the SlangEnumNextFunction
				function.

				SlangEnumFunctionClose must be called at the end of
				enumeration, even if SlangEnumFirstFunction or
				SlangEnumNextFunction returns NULL.

      SEE ALSO: SlangEnumFirstFunction, SlangEnumFunctionClose

       EXAMPLE: See example for SlangEnumFirstFunction

      FUNCTION: SlangEnumNextVar

   DESCRIPTION: Application programs can use SlangEnumFirstVar,
   				SlangEnumNextVar and SlangEnumVarClose to obtain
   				the current list of variables.

				The enumeration of variables is not done in alphabetical
				order.

				The SlangEnumFirstVar function obtains a pointer that
				can be used in subsequent calls to the SlangEnumNextVar
				function.

				SlangEnumVarClose must be called at the end of enumeration,
				even if SlangEnumFirstVar or SlangEnumNextVar returns NULL.

      SEE ALSO: SlangEnumFirstVar, SlangEnumVarClose

       EXAMPLE: See example for SlangEnumFirstVar

      FUNCTION: SlangEnumFunctionClose

   DESCRIPTION: SlangEnumFunctionClose closes (frees) the enumeration pointer
   				used by SlangEnumFirstFunction and SlangEnumNextFunction
   				functions.

      SEE ALSO: SlangEnumFirstFunction, SlangEnumNextFunction

       EXAMPLE: See example for SlangEnumFirstFunction

      FUNCTION: SlangEnumVarClose

   DESCRIPTION: SlangEnumVarClose closes (frees) the enumeration pointer
   				used by SlangEnumFirstVar and SlangEnumNextVar functions.

      SEE ALSO: SlangEnumFirstVar, SlangEnumNextVar

       EXAMPLE: See example for SlangEnumFirstVar

      FUNCTION: SlangError

   DESCRIPTION: SlangError is called when a slang function encounters an error
   				that should halt expression evaluation.  The 'Node' argument
   				contains row & column information as to where in the originally
   				parsed string or file the node came from.
				The 'Format' and remaining arguments are used passed to sprintf
				to build the final error string.

      FUNCTION: SlangEvaluate

       SUMMARY: Evaluate a parsed expression

         USAGE:	int SlangEvaluate(
				SLANG_NODE		*Expression,	// Parsed expression
				int		  		EvalFlag,		// Evaluate results flag
				SLANG_RET		*Ret,			// Returned data
				SLANG_SCOPE		*Scope )		// Diddle scope

       RETURNS: SLANG_OK	   - Expression evaluated without error
       			SLANG_ERROR	   - Error evaluating
       			SLANG_ABORT	   - Abort while evaluating
       			SLANG_BREAK    - 'break' statement while evaluating
       			SLANG_RETURN   - 'return' statement while evaluating
       							 Ret contains value to return
       			SLANG_CONTINUE - 'continue' statement while evaluating
       			SLANG_EXIT	   - 'exit' statement while evaluating

   DESCRIPTION: After a file or a string has been parsed using SlangParse or
   				SlangParseFile into a slang expression, it can be evaluated
   				with SlangEvaluate.

				The arguments:

					'Expression'- SlangParse and SlangParseFile generate a
								  tree of SLANG_NODE structures.  The root
								  of this tree is where evaluation begins.

					'EvalFlag'	- This argument should always be TRUE.
					
					'Ret'		- Pointer to structure to receive the evaluated
								  value of the expression.  A SLANG_RET
								  structure contains a 'Type' component which
								  should contain SLANG_VALUE, and a
								  'Data.Value' component which contains the
								  result of the evaluation.

					'Scope'		- This argument maintains a list of diddles
								  that were caused by the evaluation of the
								  Slang expression.  The diddles can be removed
								  by an application by calling SlangFreeScope.

      SEE ALSO: SlangParse, SlangParseFile, SlangFree

       EXAMPLE: See example for SlangParse

      FUNCTION: SlangFree

   DESCRIPTION: Free an expression that was parsed by the SlangParse
   				function.

      SEE ALSO: SlangParse, SlangParseFile, SlangEvaluate

       EXAMPLE: See example for SlangParse

      FUNCTION: SlangParse

   DESCRIPTION: Convert a string into a parsed expression.  The expression
   				can be evaluated as many times as needed by the application.
   				Once the application is done with the expression, it should
   				be freed with a call to SlangFree.

				The 'ModuleType' can be one of the following:

					SLANG_MODULE_UNKNOWN
					SLANG_MODULE_FILE
					SLANG_MODULE_OBJECT
					SLANG_MODULE_STRING
					SLANG_MODULE_KEYBOARD
					SLANG_MODULE_USER

				Where (SLANG_MODULE_USER + OffSet) can be used by applications
				to support their own module types.

      SEE ALSO: SlangParseFile, SlangEvaluate, SlangFree

       EXAMPLE: /*
       			**	Evaluate an expression, and print the results
       			*/

					SLANG_NODE
							*Expr;

					SLANG_CONTEXT
							Context;

					SLANG_RET
							Ret;

					SLANG_SCOPE
							Scope;

					char	*Script;


				/*
				**	Define a context (just an example, not used in the test
				**	expression), and a clean scope.
				*/

					memset( &Context, 0, sizeof( Context ));
					Context.Print	= fprintf;
					Context.Handle	= stdout;

					memset( &Scope, 0, sizeof( Scope ));


				/*
				**	Parse and evaluate the expression
				*/

					Script = "price( \"DEM/USD\" ) * 100000";

					Expr = SlangParse( Script, Script, SLANG_MODULE_STRING );
					if( !Expr )
						printf( "Parse Error: %s\n", SecDbErrStr );
					else
					{
						if( !SlangEvaluate(
								Expr,			// Parsed expression
								TRUE,			// Evaluate results flag
								&Ret,			// Returned data
								&Context,		// Axis context
								&Scope ))		// Diddle scope
							printf( "Eval Error: %s\n", SecDbErrStr );
						else if( Ret.Type == SLANG_DOUBLE )
							printf( "%lg\n", Ret.Data.Number );
						else if( Ret.Type == SLANG_STRING )
							printf( "%s\n", Ret.Data.String );
					}

      FUNCTION: SlangParseFile

   DESCRIPTION: Read and convert a file into a parsed expression.
   				The expression can be evaluated as many times as needed by
   				the application.   Once the application is done with the
   				expression, it should be freed with a call to SlangFree.

				The 'ModuleType' can be one of the following:

					SLANG_MODULE_UNKNOWN
					SLANG_MODULE_FILE
					SLANG_MODULE_OBJECT
					SLANG_MODULE_STRING
					SLANG_MODULE_KEYBOARD
					SLANG_MODULE_USER

				Where (SLANG_MODULE_USER + OffSet) can be used by applications
				to support their own module types.

      SEE ALSO: SlangParse, SlangEvaluate, SlangFree

       EXAMPLE: /*
       			**	Read an expression from a file, and print the results
       			*/

					SLANG_NODE
							*Expr;

					SLANG_CONTEXT
							Context;

					SLANG_RET
							Ret;

					SLANG_SCOPE
							Scope;

					SDB_VALUE
							StringValue;


				/*
				**	Define a context and a clean scope.
				*/

					memset( &Context, 0, sizeof( Context ));
					Context.Print	= fprintf;
					Context.Handle	= stdout;

					memset( &Scope, 0, sizeof( Scope ));


				/*
				**	Parse and evaluate the expression
				*/

					Expr = SlangParseFile(
							"TEST.EXP",
							"TEST.EXP",
							SLANG_MODULE_FILE );

					if( !Expr )
						printf( "Parse Error: %s\n", SecDbErrStr );
					else
					{
						if( !SlangEvaluate(
								Expr,			// Parsed expression
								TRUE,			// Evaluate results flag
								&Ret,			// Returned data
								&Context,		// Axis context
								&Scope ))		// Diddle scope
							printf( "Eval Error: %s\n", SecDbErrStr );
						else
						{
							// Convert result into a string data type
							StringValue.DataType = SecDbDataTypeString;
							SDB_DT_OP( SDB_DT_TO,
									&StringValue,
									&Ret.Data.Value,
									NULL );

							printf( "Evaluated: %s\n",
									StringValue.Data.Pointer );

							// Free values
							SDB_DT_OP( SDB_DT_FREE,
									NULL, &Ret.Data.Value, NULL );
							SDB_DT_OP( SDB_DT_FREE,
									NULL, &StringValue, NULL );
						}
					}

      FUNCTION: SlangFunctionRegister

   DESCRIPTION: Add a function to slang.  SlangRegisterFunction allows
   				application programs to extend the functionality of Slang
   				by adding there own functions.

				A slang function takes the following form:

					int SlangXApplicationFunction(
							SLANG_NODE		*Root,
							int				EvalFlag,
							SLANG_RET		*Ret,
							SLANG_SCOPE		*Scope )

				The function takes the exact same arguments as that of
				SlangEvaluate, in fact SlangEvaluate is implemented as
				a macro that simply calls the function associated with
				the root (expression node).

				The following flags can be or'ed together to create the
				'ParseFlags' argument:

					SLANG_BIND_BLOCK	- The block or expression immediately
										  following the function are taken to
										  be the last argument in the list of
										  arguments passed to the function.
					SLANG_NO_PARENS		- The function does not have any
										  explicit arguments.
					SLANG_BIND_COLON	- Not enough roughage.
					SLANG_PARSE_TIME	- Evaluate expression at parse-time
										  instead of evaluation-time.

