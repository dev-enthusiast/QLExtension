      FUNCTION: Slang - Language Description

		  TAIL: SLANG - $Revision: 1.22 $ - $Date: 2000/01/08 19:45:24 $ - Copyright 1993 GS & Co.

		 COVER: Slang

				Language

				Description

	SORT ORDER: 0.0

      FUNCTION: Table of Contents

   DESCRIPTION: Overview
				  Slang Syntax
				  Slang Operators
				  Slang Constants
				  Slang Datatypes
				  Slang Functions
				  Slang Variable Scopes
				  Value Methods and Diddles
				Introduction to Slang Datatypes
				Quick Function Index

	SORT ORDER: 0.1

      FUNCTION: Overview

   DESCRIPTION: Slang - Security Language

				Slang uses SecDb as the underlying security database.

				Slang is based upon C.  Most of the constructs available
				within C are available in Slang.  Slang in some respects is
				closer to C++ in the way it handles different types of data.
				Slang is a case-insensitive typeless language.  This means
				that the same function can accept different types of arguments
				and handle them in a consistent way.

				Slang is designed to make working with securities and security
				related data an integral part of the language.

	SORT ORDER: 0.2

      FUNCTION: Slang Syntax
      
   DESCRIPTION: The Slang language syntax is very similar to C.  The major
   				differences are:
   					- Composite statement blocks (the curly braces { and })
   					  are treated by Slang identically to a single statement
   					  and as such return a value and must be separated from
   					  the following statement with a semi-colon.
   					  
   					- Slang has some additional operators (@, @@, ::, and <=>)
   					  and C has some operators that are not necessary in Slang
   					  (%, ->, :>, sizeof, (cast), ? :, <<=, >>=, %=).

   					- Slang has no keywords.  Most of the C keywords are
   					  represented in Slang as functions and are used just
   					  like in C.  One exception is the else keyword which
   					  in Slang is the : operator.  For example:
   					  	
   					  if( test )
   					  {
   					  	if-block
   					  }
   					  :
   					  {
   					  	else-block
   					  };

   					- Slang allows spaces in symbols.
   					
   					- There are no variable declarations in Slang.

   					- Function definitions in Slang are done via the
   					  Func function.

	SORT ORDER: 2.20

      FUNCTION: Slang Operators

   DESCRIPTION:	Binary Operators:
					+			- Add		(When used with doubles)
					-			- Subtract	(When used with doubles)
					*			- Multiply	(When used with doubles)
					/			- Divide	(When used with doubles)

				Unary Operators:
					-			- Unary minus
					!			- Unary not
					++			- Increment
					--			- Decrement
					&			- Address of
					*			- Dereference

				Assignment Operators:
					=			- Assignment
					+=			- Addition assignment
					-=			- Subtraction assignment
					*=			- Multiplication assigment
					/=			- Division assignment
					&=			- Append assignment

				Compare Operators:
					==			- Equal
					<			- Less than
					>			- Greater than
					<=			- Less than or equal to
					>=			- Greater than or equal to
					!=			- Not equal
					<=>			- Compare (-1, 0, 1)
				
				Logic Operators:
					&&			- Logical and
					||			- Logical or

				Subscript and Component Operators:
					.			- Component
					[]			- Subscript or array initializer

				Function Calling Operators:
					@			- Call a slang function
					@@			- Call a slang function at local scope
					&			- Within a function call - pass by reference

				Scope Operators:
					::			- Explicit reference of a scoped variable

	SORT ORDER: 2.21

      FUNCTION: Slang Constants

   DESCRIPTION:	Predefined Constants:
					_Blank Zero			- Format-blank if zero
					_Cipher				- Format-dash if zero
					_Commas				- Format-commas
					_Concise			- Format-no trailing zeros
					_Equal				- Lookup Equal	
					_ERR_*				- Error codes
					_Error Value		- Numeric error value (HUGE_VAL)
					_External			- Enumeration-external values only
					_Extrapolate		- Curve extrapolation method
					_First				- Lookup First
					_First Level		- Enumeration-first level only
					_Full Precision		- Format-print full decimal precision
					_Ge					- Lookup Ge
					_Greater			- Lookup Greater
					_Interpolate Flat	- Interpolate curve (extrapolate flat)
					_Interpolate Only	- Interpolate curve (inclusive only)
					_Interpolate Prestep- Pre-stepwise curve interpolation
					_Interpolate Step	- Stepwise curve interpolation
					_Knots Only			- Interpolate curve using knots only
					_Last				- Lookup Last
					_Le					- Lookup Le
					_Leaves Only		- Enumeration-leaves only
					_Less				- Lookup Less
					_Mush Compatible	- Format-mush compatible string
					_Next				- Lookup Next
					_Pad Zeros			- Format-leading zeros
					_Parens 			- Format-parenthesis if negative
					_Percent			- Format-percent
					_Pi					- Pi
					_Plus Sign			- Format-plus sign if positive
					_Prev				- Lookup Prev
					_Prune				- Enumeration-prune the tree
					_Scale				- Format-number scaling (K,M,B...)
					_Sorted				- Enumeration-sort
					_Tree				- Enumeration-descend down the tree
					_Trim Leading       - Format-trim leading spaces
					BEEP_*				- Beep level for w_beep
					CELL_*				- Sheet/cell constants
					CHART2D_*			- 2-D charting constants
					EI_*				- Dialog field types
					EIA_*				- Dialog action values
					EIC_*				- Dialog and window color values
					EICF_*				- Dialog configuration flags
					EIE_*				- Dialog events
					EIF_*				- Dialog flags
					EIP_*				- Dialog position values
					False				- Logical FALSE (zero)
					Q_*					- Quant function values
					REG_*				- Regular expression flags
					SHT_*				- Sheet datatype constants
					SYNC_*				- Window synchronization flags
					THREE_D_*			- Chart3d constants
					True				- Logical TRUE (one)
					WF_*				- Window control flags
					WK_*				- Window and dialog key values

	SORT ORDER: 2.22

      FUNCTION: Slang Datatypes

   DESCRIPTION:	Intrinsic datatypes:
					Array					- Arrays of anything
					Binary					- Binary data
					Complex					- Complex number
					Curve	  				- Curves (int rates, fwd pnts...)
					CVector					- Vector of complex numbers
					Date	  				- Dates
					Double  				- Doubles (recast longs, etc...)
					GCurve					- Date-indexed array
					GRCurve					- RDate-indexed array
					Matrix					- Matrix of numbers
					Null					- NULL (undefined value)
					Pointer					- Pointer
					RCurve	  				- List of (RDate, Double) pairs
					RDate					- Relative Dates (1w, 2m, etc.)
					Reference				- Reference counted value
					RegEx					- Regular expression pattern
					Slang					- Slang parse tree
					String  				- Character strings
					Structure				- Structures of anything
					TCurve					- List of (Time, Double) pairs
					Time					- Time and date
					Vector					- Array of numbers
					
				SecDb datatypes:
					CFunc					- Handle to C-language for UFOs
					Database				- Handle to a SecDb database
					Each					- Iterate over arguments
					Index Pos				- Handle to SecDb index
					SecDb Value Type		- Handle to value method
					Security				- Security object
					Security List			- Array of securities
					
				User interface datatypes:
					Chart2d					- 2d chart
					Chart2dElem				- (x,y) pair in 2d chart
					Chart3d					- 3d chart
					Dialog					- Character-cell dialog box
					DlgWidget				- Visual Slang widget
					Edit Info				- Generic editor layout
					GxHandle				- Handle to graphics area
					GxImage					- Graphic image
					Page					- Character-cell layout
					Sheet					- Spreadsheet
					Sve						- Buffer Editor
					Window					- Character-cell window
				
				Datatypes hooks to external objects:
					Event Manager Connection- Handle to event manager
					GS1 Security			- GS1 Fixed Income object
					File					- File
					Socket					- TCP/IP socket
					SqlConnection			- Handle to SQL database
					Time Series				- TSDB expression
					Triarch Item
					Triarch Source
					UdbConnection
				
				Specialized datatypes (used by certain SecDb classes):
					Book Index Value
					Nearby Data
					Pos Effects
					Price Fix Data
					SecDb Dynamic Numbers
					SecDb Dynamic Pointers
					SecDb Pass Through
					Simulation Results Cache
					Vol Matrix
					Vol Vector

	SORT ORDER: 2.23

      FUNCTION: Slang Functions

   DESCRIPTION:	Array Functions:
   					ArrayConcat
					ArrayDelete				- Delete elements in an array
					ArrayIndex
					ArrayInsert				- Insert elements into an array
					ArrayReverse
					ArrayUniq

				Data Integrity Functions:
					CheckSum				- Byte sum
					Crc						- Cyclic redundancy check
					
				Bitwise Operation Functions:
					BitAnd					- Bitwise AND operator
					BitNot					- Bitwise NOT operator
					BitOr					- Bitwise OR operator
					BitXOr					- Bitwise XOR operator
					
				Communication Functions:
					GetHostByAddress		- Get information about a host
					GetHostByName			- Get information about a host
					HostName				- Get name of current host
					SocketAccept			- Accept a new tcp/ip connection
					SocketConnect			- Connect to a listening host
					SocketListen			- Listen for new connections
					SocketMsgClose			- Close a client connection
					SocketMsgDestroy		- Unmanage a client connection
					SocketMsgLinger			- Set closing behavior
					SocketMsgRead			- Read an entire message
					SocketMsgServerLoopSwitch - Be a server
					SocketMsgServerShutdown	- Exit ServerLoopSwitch
					SocketMsgWrite			- Write an entire message
					SocketPollInput			- Query if read-ready
					SocketPollOutput		- Query if write-ready
					SocketReadBinary		- Recieve binary data from socket
					SocketReadLine			- Recieve string from socket
					SocketReadResult		- Recieve formatted data
					SocketWrite				- Send data
					
				Curve Functions:
					CurveAdd				- Add two curves
					CurveAssign
					CurveDeleteKnot
					CurveDivide
					CurveExcludeByRank
					CurveFromDates
					CurveMerge				- Splice two curves together
					CurveMultiply
					CurveRange
					CurveSearch
					CurveShift
					CurveShiftGS
					CurveSubtract
					CurveSwitches			- Delta between curve knots
					CurveToVectors
					CurveUnion
					Interpolate				- Interpolate a point on a curve
					RCurveToCurve			- Convert curve to relative curve
					
				Database-maintained File Functions:
					DbFileDelete
					DbFileInfoGet
					DbFileInfoSet
					DbFileRead
					DbFileWrite

				Debugging Functions:
					Debug					- Debugger breakpoint
					HashStatistics
					HeapFindSize			- Get list of heap nodes
					HeapGetSizes			- List heap nodes by size
					HeapInfo				- Info about allocated memory
					HeapSet					- Set freed memory to pattern
					HeapUsed				- Amount of memory allocated
					MemSize
					MemSizes
					ResetDebugLog
					HappyAuditStart
					HappyAuditStop

				Dialog Functions:
					Dialog					- Dialog box
					DialogAskStrTab			- Dialog box with string table
					DialogAskYesNo			- Dialog box for yes/no questions
					DialogEdit				- Dialog box editor
					DialogFieldGet
					DialogRecalc
					DialogUpdateStrTab		- Allow callback to update strtab

				Dynalink Functions:
					DynaLinkGetConfig		- Get info about dll versions
					DynaLinkGetVersion		- Get version info about one dll
					DynaLinkIsLoaded		- Check if a dll is loaded
					
				Error Handling Functions:
					ErrorLogOpen			- Log subsequent errors to a file
					ErrorMessage			- Display an error message
					Exceptions				- Control hardware errors
					LastError				- Last error from SecDb
					LastErrorNumber			- Last error code from SecDb
					Message					- Display a message
					MessageOccasional		- Display a message occasionally
					WaitMessage				- Display a message & wait for key

				Event Manager Functions:
					EventManagerConnect
					EventManagerFor
					EventManagerGet
					EventManagerLast
					EventManagerPut
					EventManagerTypes

				Fax Functions:
					FaxGetJobStatus
					FaxGetServerStatus
					FaxSendPostscript

				File Functions:
					FileCopy				- Copy a file
					FileCreate				- Create a file
					FileDelete				- Delete a file
					FileExists				- Determine if a file exists
					FileFlush
					FileOpen				- Open a file
					FileReadBinary			- Read binary data from a file
					FileReadLine			- Read a line from a file
					FileSeek				- Reposition file pointer
					FileTell				- Retrieve file pointer
					FileTempName
					FileWrite				- Write output to a file
					ForFile					- Looped eval of file names/info
					TeePrintToFile			- Send print output to a file

				Graphing Functions:
					Draw2d
					Draw3d					- Display a chart3d datatype
					GraphScale				-
					Point3d					- Set a point in a chart3d
					
				Math Functions:
					Abs						- Numeric absolute value
					Ceil					- Numeric rounding up
					Cos
					Exp						- Exponential
					Floor					- Numeric rounding down
					Log						- Natural logarithm
					Log10					- Logarithm base 10
					Mod						- Modulus
					Pow						- Raise x to the power of y
					Random					- Random number
					RandomGauss				- Gaussian distributed random num
					Round					- Round a number n decimal points
					RoundSignificant		- Round to n significant digits
					Sign					- Numeric sign of a value -1,0,1
					Sin						- Sine
					Sqrt					- Square root
					Stats					- Calculate statistics of an array

				Music Function:
					PlayNote				- Play a musical tone

				Operating System Functions:
					ChDir					- Change the current directory
					GetEnv					- Get an environment variable
					MkDir					- Create a directory
					PutEnv					- Set an environment variable
					RmDir					- Remove a directory
					System					- Execute an operating system cmd
					ProcessID				- Get process id of slang session
					ProcessCpuTime			- Get CPU used by slang session
					
				Output Buffer Functions:
					OutputBufferBrowse		- Browse output buffer
					OutputBufferNew			- Reset output buffer
					OutputBufferOld			- View old output buffer(s)
					OutputBufferSave		- Store output buffer
				
				Page Functions:
					PageAt					- Put text into a Page datatype
					PageBox					- Draw a box for a Page datatype
					
				Position Management Functions:
					HashFunc
					BookPositionDecrement	- Decrement a position in a book
					BookPositionIncrement	- Increment a position in a book
					BookPositionLookup		- Lookup the name of a position
					BookPositionLookupName	- Lookup the name of a position
					TradeAdd
					TradeDelete
					TradeModifyPriorDay		- Generate prior-day ammendments
					TradePositionEffects	- Not for public consumption
					TradeUpdate

				Quant Functions:
					FromContinuous			- Convert rates to simple
					MatrixGrammSchmidt		- Gramm-Schmidt a matrix
					MatrixInverse			- Invert a matrix
					MatrixMultiply			- Multiply two matrices
					MatrixTranspose			- Transpose a matrix
					MR_*
					Q_*						- Quant funcs (see Adlib manual)
					SQ_*
					SVM_*
					ToContinuous			- Convert rates to continuous

				Regular Expression Functions:
					RegMatch				- Regular expression matching
					RegSub					- Regular expression substitution

				Searching and Sorting Functions:
					Bsearch					- Binary search on an array
					Lsearch
					Sort					- Sort an array
					SortTable				- Sort an array of structures

				SecDb Functions:
					CachedSecurities		- List of all objects in cache
					ClassInfo				- Info for any object class
					ClearSetRetainedValue	- Remove a set-retained value
					ClientStatistics		- Stats on client connection
					DatabaseInfo			- Info about current database
					DatabaseSearchPathAppend- Append db to search path
					DatabaseSearchPathDelete- Delete db from search path
					DatabaseSearchPathGet	- Current search path
					DatabaseSearchPathSet	- Change search path
					DeadpoolSecurities		- List of objects in deadpool
					DeleteSecurity			- Delete an object from database
					Delta					- dY/dX
					DiskInfo				- Info about an object (no-load)
					Eval					- Evaluate and remove diddles
					ExistsInDatabase		- Check if object is in db
					ForChildren				- Looped eval of objects children
					ForClass				- Looped eval of object classes
					ForSecurity				- Looped eval of object names
					ForValue				- Looped eval of object values
					Gamma					- Change in delta
					GetByInference			- Get an object through inference
					GetCacheFlags			- Get cache flags for a value
					GetManySecurities		- Get a list of securities
					GetSecurity				- Get an object from the database
					GetSecurityFromSyncPoint- Get an object from a syncpoint
					GetUniqueID				- Get a unique number
					GetValue				- Get a value from an object
					InferredName			- Get inferred name of an object
					NameLookup				- Name lookup with search criteria
					NameUsed				- Check for existance of an object
					NewSecurity				- Create a new object
					ReloadSecurity			- Reload an object
					RemoveCachedValue		- Remove an object's cached value
					RemoveFromDeadPool		- Remove an object from deadpool
					RenameSecurity			- Rename an object
					Restore					- Remove diddles within scope
					SecType					- Type of object in string form
					SecurityAdd				- Add an object from structure
					SecurityAddByInference	- Add by inference from struct
					SecurityUpdate			- Update object from structure
					SetApplicationName		- Change published app name
					SetDiddle				- Diddle a value within an object
					SetUserName				- Change published user name
					SetValue				- Set a value within an object
					UpdateSecurity			- Update an object in the database
					UseDatabase				- Operate on a different SecDb database
					Validate				- Validate an object
					ValueTypeChildInfo		- Info on children of a value
					ValueTypeDescription	- Description of value method
					ValueTypeInfo			- All info for a value method

				SecDb Index Functions:
					IndexGet				- Retrieve data from an index
					IndexInfo				- Retrieve format of an index
					IndexNames				- Get list of indices
					IndexRepair				- Repair indices for an object
					NewIndexPos				- Create a new index position

				SecDb Market Function:
					LeastCurrency
					
				SecDb Remote-database Functions:
					RemoteDelete			- Delete from a remote database
					RemoteDiskInfo			- Object info from a remote db
					RemoteGetCopy			- Copy an object from a remote db
					RemotePutCopy			- Copy an object to a remote db

				SecDb Transaction Functions:
					Transaction				- Transactionally protect block
					TransactionAbort		- Break from protected block
					TransactionCurrent
					TransLogDetail			- Get detail log of transaction
					TransLogHeader			- Get summary log of transaction
					TransLogLast			- Highest transaction number
					TransMap
					Tsdb					- Evaluate a tsdb expression
					TsdbLastPoint			- Last point of a tsdb symbol
					TsdbUpdate				- Update a tsdb symbol

				SecView Functions:
					EditSecurity			- Object editor dialog box
					ShowFKeys				- Display function keys
					ShowSecurity			- Display an object in a dialog
					ShowStats

				Sheet Functions:
					CellAttr				- Set a single cell's attributes
			 		CellAttrRange			- Set attributes for a cell range
			 		CellData				- Set a single cell's content
			 		CellDataRange			- Set contents for a cell range
			 		CellFont				- Set a single cell's font
			 		CellFontRange			- Set font for a range of cells
			 		CellFormat
			 		CellFormatRange
			 		SheetBox				- Draw a box around cells
			 		SheetColumnWidth		- Set the width of a column
			 		SheetPostscript			- Output sheet in postscript
			 		SheetRowHeight

			 	Simulation Functions:
					MonteCarlo				- Generate monte-carlo paths
					SimulationCreatePaths	- Store simulation paths
					SimulationDestroyMarketSet
					SimulationDirectory		-
					SimulationNewMarketSet	- Create a new simulation environ
					SimulationReinit		- Re-initialize a simulation
					SimulationRun			- Run a simulation

				Slang Language Functions:
					Abort					- Simulate abort key operation
					AbortCheck				- Set poll rate for abort action
					AbortTrap				- Eval a block and trap aborts
					ArgCheck				- Check value against a value set
					Break					- Flow control - Loop abort
					Constant				- Define a constant
					Continue				- Flow control - Loop continue
					DataTypes
					Defined					- TRUE if an expression evaluates
					Destroy					- Destroy one or more variables
					DestroyComponent		- Destroy component of a variable
					DoGlobal				- Evaluate a block at local scope
					Enum					- Create numbered constants
					EnumList
					EnumName
					Exec					- Evaluate a string expression
					Exit					- Immediatly exit from script
					For						- Looped conditional evaluation
					ForComponent			- Looped eval of component parts
					ForEach					- Looped eval of elements
					ForEachParallel			- Parallel processed loop eval
					Func					- Define a slang function
					Function				- Parse string into slang function
					Functions
					FunctionUsage
					Global					- Access a global variable
					HashKeys
					HighLimit				- Highest value of a datatype
					HotKey					- Attach a script to a keystroke
					If						- Conditional evaluation
					Include					- Include a Slang object
					Link					- Include object at parse time
					LowLimit				- Lowest value of a datatype
					Max						- Highest value of arguments
					Min						- Lowest value of arguments
					New						- New instance of a datatype
					Or						- Return value of first TRUE expr
					Return					- Flow control - Return from func
					Scope					- Access variable from named scope
					Scopes					- Get list of named scopes
					ScopeSetSticky			- Extend variables lifespan
					Size					- Determine the size an argument
					Sleep					- Delay for a specified time
					SmartLink
					Sticky					- Access a sticky variable
					StickyDiddle			- Create/modify sticky diddles
					StructureUnion			- Union of two structures
					Switch					- Matched conditional evaluation
					TableInit				- Initialize array of structures
					To						- Convert between datatypes
					TypeOf					- Datatype of an expression
					Variables				- Get list of variables
					While					- Looped condition evaluation

				SQL Functions:
					ForSqlQuery				- Looped eval through sql query
					SqlConnect				- Connect to an SQL server
					SqlQuery				- Query an SQL server

				String Functions:
					Asc						- Decimal to ascii
					Center					- Center data within a string
					Chr
					FillIn					- String/Variable substitution
					Format					- Pretty output formatting
					Left					- Left justify within a string
					Print					- Print to output device
					Printf					- Formatted print to output device
					Right					- Right justify within a string
					Sprint					- Put data into a string
					Sprintf					- Put formatted data into a string
					StrBegins				- Does string begin with substring?
					StrChrCount				- Count chars in a string
					StrContains				- Does string contain substring?
					StrEnds					- Does string end with substring?
					StrField				- Return single space-delimited field
					StrHeight				- Height of a multiline string
					StrJoin					- Join an array of strings
					StrLower				- Convert string to lower case
					StrMixCase				- Upcase first letter of each word
					StrPos					- Position of a string in another
					StrRepeat				- Replicate a string n-times
					StrReplace				- Replace substrings in a string
					StrSplit				- Split a string into an array
					StrToBase64				- Convert string/binary to Base64
					StrToHtml				- Quote string for URL display
					StrToSecs				- Parse comma sep'd string to objs
					StrTranslate			- Replace pairs of characters
					StrUpper				- Convert string to upper case
					StrWidth				- Width of a multiline string
					SubStr					- Portion of a string
					Trim					- Remove trailing whitespace
					
				Sve Functions:
					Sve*					- Editor funcs (see SVE manual)
					
				Tap Functions:
					TapBoxCallBack
					TapSortKeyAdd
					TapSortKeyDump
					TapSortKeys
					TapTradeSetupClass

				Time/Date Functions:					
					AddDate					- Date arithmetic function
					CurrentGMTime			- Current Greenwich mean time
					CurrentTime				- Current time
					RDateAdd				- Add using relative dates
					TimeFromDate
					TimeGmtToLocal
					TimeLocalToGmt
					Weekday					- String day of week of a date

				UFO (SecDb Classes in Slang) Functions:
					CLink					- UFO: Link in a c func from a dll
					DefineClass				- UFO: Define a new class
					Err						- Put error text into error buffer
					ErrMore					- Append more error text
					ErrorReturn				- Generate a Slang error
					GobFillSecPtr			- UFO: Fill in an object reference
					GobMushInStreamValues	- UFO: Create mush value
					GobMushString			- UFO: Create must value
					SpotMakeForward			- UFO: Make a forward object
					SpotMakeOption			- UFO: Make an option object
					SpotSigOut				- UFO: Number to coded string
					UndefineClass			- UFO: Undefine a class

				Window (character-cell) functions:
					W_Attach				- Attach two windows together
					W_Beep
					W_Bounce
					W_Box
					W_Clear
					W_Color					- Set the current window color
					W_Del					- Delete lines from a window
					W_Detach				- Detach attached windows
					W_GetKey				- Get a key from the keyboard
					W_GetLine				- Get a string from a window
					W_Hide					- Hide a window
					W_HLine
					W_Ins					- Insert blank lines into a window
					W_LineCursor			- Set position of the line cursor
					W_MakeVis				- Make a window region visible
					W_Pick					- Pick through a window
					W_Pos					- Position cursor within a window
					W_Print					- Print output into a window
					W_RefOff				- Turn refreshing off
					W_RefOn					- Turn refreshing on
					W_Relocate				- Change window's screen location
					W_Select				- Bring window to top
					W_SetAttributes
					W_Show					- Display a hidden window
					W_Title					- Set a window's titles
					W_VLine

	SORT ORDER: 2.24

      FUNCTION: Slang Variable Scopes

   DESCRIPTION: Scope is defined as 'the range for which something applies.'
				Slang supports two different kinds of scope - variable and
   				diddle.  

				There are several types of variable scope:
					Global	- A script starts evaluation at the global scope.
							  Global variables can be accessed either through
							  the Global, DoGlobal functions, the Global::
							  prefix, or by simply being at the outermost
							  level of a script.
							  
					Local	- Local variables are variables that get created
							  within a function that is called using the '@'
							  or '@@' operator.  Local variables exist only
							  during the time the function is being evaluated.
							  Slang supports recursive function calling, and
							  creates a new local scope each time a function
							  is entered.
							  
					Private - Private variables are local to their own parse
							  module.  In this way they behave much like
							  file-scope static variables in C.  The
							  implementation of this feature is done by the
							  parser which whenever Private:: is parsed, it
							  is translated to ~<ModuleName>::.  Function
							  calls (i.e., use of the '@' or '@@' operators)
							  automatically look in Private scope if the
							  function is not found in the local scope (then,
							  if not found, look in the global scope).
							  
					Named	- General case of global scope.  Any named scope
							  can be created or accessed with the :: operator.
							  By default, named scopes (except for Global) are
							  designated as Sticky.  This means that the
							  variables in the scope remain until destroyed
							  explicitly.  Non-sticky scopes have their
							  contents destroyed by SlangVariableDestroy which
							  is called by some applications each time a
							  Slang script is executed.

				There are a few different functions and operators that work
				with variable scopes.  The Scope function and the '::'
				operator allow for variables within a scope to be
				explicitly referenced. The Scopes function returns a list
				of scope names.  The ScopeSetSticky function is used to set
				or clear the sticky flag for a named scope.  The Variables
				function returns a list of all the variables in a given
				scope.

				There are three types of diddle scope:
					Global	- A script starts evaluation at the global scope.
							  Currently different Slang evaluators cleanup in
							  different ways after a script is run.  The Tap
							  evalutor destroys the global scope, while the
							  SecView and SecExpr evaluators do not.
							  
					Eval	- Diddles done within the block of an Eval
							  function get removed automatically when the
							  block is exited.  The Eval scope provides the
							  safest scope for diddling.
							  
					Sticky	- Diddles remain even after the script has
							  finished running, unless the diddles were
							  explicitly removed by the script itself (using
							  the Restore function.)

	SORT ORDER: 2.25

      FUNCTION: Value Methods and Diddles

   DESCRIPTION: VALUE METHODS:
				--------------

				Slang is designed to make working with securities and security
				related data an integral part of the language.  To implement
				this ease-of-use goal, value methods on a security have been
				made to look like functions:

					Value Type( Security Name [,Args] )
						or
					Value Type( Security [,Args]] )

				Where 'Value Type' is a type of value that the security
				supports, such as - 'Dollar Price', 'Denominated', etc.
				The ForValue function can be used to enumerate value types.

				'Security' or 'Security Name' refer to objects in the database
				such as 'DEM', 'USD/DEM', 'Security Database', etc.

				'Args' are optional parameters passed to the
				security with the value type.  There may be any number
				of arguments supported by the value method.  The value
				method specifies the semantics and datatype for each
				argument.  Any argument may be omitted (by explicit
				omission if on the end or by using NULL) in which
				case the value method will use its default value
				(possibly calculated) for that argument.

				Examples of using value methods:
				
					Print( Spot( "USD/DEM" ), "\n" );

					Rates = Interest Rate Curve( "USD" ) * 100;
					Print( Rates, "\n" );
					
				With arguments:
				
					FwdFwdVol = Volatility( "DEM/USD", 
                                        Date( "3May99" ),
                                        Date( "3May00" ));
					

				DIDDLES:
				--------

				Slang is also designed to make hypothetical scenarios easy
				to write.  The SecDb 'Diddle' mechanism is used for this
				purpose.  The dictionary defines diddle as -
				
					'to move rapidly up and down or backward and forward'

				Diddles in SecDb are simply overrides of values that would
				be obtained from objects.  The syntax for a diddle in slang
				is as follows:
				
					Value Type( Security ) =	Diddle Value;
					Value Type( Security ) +=	Diddle Value;
					Value Type( Security ) *=	Diddle Value;
					Value Type( Security ) -=	Diddle Value;
					Value Type( Security ) /=	Diddle Value;

				The assignment and operator-assignment operators when used
				on a value method will actually diddle the security to the
				specified diddle value.  Diddles can also be set with the
				SetDiddle function.

				The scope (range for which something applies) of a diddle
				depends upon where the diddle is done.  Read the section on
				scope for a full explanation.

				Diddles can be removed by using the Restore function.

				Example diddles:
				
					Sec = GetSecurity( "Some Test Option" );
					Start Price = Price( Sec );
					Eval
					{
						Pricing Date( "Security Database" ) += 1;
						End Price = Price( Sec );
					};
					One Day Theta = End Price - Start Price;
					
				Diddles can also be set programatically with the built-in
				function SetDiddle.

	SORT ORDER: 2.26

      FUNCTION: Introduction to Slang Datatypes

   DESCRIPTION:	Slang provides many instrinsic datatypes.  Slang can be
   				extended to provide additional functions and datatypes.

				The assignment operator when used with the intrinsic
				datatypes makes a copy (not a pointer reference) of the
				value being assigned.

				All of the Slang functions return something, the datatypes
				returned are defined by the functions.  A variable that is
				on the left side (an LVALUE) of an assignement is created
				automatically if it doesn't already exist.

				The memory associated with variables is kept track of by
				Slang.  If a variable is reassigned (even to a different
				datatype) Slang will free the original data before assigning
				the new data.

				Boolean values (True and False) are of the 'Double' datatype.

				There are over one hundred Slang datatypes.  (Some are even
				documented!)

					Allocation					PointerArray            
					Any                         Pos Effects             
					Array                       Price Fix Data          
					Binary                      RCurve                  
					Bogus                       RDate                   
					Book Index Value            Reference               
					CFunc                       RegEx                   
					Chart2D                     RTime                   
					Chart2DElem                 RTsdbConnection         
					Chart3D                     SecDb Dynamic Numbers   
					CMatrix                     SecDb Dynamic Pointers  
					Complex                     SecDb Node              
					Curve                       SecDb Node Flags        
					CVector                     SecDb Pass Through      
					Database                    Security                
					Date                        Security List           
					Dialog                      Sheet                   
					DiddleScope                 Simulation Results Cache
					DiddleScopeList             Slang                   
					DlgWidget                   Socket                  
					Double                      Spork                   
					Each                        SqlConnection           
					Edit Info                   String                  
					Ellipsis                    Structure               
					Error                       StructureCase           
					Event Manager Connection	Sve                     
					Fame Connection             Symbol                  
					File                        SymbolCase              
					FossGoldCObject             TCurve                  
					GCurve                      Time                    
					GRCurve                     Time Series             
					Grid Range                  Triarch Item            
					Grid Sheet                  Triarch Source          
					Grid WorkBook               Typed Structure         
					GS1 Security                UdbConnection           
					GsDt                        UPF                     
					GsDtIter                    UPF Connection          
					GxHandle                    UPF Portfolio           
					GxImage                     UPF Security            
					Index Pos                   Value Array             
					Java Class                  Value Type              
					Java Object                 Value Type Info         
					Java VM                     Vdk Collection          
					Matrix                      Vdk Search Handle       
					Nearby Data                 Vdk Session             
					Net Effects                 Vector                  
					Null                        Vol Matrix              
					Ole Method                  Vol Vector              
					Ole Object                  VtApply                 
					Ole Type Info               Window                  
					Ole Type Lib                ZData                   
					Page
					Pointer

	SORT ORDER: 3.0

      FUNCTION: Array

   DESCRIPTION:	Datatype.

				Arrays can be created using any of three methods:
				
					a = Array();
					a = New( "Array" );
					a = [];
					
				The third method 'a = []' uses a special initializer that
				was designed to make the creation of arrays easier to do.
				In the above example, an empty array is created.  Below,
				an array containing a number of different this is created:
				
					a = [ "Zero", 1, Interest Rate Curve( "DEM" ) ];
				
				Nested arrays are also supported:
				
					Sample creation:
						a = [ [ 0, 1 ], [ 2, 3 ] ];

					Sample access:
						n = a[ 1 ][ 1 ];	(Which would return 3)
						s = a[ 0 ];			(Which would return [ 0, 1 ])


				Size() returns the number of elements in the array.

	SORT ORDER: 3.1

      FUNCTION: Binary

   DESCRIPTION:	Datatype.

				Binary values can be created using either of these methods:
				
					a = Binary();
					a = New( "Binary" );
					
				The binary datatype can be used to hold any arbitrary stream
				of bytes.
				
				The decimal value of each individual byte can be accessed
				using the [] syntax, e.g., b[ 3 ] is the decimal value of
				the fourth byte in b.  Size() returns the number of bytes
				of binary data.
				
				Binary data is returned by some functions, e.g.,
				FileReadBinary.  Many other datatypes can be converted to
				and from a Binary.  In this case the Binary value is a
				platform-independent streamable representation of the value.
				The conversion is done as follows:
				
					b = Binary( SomeValue );
					
				the inverse operation is the same, e.g., if SomeValue is a
				structure:
				
					Structure( b );

	SORT ORDER: 3.1

      FUNCTION: Chart2d

   DESCRIPTION:	Datatype.

				Two dimensional charts can be created using any of the
				following methods:
				
					a = Chart2d();
					a = New( "Chart2d" );

				The following components are supported:
					AxisFontName	- Name of the font used for the axes.
					AxisFontSize	- Size of the font used for the axes.
					BackgroundColor	- Color around graph.
					BorderPercent  	- Size of graph border.
					Elements       	- Items to graph (of type Chart2dElem).
					End            	- End date/time of graph.
					Flags          	- Graph attributes.
					FontSizeType	- Type of size used for fonts (points,etc)
					GraphColor     	- Color of data portion of graph.
					LogoColor      	- Color of logo.
					Start          	- Start date/time of graph.
					Subtitle       	- Subtitle string.
					SubtitleFontName- Name of the font used for the subtitle.
					SubtitleFontSize- Size of the font used for the subtitle.
					Title          	- Title string.
					TitleColor     	- Color of title and subtitle.
					TitleFontName	- Name of the font used for the title.
					TitleFontSize	- Size of the font used for the title.
					Type           	- Graph type--time series, histogram, etc.
					XGridColor     	- Color of vertical part of grid.
					XTitle         	- Title for x axis.
					Y1GridColor    	- Color of right-side horizontal grid.
					Y1Title        	- Title for right-side y axis.
					YGridColor     	- Color of left-side horizontal grid.
					YTitle         	- Title for left-side y axis.


				Flag values (may be added together):
					CHART2D_ATTR_LOGO           - Show logo
					CHART2D_ATTR_OUTLINE        - Show outline
					CHART2D_ATTR_X_GRID         - Show x grid lines
					CHART2D_ATTR_Y1_GRID        - Show right-side y grid lines
					CHART2D_ATTR_Y_GRID         - Show left-side y grid lines
					
				Type values
					CHART2D_TYPE_HISTOGRAM      - Histogram graph.
					CHART2D_TYPE_MATURITY       - Maturity graph.
					CHART2D_TYPE_SCATTER_PLOT   - Scatter plot.
					CHART2D_TYPE_TIME_SERIES    - Time series (default).

				The following functions operate on/with the Chart2d datatype:
					Chart2dElem	- Datatype of each charted dataset.
					CellData	- Include a chart within a sheet.

	SORT ORDER: 3.1

      FUNCTION: Chart2dElem

   DESCRIPTION:	Datatype.

				Datasets used with two dimensional charts can be created
				using either of the	following methods:
				
					a = Chart2dElem();
					a = New( "Chart2dElem" );

				The following components are supported:
					Axis      	- 0 for left-hand y axis, 1 for right-hand.
					Color     	- Color of data markings on graph.
					Flags     	- Flags.
					Label     	- Label text.
					LineType  	- Type of graph line.
					LineWidth 	- Thickness of graph line.
					MarkerType	- Type of marker for each data point.
					Style     	- Graph style.
					Value     	- Dataset (Curve or Time Series).
					
				Flag values (can be added together):
					CHART2D_FLAG_ENABLED
					CHART2D_FLAG_SHOW_MEAN
					CHART2D_FLAG_SHOW_NORMAL
					CHART2D_FLAG_SHOW_REGLINE
					CHART2D_FLAG_SHOW_STD
					CHART2D_FLAG_VISIBLE
					
				LineType values:
					GX_LINETYPE_ALTERNATE
					GX_LINETYPE_DASHDOT
					GX_LINETYPE_DASHDOUBLEDOT
					GX_LINETYPE_DOT
					GX_LINETYPE_DOUBLEDOT
					GX_LINETYPE_INVISIBLE
					GX_LINETYPE_LONGDASH
					GX_LINETYPE_SHORTDASH
					GX_LINETYPE_SOLID
					
				MarkerType values:
					GX_MARKTYPE_BLANK
					GX_MARKTYPE_CROSS
					GX_MARKTYPE_DIAMOND
					GX_MARKTYPE_DOT
					GX_MARKTYPE_EIGHTPOINTSTAR
					GX_MARKTYPE_PLUS
					GX_MARKTYPE_SIXPOINTSTAR
					GX_MARKTYPE_SMALLCIRCLE
					GX_MARKTYPE_SOLIDDIAMOND
					GX_MARKTYPE_SOLIDSQUARE
					GX_MARKTYPE_SQUARE
					
				Style values:
					CHART2D_STYLE_AREA
					CHART2D_STYLE_BAR
					CHART2D_STYLE_CANDLE
					CHART2D_STYLE_NORMAL
					CHART2D_STYLE_SPLINE
					CHART2D_STYLE_STEP
					CHART2D_STYLE_UNDEFINED
					CHART2D_STYLE_VOLUME

	SORT ORDER: 3.1

      FUNCTION: Chart3d

   DESCRIPTION:	Datatype.

				Three dimensional charts can be created using any of the
				following methods:
				
					a = Chart3d();
					a = New( "Chart3d" );

				The following components are supported:
					CustomPalette	- Array of color values.
					Flags			- Modification flags (detailed below.)
					FlatAngle		- Horizontal base angle.
					Light			- Light source flags.
					Palette			- Palette type (detailed below.)
					Style			- Graph style (detailed below.)
					TiltAngle		- Vertical tilt angle.
					Title			- Name of the graph.
					Xlabel			- Label attached to x-axis.
					Xticks			- Legend attached to x-axis.
					Xlight			-
					Xvalues			-
					Ylabel			- Label attached to y-axis.
					Yticks			- Legend attached to y-axis.
					Ylight			-
					Yvalues			-
					Zlabel			- Label attached to z-axis.
					ZoomFactor		- Zoom amount, 1 is the default, greater
									  than 1 will make the graph bigger, etc.
					Zticks			- Legend attached to z-axis.
					Zhigh			- Bottom of chart (default is autoscale).
					Zlow			- Top of chart (default is autoscale).
					Zlights			-

				Style values:
					THREE_D_STYLE_BAR   		- Bar graph.
					THREE_D_STYLE_BLOCK 		- High-speed block graph.
					THREE_D_STYLE_CONTOUR		- Contour line graph.
					THREE_D_STYLE_HEAT 	 		- Flat heat-map graph.
					THREE_D_STYLE_SHADE 		- Shaded surface graph.
					THREE_D_STYLE_SPHERE		- Sphere f(x,y,z) graph.
					THREE_D_STYLE_STICK 		- Discrete point graph.
					THREE_D_STYLE_TOROID		- Map data onto a donut.
					THREE_D_STYLE_WIRE  		- Wire frame graph.

				Flag values (can be added together):
					THREE_D_FLAG_BORDERS      	- Patch & bar surface borders.
					THREE_D_FLAG_BLACKNESS     	- Black background.
					THREE_D_FLAG_WALLS         	- Solid back walls.
					THREE_D_FLAG_BASE          	- Solid base.
					THREE_D_FLAG_OUTLINE       	- Graph bounding box.
					THREE_D_FLAG_PERSPECTIVE   	- False perspective.
					THREE_D_FLAG_DOUBLE_BUFFER 	- Double image buffering for a
												  cleaner screen refresh.
					THREE_D_FLAG_AXIS_LABELS   	- Axis labels and ticks.
					THREE_D_FLAG_HIDDEN_LINE   	- Hidden line removal for wire
												  frame style.
					THREE_D_FLAG_CROSS_HATCH   	- Intersecting lines for wire
												  frame style.
					THREE_D_FLAG_INVERT_PALETTE	- Invert color palette.
					THREE_D_FLAG_CONTOURS		- Project contours on base.
					
				Light values:
					THREE_D_LIGHT_SHADING		- Brighten from light source.
					THREE_D_LIGHT_ZCOLOR		- Brighten higher values.
					THREE_D_LIGHT_BOTH			- Both shading and zcolor.

				Palette values:
					THREE_D_PAL_BLUE1       	- Dark blue to bright magenta.
					THREE_D_PAL_BLUE2       	- Dark blue to bright cyan.
					THREE_D_PAL_BLUE_SOLID  	- Dark blue to bright blue.
					THREE_D_PAL_CUSTOM      	- App. supplied palette.
					THREE_D_PAL_EARTH       	- Ugly earthtone attempt.
					THREE_D_PAL_GRAY        	- Black to white.
					THREE_D_PAL_GREEN1      	- Dark green to bright cyan.
					THREE_D_PAL_GREEN2      	- Dark green to bright yellow.
					THREE_D_PAL_GREEN_SOLID 	- Dark green to bright green.
					THREE_D_PAL_RAINBOW			- Entire spectrum.
					THREE_D_PAL_RED1        	- Dark red to bright yellow.
					THREE_D_PAL_RED2        	- Dark red to bright magenta.
					THREE_D_PAL_RED_SOLID   	- Dark red to bright red.

				The following functions operate on/with the Chart3d datatype:
					Draw3d		- Display/update a view of a chart.
					Point3d		- Set/get a point within a chart.
					CellData	- Include a chart within a sheet.

	SORT ORDER: 3.1

      FUNCTION: Curve

   DESCRIPTION:	Datatype.

				An empty curve can be created using:
				
					a = Curve();
					a = New( "Curve" );

				There is no explicit curve initializer function.  To build
				a curve, you can must put your points into an array and
				convert it into a curve:
				
					a = Curve( [
							Date( 19900101 ), 10,
							Date( 19910101 ), 20,
							Date( 19920101 ), 30 ] );

				
				Operators:
					Curve + Double		- Add to each knot's value
					Curve - Double		- Subtract from each knot's value
					Curve * Double		- Multiply each knot's value
					Curve / Double		- Divide each knot's value


				Assignment Operators:
					Curve += Double		- Add to each knot's value
					Curve -= Double		- Subtract from each knot's value
					Curve *= Double		- Multiply each knot's value
					Curve /= Double		- Divide each knot's value


				Subscript and Component Operators:
					Curve[ Double ]			- Structure containing a knot's
											  date and value.
					Curve[ Date or String ]	- Linear interpolated point.

				Size() returns the number of knots in the curve.

				Curve.Dates 	returns an array of dates
				Curve.Values 	returns an array of values

				Curves are always logically evaluated to True.

	SORT ORDER: 3.1

      FUNCTION: Database

   DESCRIPTION: Datatype.

				A SecDb database can be connected to by using:
				
					a = Database( "NYC Production" );

				To operate on the database, the UseDatabase function can be
				called.

	SORT ORDER: 3.1

      FUNCTION: Date

   DESCRIPTION:	Datatype.

				A date can be created using:

					a = Date();
					a = New( "Date" );

				The two methods of creating a date above are not very
				useful.  To create and set the value of a date use:

					a = Date( 19900101 );	// Convert double to date
					a = Date( "1Jan90" );	// Convert string to date


				Operators:
					Date1 - Date2		- Number of days between dates

					Date + Double		- Add days (Double) to Date
					Date - Double		- Subtract days (Double) from Date


				Assignment Operators:
					Date -= Double		- Add days (Double) to Date
					Date += Double		- Subtract days (Double) from Date


				Compare Operators:
					Date1 <	  Date2		- Less than
					Date1 >	  Date2		- Greater than
					Date1 <=  Date2		- Less than or equal to
					Date1 >=  Date2		- Greater than or equal to
					Date1 ==  Date2		- Equal to
					Date1 !=  Date2		- Not equal to
					Date1 <=> Date2		- Compare (-1, 0, 1)


				Unary Operators:
					++Date				- Add 1 day, then return value
					Date++				- Return value, then add 1 day
					--Date				- Subtract 1 day, then return value
					Date--				- Return value, then subtract 1 day

				Valid dates are logically evaluated to True, invalid dates
				are logically evaluated to False.

	SORT ORDER: 3.1

      FUNCTION: Dialog datatype

   DESCRIPTION:	Datatype.
   
   				The Dialog datatype is used for character-cell dialog boxes.

	SORT ORDER: 3.1

      FUNCTION: DlgWidget

   DESCRIPTION:	Datatype.
   
   				The DlgWidget datatype is used for Visual Slang interface
   				objects.

	SORT ORDER: 3.1

      FUNCTION: Double

   DESCRIPTION:	Datatype.

				Slang treats the Double, String and Null datatypes different
				from other datatypes.  There is built-in implied creation
				for these datatypes.  Below are examples of Doubles:

					3
					3.1415
					-.001


				Operators:
					Double1 + Double2	- Add Double2 to Double1
					Double1 - Double2	- Subtract Double2 from Double1
					Double1 * Double2	- Multiply Double1 by Double2
					Double1 / Double2	- Divide Double1 by Double2


				Assignment Operators:
					Double1 += Double2	- Add Double2 to Double1
					Double1 -= Double2	- Subtract Double2 from Double1
					Double1 *= Double2	- Multiply Double1 by Double2
					Double1 /= Double2	- Divide Double1 by Double2


				Compare Operators:
					Double1 <	Double2	- Less than
					Double1 >	Double2	- Greater than
					Double1 <=  Double2	- Less than or equal to
					Double1 >=  Double2	- Greater than or equal to
					Double1 ==  Double2	- Equal to
					Double1 !=  Double2	- Not equal to
					Double1 <=> Double2	- Compare (-1, 0, 1)


				Unary Operators:
					++Double			- Add 1, then return value
					Double++			- Return value, then add 1
					--Double			- Subtract 1, then return value
					Double--			- Return value, then subtract 1

				Non-zero Doubles will logically evaluate to True, while
				zero Doubles logically evaluate to False.

	SORT ORDER: 3.1

      FUNCTION: Edit Info

   DESCRIPTION:	Datatype.
   
   				The Edit Info datatype is a interface-independent layout for
   				a dialog box.

	SORT ORDER: 3.1

      FUNCTION: Event Manager Connection

   DESCRIPTION:	Datatype.
   
   				The Event Manager Connection datatype is a handle to an
   				event manager.  Events can be written or retreived from
   				an existing event manager.  The functions that deal with
   				Event Manager Connections are:
   				
					EventManagerConnect
					EventManagerFor
					EventManagerGet
					EventManagerLast
					EventManagerPut
					EventManagerTypes

	SORT ORDER: 3.1

      FUNCTION: File

   DESCRIPTION:	Datatype.

				The following functions operate on the File datatype:

					FileCreate				- Create a file
					FileDelete				- Delete a file
					FileExists				- Determine if a file exists
					FileOpen				- Open a file
					FileReadBinary			- Read binary data from a file
					FileReadLine			- Read a line from a file
					FileSeek				- Reposition file pointer
					FileTell				- Retrieve file pointer
					FileWrite				- Write output to a file

	SORT ORDER: 3.1

      FUNCTION: GxHandle

   DESCRIPTION:	Datatype.

	SORT ORDER: 3.1

      FUNCTION: GxImage

   DESCRIPTION:	Datatype.

	SORT ORDER: 3.1

      FUNCTION: Index Pos

   DESCRIPTION:	Datatype.

	SORT ORDER: 3.1

      FUNCTION: Nearby Data

   DESCRIPTION:	Datatype.

	SORT ORDER: 3.1

      FUNCTION: Null

   DESCRIPTION:	Datatype.

				Size() always returns 0.

				Nulls are always logically evaluated to False.

	SORT ORDER: 3.1

      FUNCTION: Page

   DESCRIPTION:	Datatype.

	SORT ORDER: 3.1

      FUNCTION: Pointer

   DESCRIPTION:	Datatype.

				The pointer datatype is similar to the C language concept
				of pointers.  A pointer can point to a variable's value, to
				a component or subscript of a value, or to another
				pointer.  The pointer can be used in much the same way as
				though it were the actual value to which it points.  The
				dot, subscript, and asterisk are operations supported by
				pointers.  Pionters are created with the ampersand
				operators and are used internally in Slang for assignment
				operations and some built-in functions.
	
				Pointers are created with the ampersand operator or by
				assignment from another pointer.  Pointers are also used
				internally by slang whenever an expression is evaluated
				asking for an lvalue, such as during an assignment
				operation.  Some examples:

				x = [1, 2, 3 ];
				px = &x;			// pointer to the array x
				qx = &x[ 2 ];		// pointer to the third element of x
				ppx = &px;			// pointer to px which points to x

				y = Structure(); y.foo = 12; y.bar = "Hello";
				py = &y;			// pointer to the structure y
				qy = &y.bar;		// pointer to the bar component of y
				ppy = &py;			// pointer to py which points to y
				pyb = &y.bar[0];	// points to the "H" in "Hello"

				z = Curve( [ Date( "3May95" ), 12, Date( "6May95" ), -4.2 ] );
				pz = &z;			// pointer to the curve z
				qz = &z[ 0 ];		// pointer to the first knot of z
				rz = &z["5May95"];	// pointer to (new) 5May94 knot's value

				s = "A String";
				ps = &s;			// pointer to the string s
				qs = &s[ 3 ];		// pointer to fourth character in s
				pqs = &qs;			// pointer to qs which points to s[ 3 ]

				c = [ x, y, z, s ];
				pc = &c[2].bar[2];	// pointer to the third letter in y.bar

	
				Pointers can be dereferenced by the asterisk operator. 
				Continuing with the above examples:

				*qx = 15;			// x contains array [ 1, 15, 3 ]
				*px &= "a";			// x contains array [ 1, 15, 3, "a" ]
				*px = "diff";		// x contains the string "diff"
				**ppx = 13;			// x contains 13
				x = 14;				// x (and *px and **ppx) is now 14
	
				*pyb = "Some j";	// y.bar is now "Some jello"
				*qy += " molds";	// y.bar is now "Some jello molds"
				Print( **ppy );		// Prints y
				Print( *py );		// Also prints y
	
				*rz = 3.8;			// z now is (3May, 12), (5May, 3.8), etc.
				Print( *qz );		// Prints: "Date:  3May95\nValue: 12";
				x = Array( *pz );	// Creates an array version of z in x
	
				*qs = "";			// s is "A Sring"
				*pqs = 0;			// qs is no longer a pointer and is 0

	
				The dot and bracket operators and the built-in function Size
				always operate on the pointed-to value.  In the case where
				the pointed-to value is another pointer, the operation is
				passed through recursively to the eventual non-pointer
				value.  (In C, the parallel is the -> operator, although
				there is no equivalent recursive dereferencing operation in
				C.)

				*px = [ 1, 15, 3, "a" ];
				px[ 2 ] = -3;		// x is now [ 1, 15, -3, "a" ]
				ppx[ 2 ] /= -1;		// x is now [ 1, 15, 3, "a" ]
	
				py.glob = "wow!";	// y.glob is now "wow!"
				ppy.bar += " soon";	// y.foo is now "Some jello molds soon"
				ppy[ "glob" ] = 1;	// y.glob is now 1
	
	
				Size( ppx );		// is same as Size( x ) which is 4
				Size( ps );			// is same as Size( s ) which is 7
	
	
				Pointers are used internally by Slang whenever an "lvalue"
				is needed.  (An lvalue is the type of value needed for the
				"left-hand side" of an assignment and an rvalue is the type
				of value needed for the "right-hand side" of the
				assignment, i.e., the rvalue is the actual value whereas the
				lvalue is the address of the value.)  During an Slang
				assigment, the expression on the left of the = is evaluated
				as a pointer and the assignment is passed to this pointer,
				e.g., 
	
					x = 12 * 3;
		
				is evaluated by:

					1) get &x
					2) evaluate rvalue for 12 * 3
					3) assign that value to &x
		
					
				Pointers can be passed as arguments to Slang functions just
				like any other value:

				Foo = Func( Arg ) { Print( Arg, ", ", Arg.Foo ); Arg = 0; };
				y = Structure( [ "Foo", 99 ] );
				py = &y; 
	
				@Foo( py );			// Prints "&Global::y, 99"
				Print( y );			// Prints "Foo: 99"
	
				However, the & operator is treated specially in a function
				call.  The ampersand causes the argument to be passed to
				the function as a special kind of pointer called a
				reference variable which is automatically dereferenced
				every time it is used:

				@Foo( &y );			// Prints "Foo: 99, 99"
				Print( y );			// Prints "0"
	
				Passing components to a function work the same way:
	
				y = Structure( [ "Foo", 99 ] );
				w = [ y ];
	
				@Foo( w[ 0 ] );		// Prints "Foo: 99, 99"
				Print( w );			// Prints "[  0] = foo: 99"
	
				@Foo( &w[ 0 ] );	// Prints "Foo: 99, 99"
				Print( w );			// Prints "[  0] = 0"


				The values referenced by pointers remain active until all
				references to them are gone, i.e., destroying the variable
				containing a value does not destroy the value if there are
				any extant pointers to it.  The value is automatically
				destroyed when the last reference to it is destroyed.  This
				is even true across scope changes, e.g., if a non-local
				pointer exists pointing to a local variable, the variable's
				value remains alive even after the variable goes out of
				scope until the pointer is destroyed:

				Bar = Func()
				{
					p = [ 1, 2, 3 ]; 		// p is a local variable
					s1::ptr = &p[ 3 ]		// s1::ptr is non-local variable
		
				};			// p is destroyed but the array it contained
							// remains until s1::ptr is destroyed

	SORT ORDER: 3.1

      FUNCTION: Price Fix Data

   DESCRIPTION:	Datatype.

	SORT ORDER: 3.1

      FUNCTION: RCurve

   DESCRIPTION:	Datatype.

	SORT ORDER: 3.1

      FUNCTION: RDate

   DESCRIPTION:	Datatype.

				An RDate can be created using:

					a = RDate();
					a = New( "RDate" );

				The two methods of creating an RDate above are not very
				useful.  To create and set the value of a date use:

					a = Date( "1m" );	// Convert string to rdate (one month)


				The format for an RDate is related to the operation types
				used by AddDate.  The format consists of a numeric portion
				and a single letter type.

				Operation types (these are CASE SENSITIVE, BE CAREFUL):
					b - Business day
					c - Coupon dates (calendar months)
					d - Julian days
					e - End of month
					f - Forward dates (Friday before end of month is
						considered end of month)
					i - IMM month
					l - LME month
					m - Month  (with end of month trading)
					p - PHILLY month
					s - Add spot days (like b but holiday weirdness)
					w - Week but taking into account holidays
					x - Last business day of month (ignores Amount)
					y - Add years
					M - nth Monday of month
					T - nth Tuesday of month
					W - nth Wednesday of month
					R - nth Thursday of month
					F - nth Friday of month

	SORT ORDER: 3.1

      FUNCTION: Reference

   DESCRIPTION: Datatype.

				References are reference counted DT_VALUEs.  They are similar
				to Pointers in Slang, only different.  References are faster
				than slang Pointers, but you must decide when creating the
				data structure that you want to access it via a reference.
				
				A copy happens here when the reference is first initialized
					Ref = Reference( Structure( [ ... lots of stuff ] ) );
					
				No copy is made when a reference is assigned (just the reference
				count is incremented).
					Ref2 = Ref1;
					
				No copy here
					Some Array &= Ref2;
					
				Also changes Ref1 (and the tail of Some Array), since they
				are all the same thing.
					Ref2.Component = 8;
					
				How many references are there to Ref1/2?
					Print( Ref1._RefCount, "\n" );
					
				Are Ref1 & Ref2 really the exact same object?
					Print( Ref1 == Ref2, " or Ref1.Id = ", Ref1._RefId,
					       "  Ref2.Id = ", Ref2._RefId, "\n" );
					
				What if I want the actual value, not this silly reference
				counted thing?
					A Copy of The Value = Ref1._RefValue;
					
				Oh!  I guess that means I can change the type as well.
					Ref2._RefValue = 8;	// Yup.
					
				How can I really confuse myself?
					Ref1._RefValue = &Ref2;	// That oughta do it!
					
				The main goals are to increase speed by reducing copying
				and to reduce pointer confusion by having something that
				acts more like a C pointer (and kinda acts like a Security
				object).

				(Also look at http://www.ja.gs.com/institute/slangintro/)
					
	SORT ORDER: 3.1

      FUNCTION: RegEx

   DESCRIPTION: Datatype.

				A RegEx can be created using:

					a = RegEx( RegularExpressionString );
					
				or:
				
					b = RegEx([ RegularExpressionString, Flags ]);

				Where RegularExpressionString is of String datatype and
				Flags is any of:
				
					REG_EXTENDED	Use POSIX extended syntax
					REG_ICASE		Ignore case
					REG_NEWLINE		. and [^...] do not match newline
					
				Default value for Flags is just REG_EXTENDED, i.e. first
				example is equivalent to:
				
					a = RegEx([ RegularExpressionString, REG_EXTENDED ]);

				For an explanation of regular expressions read the perl,
				grep, sed or vi documentation.

				The RegMatch function is used to match regular expressions,
				and the RegSub function is used to perform substitutions.

	SORT ORDER: 3.1

      FUNCTION: Security

   DESCRIPTION:	Datatype.

	SORT ORDER: 3.1

      FUNCTION: Sheet

   DESCRIPTION: Datatype.

				The sheet datatype consists of a grid of cells.  Each cell in
				the grid contains three pieces of information - Data, Font and
				Attributes.  The Data portion can contain any datatype and is
				viewed as the 'contents' of the cell.  The Font portion
				contains the font information used for printing the sheet.
				The Attribute portion contains formatting information used
				when printing.

				A sheet can be created using:
				
					a = Sheet();
					a = New( "Sheet" );


				The following functions operate on the sheet datatype:
					CellAttr			- Set a single cell's attributes
					CellAttrRange		- Set attributes for a range of cells
					CellData			- Set a single cell's content
					CellDataRange		- Set contents for a range of cells
					CellFont			- Set a single cell's font
					CellFontRange		- Set font for a range of cells
					CellFormat
					CellFormatRange
					SheetBox			- Draw a box around a group of cells
					SheetColumnWidth	- Set the width of a column of cells
					SheetPostscript		- Output sheet in postscript format

				The following attributes are defined:
					CELL_AT_BLACK			- Background is black
					CELL_AT_BORDER_BOTTOM	- Border on the bottom of the cell
					CELL_AT_BORDER_BOX		- Border around the entire cell
					CELL_AT_BORDER_LEFT		- Border on the left of the cell
					CELL_AT_BORDER_RIGHT	- Border on the right of the cell
					CELL_AT_BORDER_TOP		- Border on the top of the cell
					CELL_AT_BOX_BY_2		- Box every two rows
					CELL_AT_BOX_BY_3		- Box every three rows
					CELL_AT_BOX_BY_5		- Box every five rows
					CELL_AT_CENTER			- Center text within cell
					CELL_AT_CHART2D			- Include chart2d image
					CELL_AT_CHART3D			- Include chart3d image
					CELL_AT_END_HEADING_0	- Last row under level-0 heading
					CELL_AT_END_HEADING_1	- Last row under level-1 heading
					CELL_AT_END_HEADING_2	- Last row under level-2 heading
					CELL_AT_END_HEADING_3	- Last row under level-3 heading
					CELL_AT_EPS_FILE		- Include encapsulated postscript
					CELL_AT_HEADING_0		- Part of level-0 heading
					CELL_AT_HEADING_1		- Part of level-1 heading
					CELL_AT_HEADING_2		- Part of level-2 heading
					CELL_AT_HEADING_3		- Part of level-3 heading
					CELL_AT_HORIZONTAL_BAR	- Shaded horizontal bar
					CELL_AT_LEFT			- Left justify cell text
					CELL_AT_LOGO			- Cell contains a Goldman logo
					CELL_AT_NEW_PAGE		- Row starts a new page
					CELL_AT_PAGE_NUMBER		- Append page number to cell text
					CELL_AT_RIGHT			- Right justify cell text
					CELL_AT_SHADE			- Background is gray-shaded
					CELL_AT_SHADE_BY_3		- Shade every other three rows
					CELL_AT_SHADE_BY_5		- Shade every other five rows

				The following fonts are defined:
					CELL_FACE_AVANT_
					CELL_FACE_BOOKMAN          
					CELL_FACE_COURIER          
					CELL_FACE_HELVETICA        
					CELL_FACE_HELVETICA_BLACK  
					CELL_FACE_HELVETICA_NARROW 
					CELL_FACE_NEW_CENTURY      
					CELL_FACE_PALATINO         
					CELL_FACE_SYMBOL           
					CELL_FACE_TIMES            
					CELL_FACE_ZAPF_CHANCERY    
					CELL_FACE_ZAPF_DINGBATS    
				
				The following font weights are defined:
					CELL_WEIGHT_BOLD
					CELL_WEIGHT_ITALIC
					CELL_WEIGHT_NORMAL

				Subscript and Component Operators:
					a.FontFace			- Set or query the default typeface
					a[ "FontFace" ]  	  for the entire sheet.
					
					a.FontSize			- Set or query the default size of
					a[ "FontSize" ]		  the font.

					a.FontWeight		- Set or query the default weight of
					a[ "FontWeight" ]	  the font.

	SORT ORDER: 3.1

      FUNCTION: Simulation Results Cache

   DESCRIPTION:	Datatype.

	SORT ORDER: 3.1

      FUNCTION: Slang

   DESCRIPTION:	Datatype.

				Size() always returns 1.

	SORT ORDER: 3.1

      FUNCTION: Socket

   DESCRIPTION:	Datatype.
   
   				A socket represents a tcp/ip connection to another socket in
   				another process on this or another host.  A socket can be
   				created	by SocketAccept, SocketConnect, or
   				SocketMsgServerLoopSwitch.  A socket can be written to with
   				SocketWrite or SocketMsgWrite and read from with
   				SocketReadBinary, SocketReadLine, SocketReadResult, or
   				SocketMsgRead.  Ability to read or write can be queried by
   				SocketPollInput and SocketPollOutput.  SocketListen designates
   				a socket able to accept new connections from other peers.  
   				Additional functions are provided for querying
   				tcp/ip information:  GetHostByAddress, GetHostByName,
   				HostName, and String( Socket ).
   				
   				The SocketMsg api and SocketMsgServer api help manage socket
   				messaging between peers and provide functionality for
   				building client/server applications.  SocketMsgWrite sends
   				an integer message type and arbitrary value and SocketMsgRead
   				recieves the message type and value.  These functions
   				automatically handle situations which need multiple packets
   				for large messages.  SocketMsgServerLoopSwitch provides a
   				template for the server side of a client/server application.

	SORT ORDER: 3.1

      FUNCTION: SQL Connection

   DESCRIPTION:	Datatype.

	SORT ORDER: 3.1

      FUNCTION: String

   DESCRIPTION:	Datatype.

				Slang treats the Double, String and Null datatypes different
				from other datatypes.  There is built-in implied creation
				for these datatypes.  Below are examples of Strings:

					"Test String"
					"String with a carriage return\n"
					$'Single quote delimeters, no backslash translation'


				Operators:
					String1 + String2	- String2 appended to String1


				Assignment Operators:
					String1 += String2	- String2 appended to String1
					String1 &= String2	- String2 appended to String1


				Compare Operators:
					String1	<	String2 - less than
					String1	>	String2 - greater than
					String1	<=	String2 - less than or equal to
					String1	>=	String2 - greater than or equal to
					String1	==	String2 - equal to
					String1	!=	String2 - not equal to
					String1	<=>	String2 - compare (-1, 0, 1)

					All of the compare operations on strings are case
					insensitive.


				Subscript and Component Operators:
					String[ Double ]	- Single character string at character
										  position of Double


				Conversion Operators:
					String( AnyValue )	- All datatypes are requires to
										  support conversion to strings.


				Size() returns the number of characters in the string (strlen).

				Strings are always logically evaluated to True.

	SORT ORDER: 3.1

      FUNCTION: Structure

   DESCRIPTION:	Datatype.

				A structure can be created using:

					a = Structure();
					a = New( "Structure" );
					a = Structure( [ "Tag1", Value1, ... "TagN", ValueN ] );

				Once a structure has been created, components can be set:
				
					a.Name		= "Demo Name;
					a.Location	= "New York;
					a.Hours		= 8;
					a.Points	= [ 1, 2, 3, 4 ];

				Another way to get/set components within a structure is
				by using the subscript operator:
				
					a[ "Name" ]	= "Demo Name2";
					Print( a[ "Points" ] );

				The ForComponent function is used to run through a structure's
				components and evaluate a block, the following code prints out
				the name of each component, and its concomitant value:

					ForComponent( Name, Struct )
						Print( Name, " = ", Struct[ Name ], "\n" );


				Operators:
					Struct1 + Struct2	- Add contents of both structures
					Struct1 - Struct2	- Subtract contents of 2 from 1
					Struct1 * Struct2	- Multiply contents of both structures
					Struct1 / Struct2	- Divide contents of 1 by 2

					Struct1 + AnyValue	- Add AnyValue to each component
					Struct1 - AnyValue	- Subtract AnyValue from components
					Struct1 * AnyValue	- Multiply each component by AnyValue
					Struct1 / AnyValue	- Divide each component by AnyValue


				Assignment Operators:
					Struct1 += Struct2	- Add contents of both structures
					Struct1 -= Struct2	- Subtract contents of 2 from 1
					Struct1 *= Struct2	- Multiply contents of both structures
					Struct1 /= Struct2	- Divide contents of 1 by 2

					Struct += AnyValue	- Add AnyValue to each component
					Struct -= AnyValue	- Subtract AnyValue from components
					Struct *= AnyValue	- Multiply each component by AnyValue
					Struct /= AnyValue	- Divide each component by AnyValue
				

				Compare Operators:
					Struct1	== Struct2	- Contents of structures equal
					Struct1	!= Struct2	- Contents of structures not equal


				Subscript and Component Operators:
					Struct.Component
					Struct[ "Component" ]


   				Size() returns the number of components in the structure

				Structures are always logically evaluated to True.

	SORT ORDER: 3.1

      FUNCTION: Sve

   DESCRIPTION:	Datatype.

	SORT ORDER: 3.1

      FUNCTION: Time

   DESCRIPTION:	Datatype.

				A date can be created using:
					a = Time();
					a = New( "Time" );

				The two methods of creating a Time above are not very
				useful.  To create and set the value of a Time use:
					a = Time( 727560991 );	// Number of secs from Jan 1, 1980
					a = Time( "10:10:00" );	// Convert String to Time

				Operators:
					Time1 - Time2		- Number of seconds between Times
					Time + Double		- Add seconds (Double) to Time
					Time - Double		- Subtract seconds (Double) from Time

				Assignment Operators:
					Time -= Double		- Add seconds (Double) to Time
					Time += Double		- Subtract seconds (Double) from Time

				Compare Operators:
					Time1 <	  Time2		- less than
					Time1 >	  Time2		- greater than
					Time1 <=  Time2		- less than or equal to
					Time1 >=  Time2		- greater than or equal to
					Time1 ==  Time2		- equal to
					Time1 !=  Time2		- not equal to
					Time1 <=> Time2		- compare (-1, 0, 1)

				Unary Operators:
					++Time				- Add 1 second, then return value
					Time++				- Return value, then add 1 second
					--Time				- Subtract 1 second, then return value
					Time--				- Return value, then subtract 1 second

   				Size() always returns 1.

				If a Time is valid it logically evaluates to True, otherwise
				it logically evaluates to False.

	SORT ORDER: 3.1

      FUNCTION: Time Series

   DESCRIPTION:	Datatype.

	SORT ORDER: 3.1

      FUNCTION: Vol Matrix

   DESCRIPTION:	Datatype.

	SORT ORDER: 3.1

      FUNCTION: Vol Vector

   DESCRIPTION:	Datatype.

	SORT ORDER: 3.1

      FUNCTION: Window

   DESCRIPTION: Datatype.

				A window can be created using:
					a = Window();
					a = New( "Window" );

				Once a window has been created, it can be moved and resized
				using W_Relocate.
				
				A window will be closed and removed when the variable goes
				out of scope, or is explicitly destroyed (using Destroy).

				The character cursor controls where text will be printed
				using the W_Print function.
				
				The line cursor is used by the W_Pick function.  The W_Pick
				function lets the user scroll through, and select lines from
				a window.

				The following components are supported (read only):
					x_cur		- X location of character cursor
					y_cur		- Y location of character cursor
					l_cursor	- Line number of the line cursor

				The following functions operate on windows:
					W_Attach		- Attach two windows together
					W_Color			- Set the current window color
					W_Del			- Delete lines from a window
					W_Detach		- Detach attached windows
					W_GetKey		- Get a key from the keyboard
					W_GetLine		- Get a string from a window
					W_Hide			- Hide a window
					W_Ins			- Insert blank lines into a window
					W_LineCursor	- Set position of the line cursor
					W_MakeVis		- Make a window region visible
					W_Pick			- Pick through a window
					W_Pos			- Position cursor within a window
					W_Print			- Print output into a window
					W_RefOff		- Turn screen refreshing off
					W_RefOn			- Turn screen refreshing on
					W_Relocate		- Change window's screen location
					W_Select		- Bring window to top
					W_Show			- Display a hidden window
					W_Title			- Set a window's titles

      FUNCTION: Abort

       SUMMARY: Simulate abort key operation

         USAGE: Abort()

       RETURNS: Nothing

   DESCRIPTION: The Abort function is used to simulate the user pressing the
   				abort key.  If the AbortTrap function is used, the Abort
   				function can be used either inside the AbortTrap - to simulate
   				the user aborting, or outside the AbortTrap - to continue with
   				the abort processing.

      SEE ALSO: AbortTrap, AbortCheck, Error

      FUNCTION: AbortCheck

       SUMMARY: Set poll rate for abort action

         USAGE: AbortCheck( CheckFrequency )
         		{
         			BLOCK
         		}

       RETURNS: Null

   DESCRIPTION: The AbortCheck function changes the frequency of polling
   				the application for an abort action (e.g., the Escape key
   				in SecView).  The CheckFrequency argument is the number of
   				seconds between checks.  Zero means always check.  Less than
   				zero means never check.  Typical uses for this function are
   				1) speed up some part of a script at the expense of possibly
   				delaying an interrupt from the user, or 2) delaying an abort
   				action until some uninterruptable piece of code is finished
   				(note that the abort is only delayed not ignored).

      SEE ALSO: AbortTrap, Abort

       EXAMPLE: AbortCheck( -1 )
       			{
       				// Some uninteruptable stuff here
       			};
       			// The abort action will be held until this point

      FUNCTION: AbortTrap

       SUMMARY: Evaluate a block and trap user aborts

         USAGE: AbortTrap
         		{
         			BLOCK;
         		}

       RETURNS: True  - User aborted
       			False - No abort

   DESCRIPTION: The AbortTrap function allows a script to take over abort
   				handling.  If the user aborted the script or the Abort
   				function was executed then AbortTrap will return True.  The
   				script will not be aborted (but the code between the abort
   				action and the end of AbortTrap's block will NOT be executed).
   				
   				AbortTrap provides a mechanism for cleaning up resources that
   				a script has allocated, and would leave allocated if aborted
   				in the middle of evaluation.

      SEE ALSO: Abort, AbortCheck

       EXAMPLE: /*
       			**	Create a file with the names of all the objects in
       			**	the database.  If the user aborted, the file is removed
       			*/
       			
	       			Output = FileCreate( "objects" );
	       			Aborted = AbortTrap
	       			{
	       				ForSecurity( Sec, Null )
	       					FileWrite( Output, Sec, "\n" );
	       			};
	       			
	       			// Close the file
	       			Destroy( Output );

	       			if( Aborted )
	       				FileDelete( "objects" );

      FUNCTION: Abs

       SUMMARY: Numeric absolute value

         USAGE:	Abs( Number )

       RETURNS: Absolute value of 'Number'

   DESCRIPTION:	Return the absolute value of 'Number'.  This function only
   				works on doubles.

      SEE ALSO:	Sign, Mod, Ceil, Floor

      FUNCTION: AddDate

       SUMMARY: Date arithmetic function

         USAGE:	AddDate(
         			BaseDate,	// Date to start from
         			Type,		// Operation to perform
         			Amount,		// Amount to add/subtract, etc...
         			Currency1,	// Optional first currency (for holidays)
         			Currency2)	// Optional second currency (for holidays)

       RETURNS: Date

   DESCRIPTION:	The AddDate function performs arithmetic on dates.
   				All operations start at BaseDate.

				Operation types (these are CASE SENSITIVE, BE CAREFUL):
					b - Business day
					c - Coupon dates (calendar months)
					d - Julian days
					e - End of month
					f - Forward dates (Friday before end of month is
						considered end of month)
					i - IMM month
					l - LME month
					m - Month  (with end of month trading)
					p - PHILLY month
					s - Add spot days (like b but holiday weirdness)
					w - Week but taking into account holidays
					x - Last business day of month (ignores Amount)
					y - Add years
					M - nth Monday of month
					T - nth Tuesday of month
					W - nth Wednesday of month
					R - nth Thursday of month
					F - nth Friday of month

				Currency1 and Currency2 are optional 3 letter ISO codes.
				If these arguments are supplied, the appropriate holiday
				tables will be used in the date calculations.
				
      SEE ALSO:	Date

      FUNCTION: ArgCheck

       SUMMARY: Check to see if a value is a member of a set of values

         USAGE:	ArgCheck(
         			CompareValue,
         			TestValue1,
         			...
         			TestValueN)

       RETURNS: True  - CompareValue matches a TestValue
       			False - CompareValue not found in TestValues

   DESCRIPTION:	Check the first argument 'CompareValue' against the remaining
   				arguments and return True if there is match.

      SEE ALSO:	Or

      FUNCTION: ArrayDelete

       SUMMARY: Delete elements in an array

         USAGE: ArrayDelete( Array, Element [,Count] )

       RETURNS: True  - Elements deleted without error
       			False - Error deleting elements

   DESCRIPTION: Delete Count elements from an array datatype starting at
   				Element.  The array will shrink in size by Count.  Count
   				defaults to 1 if not supplied.

      SEE ALSO: ArrayInsert, Array

      FUNCTION: ArrayInsert

       SUMMARY: Insert elements into an array

         USAGE: ArrayInsert( Array, Element [,Count] )

       RETURNS: True  - Elements inserted without error
       			False - Error inserting elements

   DESCRIPTION: Insert Count elements into an array datatype starting at
   				Element.  The array will grow in size by Count.  Count
   				defaults to 1 if not supplied.  The newly inserted elements
   				are set to Null by default.

      SEE ALSO: ArrayInsert, Array

      FUNCTION: Asc

       SUMMARY: Decimal to ascii

         USAGE: Asc( Number )

       RETURNS: One-character string

   DESCRIPTION: Asc converts a numeric value to its ascii character value.

      SEE ALSO: Chr, SPrintf

       EXAMPLE: // Print the uppercase alphabet
       			For( Num = Chr( "A" ); Num <= Chr( "Z" ); Num++ )
       				Print( Asc( Num ));
       			Print( "\n" );

      FUNCTION: BitAnd

       SUMMARY: Bitwise AND operator.

         USAGE:	BitAnd( Number1, Number2 )

       RETURNS: Number1 and'ed with Number2

   DESCRIPTION: Perform bitwise AND operation between two numbers.

      SEE ALSO: BitNot, BitOr, BitXOr
				    
      FUNCTION: BitNot

       SUMMARY: Bitwise NOT operator.

         USAGE:	BitNot( Number1 )

       RETURNS: Number1 bitwise not.

   DESCRIPTION: Perform bitwise NOT operation on a number.

      SEE ALSO: BitAnd, BitOr, BitXOr

      FUNCTION: BitOr

       SUMMARY: Bitwise OR operator.

         USAGE:	BitOr( Number1, Number2 )

       RETURNS: Number1 or'ed with Number2

   DESCRIPTION: Perform bitwise OR operation between two numbers.

      SEE ALSO: BitAnd, BitNot, BitXOr

      FUNCTION: BitXOr

       SUMMARY: Bitwise XOR operator.

         USAGE:	BitXOr( Number1, Number2 )

       RETURNS: Number1 xor'ed with Number2

   DESCRIPTION: Perform bitwise EXCLUSIVE-OR operation between two numbers.

      SEE ALSO: BitAnd, BitNot, BitOr

      FUNCTION: BookPositionDecrement

       SUMMARY: Decrement a position in a book

         USAGE:	BookPositionDecrement(
         			BookName,
         			SecurityTraded,
         			QuantityOffset,
         			TradeName)

       RETURNS: True  - Position changed without error
       			False - Error changing position

   DESCRIPTION:	Change position as though deleting a trade called
				TradeName of quantity QuantityOffset from BookName's
				position on SecurityTraded.  The trade id is extracted
				from TradeName; the position name is constructed
				from BookName and SecurityTraded as in BookPositionLookup.
				
				THIS FUNCTION IS INTENDED FOR TESTING PURPOSES ONLY.

      SEE ALSO:	BookPositionIncrement, BookPositionLookup,
      			BookPositionLookupName

      FUNCTION: BookPositionIncrement

       SUMMARY: Increment a position in a book

         USAGE:	BookPositionIncrement(
         			BookName,
         			SecurityTraded,
         			QuantityOffset,
         			TradeName)

       RETURNS: True  - Position changed without error
       			False - Error changing position

   DESCRIPTION:	Change position as though inserting a trade called
				TradeName of quantity QuantityOffset from BookName's
				position on SecurityTraded.  The trade id is extracted
				from TradeName; the position name is constructed
				from BookName and SecurityTraded as in BookPositionLookup.
				
				THIS FUNCTION IS INTENDED FOR TESTING PURPOSES ONLY.

      SEE ALSO:	BookPositionDecrement, BookPositionLookup,
      			BookPositionLookupName

      FUNCTION: BookPositionLookup

       SUMMARY: Lookup a position name in a book

         USAGE:	BookPositionLookup(
         			BookName,
         			SecurityTraded)

       RETURNS: The name of the position in the current database, or
       			NULL if the position does not currently exist.

   DESCRIPTION:	Finds the existing position that a trade on SecurityTraded
   				for BookName would change.
   				
   				The BookName and SecurityTraded are used to determine the
   				name of the position object in the database.  This is
   				constructed as "Book " + BookName + HashValue, where
   				HashValue is the first three characters of
   				Security Type( SecurityTraded ) plus a hash number
   				calculated from SecurityTraded.  There is a slight chance
   				that a position with that name has already been created
   				for a different SecurityTraded.  In this case, the
   				hash number is incremented until the position is found.

      SEE ALSO:	BookPositionLookupName, BookPositionIncrement,
      			BookPositionDecrement
      			
       EXAMPLE: /*
       			**	This code pulls up the edit screen for DMV1's
       			**	position on the security where the cursor is 
       			**	in secview.
       			*/
       			
       			if( PosName = BookPositionLookup( "DMV1", Argv[ 0 ] ))
       				EditSecurity( PosName )
       			:
       				Print( LastError(), "\n" );

      FUNCTION: BookPositionLookupName

       SUMMARY: Lookup a position name in a book (if the position doesn't
       			exist, return the proposed name of the position)

         USAGE:	BookPositionLookupName(
         			BookName,
         			SecurityTraded)

       RETURNS: The intended name of the position.

   DESCRIPTION:	Calculates the intended name of the position that a trade
   				on SecurityTraded for BookName would create or change.
   				
   				The BookName and SecurityTraded are used to determine the
   				name of the position object in the database.  This is
   				constructed as "Book " + BookName + HashValue, where
   				HashValue is the first three characters of
   				Security Type( SecurityTraded ) plus a hash number
   				calculated from SecurityTraded.  The position may not
   				yet exist or it may exist but be for a different
   				SecurityTraded (see BookPositionLookup).  
   				BookPositionLookup, unlike BookPositionLookupName, will
   				not attempt to look for resolutions hashing conflicts.

      SEE ALSO:	BookPositionLookup, BookPositionIncrement,
      			BookPositionDecrement

       EXAMPLE: /*
       			**	This code compares the apparent positions that
       			**	were affected by the trade named in argv[ 0 ]
       			**	against the actual positions affected.
       			*/
       			
       			Trade = GetSecurity( Argv[ 0 ] );
       			PosEffects = Position Effects( Trade );
       			for( Pos, PosEffects )
       				Print( 
       						Pos.Book " on ", Pos.Security, "\n",
       						"apparent: ", 
       						BookPositionLookupName( Pos.Book, Pos.Security ), 
       						"\n",
       						"actual: ",
       						BookPositionLookup( Pos.Book, Pos.Security ), 
       						"\n\n" );

      FUNCTION: Break

       SUMMARY: Flow control - Loop abort

   DESCRIPTION:	Terminates the smallest enclosing For* or While statement
   				in which it appears.

      SEE ALSO:	Continue, While, For

      FUNCTION: Bsearch

       SUMMARY: Binary search on an array datatype

         USAGE: Bsearch(
         			Array,
         			SearchData)

       RETURNS: Matching element number if found
       			Null if no match

   DESCRIPTION: The Bsearch function performs a binary search on 'Array'
   				looking for 'SearchData'.  'Array' must be in sorted order
   				for this function to work correctly.

      SEE ALSO: Sort, Array, Structure

      FUNCTION: Ceil

       SUMMARY: Numeric rounding up function

         USAGE:	Ceil( Number )

       RETURNS: Smallest integer that is greater than or equal to 'Number'

   DESCRIPTION:	Smallest integer that is greater than or equal to 'Number'.
   				This function only operates on Doubles.

      SEE ALSO:	Floor

      FUNCTION: CellAttr

       SUMMARY: Set the attribute for a single cell in a sheet

         USAGE: CellAttr(
         			Sheet,			// Spreadsheet to use
         			Column,			// Column number
         			Row,			// Row number
         			[Attributes])	// Attributes added together

       RETURNS: True/False if Attributes is specified
       			Attribute within cell if Attributes is not specified

   DESCRIPTION: The attribute, font and font weight constants are only
				defined if the script "SheetInfo Constants" has been linked.
				The statement should look like:

					Link( "SheetInfo Constants" );


   				The following attributes are defined:
					CELL_AT_BLACK			- Background is black
					CELL_AT_BORDER_BOTTOM	- Border on the bottom of the cell
					CELL_AT_BORDER_BOX		- Border around the entire cell
					CELL_AT_BORDER_LEFT		- Border on the left of the cell
					CELL_AT_BORDER_RIGHT	- Border on the right of the cell
					CELL_AT_BORDER_TOP		- Border on the top of the cell
					CELL_AT_BOX_BY_2		- Box every two rows
					CELL_AT_BOX_BY_3		- Box every three rows
					CELL_AT_BOX_BY_5		- Box every five rows
					CELL_AT_CENTER			- Center text within cell
					CELL_AT_CHART2D			- Include chart2d image
					CELL_AT_CHART3D			- Include chart3d image
					CELL_AT_END_HEADING_0	- Last row under level-0 heading
					CELL_AT_END_HEADING_1	- Last row under level-1 heading
					CELL_AT_END_HEADING_2	- Last row under level-2 heading
					CELL_AT_END_HEADING_3	- Last row under level-3 heading
					CELL_AT_EPS_FILE		- Include encapsulated postscript
					CELL_AT_HEADING_0		- Part of level-0 heading
					CELL_AT_HEADING_1		- Part of level-1 heading
					CELL_AT_HEADING_2		- Part of level-2 heading
					CELL_AT_HEADING_3		- Part of level-3 heading
					CELL_AT_HORIZONTAL_BAR	- Shaded horizontal bar
					CELL_AT_LEFT			- Left justify cell text
					CELL_AT_LOGO			- Cell contains a Goldman logo
					CELL_AT_NEW_PAGE		- Row starts a new page
					CELL_AT_PAGE_NUMBER		- Append page number to cell text
					CELL_AT_RIGHT			- Right justify cell text
					CELL_AT_SHADE			- Background is gray-shaded
					CELL_AT_SHADE_BY_3		- Shade every other three rows
					CELL_AT_SHADE_BY_5		- Shade every other five rows

      SEE ALSO: Sheet, CellAttrRange, CellData, CellFont, SheetBox

      FUNCTION: CellAttrRange

       SUMMARY: Set the attributes for a range of cells in a sheet

         USAGE: CellAttrRange(
					Sheet,			// Spreadsheet to use
 					Column1,   		// Starting column of range
 					Row1,			// Starting row of range
 					Column2,   		// Ending column of range
 					Row2,			// Ending row of range
 					Attributes)		// Attributes for cells

       RETURNS: Null

   DESCRIPTION: The attribute, font and font weight constants are only
				defined if the script "SheetInfo Constants" has been linked.
				The statement should look like:

					Link( "SheetInfo Constants" );

   
   				The following attributes are defined:
					CELL_AT_BLACK			- Background is black
					CELL_AT_BORDER_BOTTOM	- Border on the bottom of the cell
					CELL_AT_BORDER_BOX		- Border around the entire cell
					CELL_AT_BORDER_LEFT		- Border on the left of the cell
					CELL_AT_BORDER_RIGHT	- Border on the right of the cell
					CELL_AT_BORDER_TOP		- Border on the top of the cell
					CELL_AT_BOX_BY_2		- Box every two rows
					CELL_AT_BOX_BY_3		- Box every three rows
					CELL_AT_BOX_BY_5		- Box every five rows
					CELL_AT_CENTER			- Center text within cell
					CELL_AT_CHART2D			- Include chart2d image
					CELL_AT_CHART3D			- Include chart3d image
					CELL_AT_END_HEADING_0	- Last row under level-0 heading
					CELL_AT_END_HEADING_1	- Last row under level-1 heading
					CELL_AT_END_HEADING_2	- Last row under level-2 heading
					CELL_AT_END_HEADING_3	- Last row under level-3 heading
					CELL_AT_EPS_FILE		- Include encapsulated postscript
					CELL_AT_HEADING_0		- Part of level-0 heading
					CELL_AT_HEADING_1		- Part of level-1 heading
					CELL_AT_HEADING_2		- Part of level-2 heading
					CELL_AT_HEADING_3		- Part of level-3 heading
					CELL_AT_HORIZONTAL_BAR	- Shaded horizontal bar
					CELL_AT_LEFT			- Left justify cell text
					CELL_AT_LOGO			- Cell contains a Goldman logo
					CELL_AT_NEW_PAGE		- Row starts a new page
					CELL_AT_PAGE_NUMBER		- Append page number to cell text
					CELL_AT_RIGHT			- Right justify cell text
					CELL_AT_SHADE			- Background is gray-shaded
					CELL_AT_SHADE_BY_3		- Shade every other three rows
					CELL_AT_SHADE_BY_5		- Shade every other five rows

      SEE ALSO: Sheet, CellAttr, CellDataRange, CellFontRange, SheetBox

      FUNCTION: CellData

       SUMMARY: Set the value (contents) of a cell in a sheet

         USAGE: CellData(
         			Sheet,			// Spreadsheet to use
         			Column,			// Column number
         			Row,			// Row number
         			[Data])			// Data to set

       RETURNS: True/False if Data is specified
       			Data within cell if Data is not specified

   DESCRIPTION: The CellData function sets the contents of a single cell
   				within a sheet.

      SEE ALSO: Sheet, CellDataRange, CellAttr, CellFont

      FUNCTION: CellDataRange

       SUMMARY: Set the value (contents) for a range of cells in a sheet

         USAGE: CellDataRange(
					Sheet,			// Spreadsheet to use
 					Column1,   		// Starting column of range
 					Row1,			// Starting row of range
 					Column2,   		// Ending column of range
 					Row2,			// Ending row of range
 					Data)			// Data to set

       RETURNS: Null

   DESCRIPTION: The CellDataRange function sets the contents of a range of
   				cells within a sheet.

      SEE ALSO: Sheet, CellData, CellAttrRange, CellFontRange

      FUNCTION: CellFont

       SUMMARY: Set the font information for a cell in a sheet

         USAGE: CellFont(
         			Sheet,			// Spreadsheet to use
         			Column,			// Column number
         			Row,			// Row number
					[FontFace],		// Typeface of font
					[FontSize],		// Size of font in points (72/inch)
					[FontWeight])	// Weight of font (bold, italic...)

       RETURNS: Null

   DESCRIPTION: If FontFace, FontSize or FontWeight are Null or omitted,
				then corresponding value in the cell will not be modified.

				The following fonts are defined:
					CELL_FACE_AVANT_
					CELL_FACE_BOOKMAN          
					CELL_FACE_COURIER          
					CELL_FACE_HELVETICA        
					CELL_FACE_HELVETICA_BLACK  
					CELL_FACE_HELVETICA_NARROW 
					CELL_FACE_NEW_CENTURY      
					CELL_FACE_PALATINO         
					CELL_FACE_SYMBOL           
					CELL_FACE_TIMES            
					CELL_FACE_ZAPF_CHANCERY    
					CELL_FACE_ZAPF_DINGBATS    

				The following font weights are defined:
					CELL_WEIGHT_BOLD
					CELL_WEIGHT_ITALIC
					CELL_WEIGHT_NORMAL

      SEE ALSO: Sheet, CellFontRange, CellAttr, CellData

      FUNCTION: CellFontRange

       SUMMARY: Set the font information for a range of cells in a sheet

         USAGE: CellFontRange(
					Sheet,			// Spreadsheet to use
 					Column1,   		// Starting column of range
 					Row1,			// Starting row of range
 					Column2,   		// Ending column of range
 					Row2,			// Ending row of range
					[FontFace],		// Typeface of font
					[FontSize],		// Size of font in points (72/inch)
					[FontWeight])	// Weight of font (bold, italic...)

       RETURNS: Null

   DESCRIPTION: If FontFace, FontSize or FontWeight are Null or omitted,
				then corresponding value in the cell will not be modified.

				The following fonts are defined:
					CELL_FACE_AVANT_
					CELL_FACE_BOOKMAN          
					CELL_FACE_COURIER          
					CELL_FACE_HELVETICA        
					CELL_FACE_HELVETICA_BLACK  
					CELL_FACE_HELVETICA_NARROW 
					CELL_FACE_NEW_CENTURY      
					CELL_FACE_PALATINO         
					CELL_FACE_SYMBOL           
					CELL_FACE_TIMES            
					CELL_FACE_ZAPF_CHANCERY    
					CELL_FACE_ZAPF_DINGBATS    

				The following font weights are defined:
					CELL_WEIGHT_BOLD
					CELL_WEIGHT_ITALIC
					CELL_WEIGHT_NORMAL

      SEE ALSO: Sheet, CellFont, CellAttrRange, CellDataRange

      FUNCTION: Center

       SUMMARY: Create a string where the input is centered

         USAGE:	Center(
	         		Width,	// Width of returned string
					Data) 	// Data to center

       RETURNS: String with 'Data' centered within

   DESCRIPTION:	Center justify 'Data' converted into a string.

      SEE ALSO:	Right, Left, Format, Print

       EXAMPLE:	/*
       			**	Output sample
       			*/

					Print(	Left(   20, "Left Justify"   ), "\n",
							Right(  20, "Right Justify"  ),	"\n",
							Center( 20, "Center Justify" ),	"\n" );

      FUNCTION: ChDir

       SUMMARY: Change the current working directory

         USAGE: ChDir( Directory )

       RETURNS: True	- The directory was changed without error
       			False	- Couldn't change directory

   DESCRIPTION: Change the current directory for the application.  This
   				will affect all file functions that don't explicitly
   				specify the path.

      SEE ALSO: MkDir, RmDir

       EXAMPLE: /*
       			**	Set the current directory to C:\OS2 and print the
       			**	contents
       			*/
       			
       				ChDir( "c:/os2" );
       				ForFile( FileName )
       					Print( FileName, "\n" );

      FUNCTION: Constant

       SUMMARY: Define a constant

         USAGE: Constant(
         			ConstantName,	// Name of constant
         			Value)			// Numeric value

       RETURNS: None

   DESCRIPTION: The Constant function allows a script to define constants
   				at parse time.  Slang only supports numeric constants
   				(Double datatype).  The Constant function is executed at
   				parse time unlike most functions in slang that execute at
   				run time.

      SEE ALSO: Enum

      FUNCTION: Continue

       SUMMARY: Flow control - Loop continue

   DESCRIPTION:	Passes control to the next iteration of the smallest
				enclosing For* or while statement in which it appears.

      SEE ALSO:	Break, For, While

      FUNCTION: Cos

       SUMMARY: Arithmetic cosine.

         USAGE:	Cos( Number )

       RETURNS: Cosine of the Number specified

   DESCRIPTION:	Trigonometric function to return the cosine of a number.
   				'Number' is expressed in radians.  This function only
   				operates on Doubles.

      SEE ALSO:	Sin, Tan

      FUNCTION: CurrentGMTTime

       SUMMARY: Current Greenwich Mean Time.

         USAGE:	CurrentGMTTime()

       RETURNS: Current Greenwich Mean Time.

   DESCRIPTION:	The CurrentGMTTime function returns the current Greenwich
   				Mean Time.  The function should be reliable, because it
   				synchonizes the time to a file server.

      SEE ALSO:	Time, CurrentTime

      FUNCTION: CurrentTime

       SUMMARY: Current time

         USAGE:	CurrentTime()

       RETURNS: Current system time.

   DESCRIPTION:	The CurrentTime function returns the current time from the
   				computer.  The time clock on the computer is not necessarily
   				synchronized to the network.

      SEE ALSO:	Time, CurrentGMTTime

       EXAMPLE: /*
       			**	Perform an operation and display the amount of time
       			**	that elapsed
       			*/

					Starting Time = CurrentTime();
					For( Loop = 0; Loop < 10000; Loop++ )
						;
					Ending Time = CurrentTime();

					Print( "Started: ",	Starting Time, "   ",
							"Ended: ",	Ending Time, "   ",
							"Seconds: ",Ending Time - Starting Time, "\n" );

      FUNCTION: CurveAdd

       SUMMARY: Add two curves together.

         USAGE:	CurveMerge(
					CurveA,			// First curve
					CurveB)			// Second curve

       RETURNS: Sum curve
				NULL if error

   DESCRIPTION: Create a new curve which is the sum of CurveA and CurveB.
   				The knots of the resulting curve are the union of the knots
   				of CurveA and CurveB.  Missing knots in either curve are
   				linearly interpolated.

      SEE ALSO: CurveAdd

       EXAMPLE:	ACurve = Curve();
				ACurve[ "3May94" ] = 12;
				ACurve[ "3May96" ] = 100;
				
				BCurve = ACurve;
				BCurve[ "3May95" ] = 22.1;

				Print( CurveAdd( ACurve, BCurve ));

				/*
				**  Prints:

 				3May94                 24
 				3May95          78.039808
 				3May96                200

				*/

      FUNCTION: CurveMerge

       SUMMARY: Merge two curves together based upon a date range

         USAGE:	CurveMerge(
					CurveA,			// First curve
					CurveB,			// Second curve
					StartDate,		// Starting date
					EndDate)  		// Ending date

       RETURNS: Merged curve consisting of parts of 'CurveA' and 'CurveB'
				NULL if error

   DESCRIPTION: Create a new curve that consists of parts of 'CurveA' and
   				'CurveB'.  The new curve is built in three pieces:
   				
   					First piece:
	   					'CurveA' from the beginning of time till the day
	   					before 'StartDate'.

					Second piece:
						'CurveB' from 'StartDate' to 'EndDate' (inclusive).

					Third piece:
						'CurveA' from the day after 'EndDate' till the end of
						time.

				At the junctions between 'CurveA' and 'CurveB', extra
				interpolated points are added to the new curve to maintain
				consistency with interpolation.

				If CurveA or CurveB is Null, only points from the supplied
				curve are used.  This is useful for extracting part of a
				curve.

				The CurveMerge function is useful for creating date
				bucketized reports.  CurveMerge can easily be used
				to determine the effect of changes in parts of a volatility
				or interest rate curve over time.

      SEE ALSO: CurveAdd, SecDbCurveMerge

       EXAMPLE:	/*
				**	Determine DEM/USD Kappa for the near month sensitive
				**	securities within a portfolio.  The Kappa is based upon
				**	a 25% move in the volatilties.
				*/

					Security = "Book: B1";
					Cross	 = "DEM/USD";
					Move	 = 1.25;

					Vol Curve= Volatility Curve( Cross );
					Starting Date = Current Date( "Security Database" );
					Ending Date   = Starting Date + 30;

					Kappa = Eval
					{
						Starting Price	= Dollar Price( Security );
						Volatility Curve( Cross ) = CurveMerge( 
								Vol Curve,
								Vol Curve * Move,
								Starting Date,
								Ending Date );
						Dollar Price( Security ) - Starting Price;
					};

					Print( Kappa );

      FUNCTION: DatabaseInfo

       SUMMARY: Info about current database

         USAGE:	DatabaseInfo()

       RETURNS: Structure containing information about the current database

   DESCRIPTION:	The DatabaseInfo function returns a structure with information
				about the current database.

				Components in returned structure:

					DatabasePath	- File path for database
					DbID			- ID number
					DbName			- Database name
					Location		- Physical location of database
					MirrorGroup		- Mirror group that the database
									  belongs to

      FUNCTION: DatabaseSearchPathAppend

       SUMMARY: Append db to search path

         USAGE:	DatabaseSearchPathAppend(
         			ChildDb	)			// Database to append

       RETURNS: Array of database names in the resulting search path

   DESCRIPTION:	When objects exist only in other databases, but are
   				wished to appear as though they exist in the current
   				root database, the database search path can be used.
   				DatabaseSearchPathAppend appends the ChildDb to the
   				list of databases that SecDb searches when trying to
   				find any object in the root database.
   				
   				If the ChildDb is already in the search path, it
   				will remain in the search path but not be moved
   				to the end.
   				
      SEE ALSO:	DatabaseSearchPathDelete, DatabaseSearchPathGet,
      			DatabaseSearchPathSet, GetSecurity, NameUsed,
      			RemoveFromDeadpool

      FUNCTION: DatabaseSearchPathDelete

       SUMMARY: Delete db from search path

         USAGE:	DatabaseSearchPathAppend(
         			ChildDb	)			// Database to delete

       RETURNS: Array of database names in the resulting search path

   DESCRIPTION:	The DatabaseSearchPathDelete function deletes a 
   				database previously put into the search
   				path with DatabaseSearchPathAppend or DatabaseSearchPathSet.
   				
   				Regardless of how many times the ChildDb has been
   				appended or set in the search path, and regardless
   				of its order in the search path, it is deleted.
   				The parent database can even be deleted from the
   				search list if there is at least one other db in
   				its path.
   				
   				When the last item in the search path is deleted,
   				the search path is reverted to just the parent
   				database.
   				
   				If the ChildDb is not currently in the search path,
   				the function completes successfully as though it
   				had deleted it.
   				
      SEE ALSO:	DatabaseSearchPathAppend, DatabaseSearchPathGet,
      			DatabaseSearchPathSet

      FUNCTION: DatabaseSearchPathGet

       SUMMARY: Current search path

         USAGE:	DatabaseSearchPathGet()

       RETURNS: Array of database names in the current search path

   DESCRIPTION:	DatabaseSearchPathGet retrieves the current search
   				path for the root database as set or modified by
   				DatabaseSearchPathAppend, DatabaseSearchPathDelete,
   				or DatabaseSearchPathSet.
   				
      SEE ALSO:	DatabaseSearchPathAppend, DatabaseSearchPathDelete,
      			DatabaseSearchPathSet

      FUNCTION: DatabaseSearchPathSet

       SUMMARY: Change search path

         USAGE:	DatabaseSearchPathSet(
         			SearchPath	)			// Desired search path

       RETURNS: Array of database names in the resulting search path

   DESCRIPTION:	When objects exist only in other databases, but are
   				wished to appear as though they exist in the current
   				root database, the database search path can be used.
   				DatabaseSearchPathSet sets the list of databases that
   				SecDb searches when trying to find any object in the
   				root database.
   				
   				The root database itself will not automatically be
   				in the search path.  It must be included explicitly
   				(typically as its first element).
   				
       EXAMPLE: /*
       			**	Set the search path to look in the archive db
       			**	if it cannot find objects in production.
       			**	Also set search path for archive to look
       			**	first in production, then in archive so any
       			**	child references come back to production if
       			**	possible.
       			*/
       			
       			DatabaseSearchPathSet([ Database(), "NYC Archive" ]);
       			UseDatabase( Database( "NYC Archive" ))
       				DatabaseSearchPathSet([ "NYC Production", "NYC Arcive" ]);
   				
      SEE ALSO:	DatabaseSearchPathDelete, DatabaseSearchPathGet,
      			DatabaseSearchPathGet, GetSecurity, NameUsed,
      			RemoveFromDeadpool

      FUNCTION: Debug

       SUMMARY: Debugger breakpoint

         USAGE:	Debug

   DESCRIPTION:	When evaluating a script with an evaluator that supports
   				debugging (SecView), the Debug function is used to invoke
   				a breakpoint.

				When the breakpoint is hit, the user is able to look at
				the variables, call-stack and source code.  Execution can
				then be allowed to continue, or be aborted by the user.

      FUNCTION: Defined

       SUMMARY: Evaluate an expression and trap all errors.

         USAGE:	Defined( Expression )

       RETURNS: True  - Expression evaluated without error
       			False - Expression couldn't be evaluated

   DESCRIPTION:	Evaluate an expression and trap all errors.  The return value
       			will be True if no error occurred, and False if the expression
       			couldn't be evaluated.

				The Defined function allows a script to trap errors that would
				usually cause evaluation to halt.  Such things as dividing by
				zero, accessing undefined variables, domain errors, etc... can
				be handled by the script.

	   EXAMPLE:	/*
	   			**	If a variable is not defined, set it to a default value
	   			*/

					If( !Defined( Variable ))
						Variable = "Default Value";

      FUNCTION: DeleteSecurity

       SUMMARY: Delete a security from the database

         USAGE:	DeleteSecurity(
	         		Security,		// Security or name of security to delete
	         		NoLoadFlag)		// Flag to bypass loading of the security

       RETURNS: TRUE if the security was deleted without problems
       			FALSE if there was a problem

   DESCRIPTION:	The DeleteSecurity function is used to remove securities from
   				the database.
   				
   				The 'Security' argument can either be a security that
   				was loaded using 'GetSecurity' or it can be the name of
   				a security.

				The 'NoLoadFlag' argument is optional and can either be
				TRUE to indicate that the security should not be loaded, or
				FALSE to indicate that the security should be loaded.  The
				default for this argument is FALSE.

	  SEE ALSO: NewSecurity, GetSecurity, RenameSecurity, UpdateSecurity,
	  			SetValue, SecDbDeleteByName

       EXAMPLE:	/*
       			**	Delete the "Test Option" security from the database
       			*/

					If( !DeleteSecurity( "Test Option" ))
						Print( LastError());

      FUNCTION: Delta

       SUMMARY: Change of one value versus another

         USAGE:	Delta(
	         		ExpressionY,		// Y expression
	         		ValueMethodX,		// X value method
	         		StartDate,			// Optional start date for buckets
	         		EndDate,			// Optional end date for buckets
	         		Epsilon)			// Optional epsilon for diddle

       RETURNS: Dy/Dx

   DESCRIPTION:	Calculate the change in ExpressionY over a change in
   				ValueMethodX.  The amount of change can be set by Epsilon,
   				if Epsilon is not passed it defaults to 0.0001.

				The StartDate and EndDate arguments are optional and apply
				only if ValueMethodX is a curve.

      SEE ALSO:	Gamma

       EXAMPLE:	/*
       			**	Print a simple delta of a test option
       			*/

					Opt = "Test Option";

					Print( Delta( Dollar Price( Opt ), Price( "DEM/USD" )));

      FUNCTION: Destroy

       SUMMARY: Destroy one or more variables

         USAGE:	Destroy(
         			Null)

         		Destroy(
	         		Variable 1,
	         		Variable 2,
	         		...,
	         		Variable N)
	         		
	         	Destroy(
	         		LValue)

       RETURNS: Null

   DESCRIPTION:	The Destroy function removes a variable from the scope, and
   				releases any associated resources.  If Null is passed instead
   				of any variables, all variables in the scope are destroyed.

				Variables in the global scope can also be destroyed using:

					Destroy( Global( Variable ))


				Variables within a function that are declared locally will
				be destroyed automatically when the function returns.
				
				When Destroy is passed a non-null, non-variable expression,
				it passes a destroy message to it.  For structures, this has
				the effect of deleting the component, e.g., Destroy(Foo.Bar)
				removes the Bar component from the structure Foo.  For
				arrays, the effect is equivalent to assigning Null to the
				referenced element, e.g., Destroy( x[2] ) is equivalent to
				x[2] = Null.

      FUNCTION: DestroyComponent

   DESCRIPTION: Deprecated usage.  Use the Destroy function.
   
      SEE ALSO: Destroy, Structure

      FUNCTION: Dialog

       SUMMARY: Slang configurable dialog box

         USAGE:	Dialog(
         			Dialog,		// Array controlling dialog
         			Defaults,	// Initial dialog values
         			Title,		// Dialog window title (Optional)
         			Subtitle )	// Dialog window subtitle (Optional)
         			
       RETURNS: Structure containing dialog values
       			Null - User aborted dialog

   DESCRIPTION:	Invoke a SecEdit dialog.  The Dialog array controls the
   				layout and interaction of the dialog.  The Defaults structure
   				contains the initial values to be set in the dialog.

   				The Dialog functions are context specific.  Some slang
   				evaluators do not support dialog interaction with the user.

      SEE ALSO:	DialogAskStrTab, DialogAskYesNo, DialogEdit, TableInit,
      			DialogUpdateStrTab, SecEdit manual,
      			"Example: Dialog ..." scripts

       EXAMPLE:	/*
				**	Simple dialog example
				*/

    			Format = Structure();
    			Format.Decimal = 2;
    			Format.Flags   = Commas;

    			StrTab = [ "Cow", "Pig", "Sheep", "Goat" ];

    			Table = TableInit(
        			[
            			[ "Type",    "Component"	   ],
            			[ EI_TITLE,  "Example Title"   ],
            			[ EI_DOUBLE, "No Format"       ],
            			[ EI_DOUBLE, "With Format",	   "Extra", Format ],
            			[ EI_STRING, "A String"		   ],
            			[ EI_STRTAB, "A String Table", "Extra", StrTab ]
        			]);

    			Input  = Structure();
    			Input.No Format     =    3.18438;
    			Input.With Format   = 1233.38847;
    			Input.A String Table= "Cow";
    			Result = Dialog( Table, Input, "Simple", "Example" );

    			If( Result )
        			Print( "Dialog Accepted: Result=\n", Result )
    			:
        			Print( "Dialog aborted\n" );

      FUNCTION: DialogAskStrTab

       SUMMARY: Ask the user to select an entry from a string table.

         USAGE:	DialogAskStrTab( Prompt, Table, Default )

       RETURNS: Index into table if something was selected.
       			-1 if user aborted.

   DESCRIPTION:	The DialogAskStrTab function displays a question and a list
   				of things to choose from.  The user is then prompted to select
   				one of the items from the list.

   				The Dialog functions are context specific.  Some slang
   				evaluators do not support dialog interaction with the user.

      SEE ALSO:	Dialog, DialogAskYesNo, DialogEdit, DialogUpdateStrTab

	   EXAMPLE:	/*
				**	Ask the user to pick something from a list
				*/

					StrTab = [ "Chocolate", "Strawberry", "Vanilla" ];
					Flavor = DialogAskStrTab( "Flavor? ", StrTab, "Vanilla" );
					If( Flavor != -1 )
						Print( "You picked ", StrTab[ Flavor ], "\n" );

      FUNCTION: DialogAskYesNo

       SUMMARY: Ask the user a yes/no question

         USAGE:	DialogAskYesNo( Prompt [,Default] )

       RETURNS: True or False

   DESCRIPTION:	The Dialog functions are context specific.  Some slang
   				evaluators do not support dialog interaction with the user.

   				The evaluators that do support this function will ask the
   				user a yes/no question.  The Prompt argument is the question
   				that the user is asked.  The option Default argument will
   				be returned if the user decided not to answer the query.

      SEE ALSO:	Dialog, DialogAskStrTab, DialogEdit, DialogUpdateStrTab

	   EXAMPLE:	/*
	   			**	Ask the user a question
	   			*/

					If( DialogAskYesNo( "Continue? ", False ))
					{
						// Do some more stuff
					};

      FUNCTION: DialogEdit

       SUMMARY: Edit/build a SecEdit dialog

         USAGE:	DialogEdit( Defaults [,Security/Structure] )

       RETURNS: True  - user accepted changes
				False - user aborted changes

   DESCRIPTION:	The DialogEdit function provides the inner dialog building
				function used by the "Editor" slang script to build dialogs.
				The dialog can be an editor for a security or a regular
				dialog for a slang structure.

				The first parameter is a structure with the EditInfoArray
				component set to the initial dialog edit array.  This value
				is required and must be a valid non-empty edit array.

				The second parameter is either a security pointer or a
				structure, depending on the type of dialog being edited.
				This second value is used by the "Test Dialog" function
				as the test security or structure.

      SEE ALSO:	Dialog, DialogAskStrTab, DialogAskYesNo, DialogUpdateStrTab,
				"Editor" slang script

      FUNCTION: DialogUpdateStrTab

       SUMMARY: Update a string table from within a dialog callback

         USAGE:	DialogUpdateStrTab( BinaryInfo, StrTab )

       RETURNS: True or False

   DESCRIPTION:	DialogUpdateStrTab is used to update the string table for
				a dialog field, allowing the string table contents to be
				dependent on other data in the dialog.

      SEE ALSO:	Dialog

	   EXAMPLE:	/**********************************************************
				** Routine: CallBack
				** Returns: EIA_NO_ACTION
				** Action : Update string table
				**********************************************************/

				CallBack = Func( Event, Info )
				{
					if( Event == EIE_FIELD_ENTER )
					{
        				Tab = [ Info.ReturnValue.S1,
        						Info.ReturnValue.S2,
        						Info.ReturnValue.S3 ];
        				DialogUpdateStrTab( Info.Binary Info, Tab );
    				};
    				Return( EIA_NO_ACTION );
				};


				/*
				**	Simple dialog to demonstrate dynamic string tables
				*/

				Template	= Structure();
				Template.S1	= "S1";
				Template.S2	= "S2";
				Template.S3	= "S3";

				Table = TableInit(
  				[
    				[ "Type",    "Component"    ],
    				[ EI_STRING, "S1"			],
    				[ EI_STRING, "S2"			],
    				[ EI_STRING, "S3"			],
    				[ EI_STRTAB, "StrTab",
            	 				"DataWidth",	31,
			     				"Extra", 		[ "xxx" ],
			     				"CallBack",
			     				"@CallBack( CallBackEvent, &CallBackInfo )" ]
  				]);

				Result = Dialog( Table, Template, "Title", "Subtitle" );

				If( Result )
    				Print( "Dialog Accepted: Result=\n", Result )
				:
    				Print( "Dialog aborted\n" );

      FUNCTION: DiskInfo

       SUMMARY: Retrieve an object's disk information

         USAGE:	DiskInfo( Object )

       RETURNS: Structure containing disk information
       			Null - Object couldn't be found

   DESCRIPTION:	Retrieve information about an object in the database.

				Components in returned structure:

					DbCreated	- Name of database where object was created
					DbUpdated	- Name of database where object was updated
					Name		- Name of object
					TimeCreated	- Time object was created
					TimeUpdated	- Time object was last modified
					Type		- Object's class name
					UpdateCount	- Number of times object has been updated
					Version		- Version number of object

      SEE ALSO:	GetSecurity, RemoteDiskInfo

      FUNCTION: DoGlobal

       SUMMARY: Evaluate a block at local scope

         USAGE:	DoGlobal
         		{
         			BLOCK;
         		};

       RETURNS: Returned value of BLOCK

   DESCRIPTION:	Some scripts assume that they are being run at the global
				scope (accessing global variables as if they were local).
   
				From within a function, it is sometimes necessary to evaluate
   				an expression as if it were outside of the function's scope.

      SEE ALSO:	Global, Scope, Scopes, ::

      FUNCTION: Draw3d

       SUMMARY: Draw or refresh a view of a chart3d datatype.

         USAGE:	Draw3d( Chart )

       RETURNS: Null

   DESCRIPTION:	The Draw3d function currently can only be used while
   				evaluating scripts in the 3d program.

				The Draw3d function will render a chart3d datatype to a
				window.  Any changes made by the user will affect the values
				within the displayed datatype.

      SEE ALSO:	Chart3d, Point3d

	   EXAMPLE: See the '3D Demo' script.

      FUNCTION: DynaLinkGetConfig

       SUMMARY: Retrieve array of dll version information

         USAGE:	DynaLinkGetConfig()

       RETURNS: Array of structures containing dll version information

   DESCRIPTION:	The DynaLinkGetConfig function retrieves data from the
   				'DynaLink.cfg' file.  The information is returned in an array
   				of structures.

				The structures have the following components:
				
					Allowed		- Array of structures defined below.
					DllLoadPath	- Actual path of dll.  This is only set if
								  the dll is currently loaded.
					DllName		- Name of dll (without path or extension.)


				The 'Allowed' structures have the following components:
				
					Area		- Build region (core, strat, V... )
					CompileHigh	- Highest allowable compile value.
					CompileLow	- Lowest allowable compile value.
					MajorHigh	- Major revision highest allowable value.
					MajorLow	- Major revision lowest allowable value.
					MinorHigh	- Used, bad idea.
					MinorLow	- Used, bad idea.

      SEE ALSO:	DynaLinkGetVersion, DynaLinkIsLoaded

      FUNCTION: DynaLinkGetVersion

       SUMMARY: Retrieve version information about a specific dll.

         USAGE:	DynaLinkGetVersion( DllName )

       RETURNS: Structure containing dll version information.
       			Null if the dll is not found.

   DESCRIPTION:	The DynaLinkGetVersion function retrieves version data about
   				a specific dll.  The structure returned has the following
   				components:
					Area			- Build region (core, strat, V... )
					CompileNumber	- Number of the compiler.
					CompileTime		- Time the dll was linked.
					Major			- Major revision number.
					Message			- Text informational comment.
					Minor			- Minor revision number.
					Name			- Name of the dll (with extension.)
					Version			- Text version number.

      SEE ALSO:	DynaLinkGetConfig, DynaLinkIsLoaded

      FUNCTION: DynaLinkIsLoaded

       SUMMARY: Determine if a dll is currently loaded.

         USAGE:	DynaLinkIsLoaded( DllName )

       RETURNS: True  - Dll is currently loaded.
       			False - Dll is not currently loaded.

   DESCRIPTION:	Determine if a dll is currently loaded.

      SEE ALSO:	DynaLinkGetConfig, DynaLinkGetVersion

      FUNCTION: EditSecurity

       SUMMARY: Allow user to edit an object in a dialog box

         USAGE:	EditSecurity( Object )

       RETURNS: True  - Object was updated
       			False - Object editing was aborted

   DESCRIPTION:	The EditSecurity function displays a dialog box which allows
   				a user to edit a security.  The dialog box is identical to
   				the one that SecView uses when editing a security.

      SEE ALSO:	ShowSecurity

      FUNCTION: Enum

       SUMMARY: Create numbered constants

         USAGE: Enum
         		{
         			Constant0
         			Constant1
         			.
         			.
         			.
         			ConstantN
         		}

       RETURNS: None

   DESCRIPTION: Define enumerated constants at parse time.  The numbering of
   				the constants start at 0.

      SEE ALSO: Constant

       EXAMPLE: /*
       			**	Define some word constants to be their numbers
       			*/
       			
       				Enum
       				{
       					Zero,
       					One,
       					Two,
       					Three
       				};

      FUNCTION: Err

       SUMMARY: Set error text and error number

         USAGE: Err( ErrorText [, ErrorCode] )

       RETURNS: False

   DESCRIPTION: The Err function sets the error text and optionally the error
   				code.  These values can be referenced by the LastError and
   				LastErrorNumber functions.  The ErrorCode argument should be
   				one of the _ERR_* constants.  If an '@' character is found
   				within ErrorText, it will be replaced with the error text
   				corresponding to the ErrorCode.

      SEE ALSO: ErrMore, ErrorLogOpen, ErrorMessage, LastError, ErrorReturn,
      			LastErrorNumber

       EXAMPLE: /*
       			**	Test inputs and set error when incorrect
       			*/

					Test = Func( Number )
					{
						If( !Defined( Number )
								|| TypeOf( Number ) != "Double" )
							Return( Err( "@", _ERR_INVALID_ARGUMENTS ));

						Return( True );
					};

      FUNCTION: ErrMore

       SUMMARY: Append more error text to the error buffer

         USAGE: ErrMore( ErrorText )

       RETURNS: False

   DESCRIPTION: The ErrMore function prepends the ErrorText argument to the
   				current error text.  This allows functions to return more
   				information to a calling process to determine the nature and
   				path of an error condition.

      SEE ALSO: Err, ErrorLogOpen, ErrorMessage, LastError, ErrorReturn

       EXAMPLE: /*
       			**	if UpdateSecurity fails, add an additional error
       			**	message to indicate it failed in the @Foo() slang routine
       			**	(Note that @ is not translated as it would be in Err()).
       			*/
       			
       			if( !UpdateSecurity( SecPtr ))
       				return( ErrMore( "@Foo" ));

      FUNCTION: ErrorLogOpen

       SUMMARY: Open file to log errors to.

         USAGE: ErrLogOpen( FileName [,LogText] )

       RETURNS: True or False

   DESCRIPTION: The ErrorLogOpen function opens a log file to log all errors
				displayed by form_errmsg (the standard red-box error display).

				The FileName is typically derived from the database path and
				the optional LogText is typically the username.  Each entry
				in the log file includes the current time.

      SEE ALSO: Err, ErrMore, ErrorMore, ErrorMessage, LastError, ErrorReturn

       EXAMPLE: /*
				**	Open errorlog
				*/

				DbPath = DatabaseInfo().DatabasePath;
				ErrorLogOpen( DbPath + "/errorlog/test.log", GetEnv( "USER_NAME" ) );

      FUNCTION: ErrorMessage

       SUMMARY: Display an error message.

         USAGE: ErrorMessage( Message )

       RETURNS: Null

   DESCRIPTION: The implementation of the ErrorMessage function is defined
   				by the context of the slang evaluator.  Some evaluators will
   				display a red box and wait for the user to acknowledge, other
   				evaluators will print the error message to the stderr device.

      SEE ALSO: Err, ErrorMore, ErrorLogOpen, LastError, ErrorReturn,
      			Message

       EXAMPLE: /*
       			**	In secview, display red error box with "Wowzers, Penny!!"
       			*/
       			
       			ErrorMessage( "Wowzers, Penny!!" );

      FUNCTION: ErrorReturn

       SUMMARY: Set the error text and number and generate a slang error.

         USAGE: ErrorReturn( [ErrorText [,ErrorCode]] )

   DESCRIPTION: This is used by a UFO value function to indicate a failed
   				getvalue.
   				
   				Sets the error code and text like Err, but also returns
   				from the current slang function with a SLANG_ERROR return.
   				This is interpreted by the UFO processor as a failed
   				getvalue.

      SEE ALSO: Err, ErrorMore, ErrorLogOpen, ErrorMessage, LastError

       EXAMPLE: /********************************************************
       			**
       			**	Function:	GigaOption::ValueFuncInvPrem
       			**	
       			**	Value Type:	Inverted Premium( obj )
       			**	
       			**	Children:	Premium( obj )
       			**	
       			**	Action:		1 / Premium
       			**
       			*******************************************************/
       			
       			GigaOption::ValueFuncInvPrem = Func( Self, VTI )
       			{
       				if( Premium( Self ) != 0 )
       					return( 1 / Premium( Self ))
       				:
       					ErrorReturn( "@: premium", _ERR_DIVIDE_BY_ZERO );
       			};

      FUNCTION: Eval

       SUMMARY: Evaluate a block and restore values diddled within the block

         USAGE:	Eval
				{
         			BLOCK		// Block to execute
				};

       RETURNS: Last value analyzed within the block

   DESCRIPTION:	Diddles are used to temporarily redefine values that a
   				security returns.  The scope (or influence) of a diddle
   				within Slang can be controlled by using the Eval and
   				Restore functions.

				All of the diddles done within the block are restored when
				the Eval function returns.

	  SEE ALSO: Restore

       EXAMPLE:	/*
				**	Print the dollar theta for the test option
				*/

					Theta = Eval
					{
						Starting Price	= Dollar Price( "Test Option" );
						Pricing Date( "Security Database" ) += 1;
						Dollar Price( "Test Option" ) - Starting Price;
					};

					Print( "Theta:", Format( Theta, 10, 0, _Commas ), "\n" );

      FUNCTION: EvalOnce

       SUMMARY: Evaluates an expression and replaces itself with it's value

         USAGE:	EvalOnce( Expression )

       RETURNS: Value of the expression the first time it was evaluated

   DESCRIPTION:	EvalOnce is primarily used by the parser to tag constant
				subexpressions.

				Constant subexpressions are defined as:

				ConstExpr :=
				   Constant
				|  EvalOnceFunction( ConstExpr, ... )
				|  EvalOnceFunctionBindBlock( ConstExpr, ... ) ConstExpr
				|  ConstExpr BinaryOp ConstExpr

				EvalOnceFunction is a function which is tagged as Eval_Once
				in slang.dat. Most math functions are tagged Eval_Once. Some
				datatype constructors like Double, Structure, Array & String
				are tagged as Eval_Once too.

				You can also use EvalOnce to force an expression to be
				only evaluated the first time and then replaced by it's
				value. This should only be useful in UFOs where you wish
				to force the UFO parser to consider an expression as a
				constant child.

       EXAMPLE:	/*
				**	A function which adds 3 to it's argument the first
				**  time it is called and henceforth returns that value
				**
				**	Needless to say, this is not good programming practice
				*/

					Foo = Func( x )
						EvalOnce( x + 3 )

					@Foo( 5 ) == 8;
					@Foo( 10 ) == 8;

      FUNCTION: Exceptions

       SUMMARY: Enable/Disable hardware error trapping

         USAGE: Exceptions( [EnableFlag] )

       RETURNS: Exception state

   DESCRIPTION: Hardware errors are usually trapped by the operating system.
   				Some operating systems require user input to continue after
   				a hardware error.  The Exceptions function is used to enable
   				or disable this behavior.  

      FUNCTION: Exec

       SUMMARY: Evaluate a string or Slang expression

         USAGE:	Exec( Expression )

   DESCRIPTION:	The Exec function evaluates a String or Slang datatype.
   				Since Slang is an interpreter, expressions can be assembled
   				and evaluated at any time.  This code generation ability (or
   				self modifying code ability) has been used by many report
   				generating scripts.

				The Exec function evaluates at the local scope.

				We prefer the use of Func and @@ or @ methods of executing
				functions.  Code created with Func can be profiled, debugged
				and optimized while code that uses Exec cannot.

	  SEE ALSO: Function, Func, @, @@

	   EXAMPLE:	/*
	   			**	Build and execute expressions
	   			*/

					First Test = 10;
					Other Test = Pi;
					More Stuff = Volatility Curve( "DEM/USD" );

					Names = [ "First Test", "Other Test", "More Stuff" ];

					ForEach( Name, Names )
						Print( Name, " = ", Exec( Name ), "\n" );

      FUNCTION: Exist

       SUMMARY: Deprecated equivalent of NameUsed
       
      SEE ALSO: NameUsed

      FUNCTION: Exit

       SUMMARY: Immediatly exit from script

         USAGE: Exit( [ReturnValue] )

       RETURNS: ReturnValue.

   DESCRIPTION: Causes current slang evaluation to stop and return
   				ReturnValue.
   				
   				The SecExpr program can be made to return ReturnValue to
   				the operating system by using the '-l' flag.  This allows
   				communication between Slang scripts and command shell scripts.

      SEE ALSO: Abort, Return, TransactionAbort.

       EXAMPLE: /*
       			**	Stop entire script when error detected.
       			*/
       			
       			Set = Func( SecPtr, ValueName, Value )
       			{
       				if( !SetValue( ValueName, SecPtr, Value ))
       					Exit( 99 );
       			};

      FUNCTION: Exp

       SUMMARY: Arithmetic exponential

         USAGE:	Exp( Number )

       RETURNS: Exponential value of Number

   DESCRIPTION:	Return exponential value of Number.  This function only
   				operates on Doubles.

      SEE ALSO:	Log, Pow

      FUNCTION: FileCopy

       SUMMARY: Copy a file.

         USAGE:	FileCopy( SourceName, DestName )

       RETURNS: TRUE	- copied successfully
       			FALSE	- copy failed

   DESCRIPTION:	Copy the contents of the source file to the destination file.

	   EXAMPLE:	/*
	   			**	Copy the local config.sys file to config.bak
	   			*/
	   			
	   				FileCopy( "c:/config.sys", "c:/config.bak" );

      FUNCTION: FileCreate

       SUMMARY: Create a file.

         USAGE:	FileCreate( FileName )

       RETURNS: File - File datatype if file created without error
       			Null - Null datatype if file couldn't be created.

   DESCRIPTION:	Create a file.  If the file already exists the contents will
   				be truncated.  If FileCreate is successful, a File datatype
   				is returned.

				If the FileName argument is Null, a temporary file will be
				created automatically.

				FileWrite can be used to write data to the file.  Calling
				Destroy with the variable that contains the File will result
				in the closing (but certainly not destruction) of the file.

      SEE ALSO:	FileCopy, FileDelete, FileExists, FileOpen, FileReadBinary,
      			FileReadLine, FileWrite, Destroy, ChDir, MkDir, RmDir

      FUNCTION: FileDelete

       SUMMARY: Delete a file

         USAGE:	FileDelete( FileName )

       RETURNS: True  - File deleted without error
       			False - Error deleting file

   DESCRIPTION:	Delete a file.

      SEE ALSO:	FileExists, FileOpen, FileReadLine, FileWrite, Destroy, MkDir

      FUNCTION: FileExists

       SUMMARY: Determine if a file exists

         USAGE:	FileExists( FileName )

       RETURNS: True  - File exists
       			False - File doesn't exist

   DESCRIPTION:	The FileExists function returns True if the FileName already
   				exists, and False if it does not.

      SEE ALSO:	FileCreate, FileOpen

      FUNCTION: FileOpen

       SUMMARY: Open a file

         USAGE:	FileOpen( 
					FileName, 		// Name of file to open
					Flags )			// Optional mode and flags

       RETURNS: File datatype if file opened without error
       			Null if file couldn't be opened

   DESCRIPTION:	Open a file.  Once a file has been opened, FileReadLine can
   				be used to read lines from the file or if the file has
   				been opened in binaray mode, FileReadBinary can be used.
   				
   				Flags are one or more of the FILE_OPEN_FLAG constants:
   				
   					FILE_OPEN_READ			Open the file to read (default).
   					FILE_OPEN_WRITE			Open the file to write.
   					FILE_OPEN_BINARY		Open file in binary mode.
   					FILE_OPEN_APPEND		Start writing at current EOF.
   					FILE_OPEN_TRUNCATE		Truncate on write.
   					FILE_OPEN_DONT_CREATE	Only open if exists.
   					FILE_OPEN_MUST_CREATE	Fail if file exists.

      SEE ALSO:	FileCreate, FileReadLine, FileReadBinary, FileWrite, FileSeek,
      			FileTell, FileExists, Destroy

       EXAMPLE:	/*
       			**	Open the config.sys file and print the libpath lines
       			**	and append them to log file if the log already exists
       			*/
       			
       				If( File = FileOpen( "c:/config.sys" ))
       				{
       					LogFlags  = FILE_OPEN_WRITE + 
       								FILE_OPEN_APPEND + 
       								FILE_OPEN_DONT_CREATE;
       					Log = FileOpen( "d:/tmp/log", LogFlags );
       					
       					While( Line = FileReadLine( File ))
       					{
       						If( -1 != StrPos( Line, "libpath" ))
       						{
       							Print( Line, "\n" );
       							if( Log )
       								FileWrite( Log, Line, "\n" );
       						};
       					};
       				};

      FUNCTION: FileReadBinary

       SUMMARY: Read binary data from a file

         USAGE: FileReadBinary(
         			File,		// File to read from
         			Size)		// Number of bytes to read

       RETURNS: Binary datatype containing data read from the file.
       			Null if passed the end of file.

   DESCRIPTION: Read a binary block of data from a file.  The Size function
   				can be used on the returned binary datatype to determine the
   				number of bytes actually read.  The FileSeek function can be
   				used to move the file pointer within the file.

      SEE ALSO: File, FileOpen, FileReadLine, FileSeek, FileTell

       EXAMPLE: /*
       			**	Read and dump the first 1024 bytes from a file
       			*/

					fp = File( "c:/config.sys" );
					Print( FileReadBinary( fp, 1024 ));
					Destroy( fp );

      FUNCTION: FileReadLine

       SUMMARY: Read a line from a file

         USAGE:	FileReadLine( File )

       RETURNS: String	- Line from file
       			Null	- No more lines in the file

   DESCRIPTION:	Read a line from a file.  A line is considered to be
   				terminated by a carriage return ('/n').  The carriage
   				return is not included in the string.  If there are no
   				more lines in the file, Null is returned.

      SEE ALSO:	File, FileReadBinary, FileOpen, FileSeek, FileTell

      FUNCTION: FileSeek

       SUMMARY: Seek to a specific location within a file

         USAGE: FileSeek( File, Offset [,FromEnd] )

       RETURNS: True  - Location set without error.
       			False - Error setting location.

   DESCRIPTION: The FileSeek function moves the location of the next read
   				or write of a file.  FileTell can be used to determine the
   				current location of a file's pointer.  FileWrite, FileReadLine
   				and FileReadBinary move the file pointer.

      SEE ALSO: FileTell, File, FileOpen, FileReadLine, FileReadBinary,
      			FileWrite

       EXAMPLE: /*
       			**	Read the last 10 bytes from a file
       			*/

					fp = File( "c:/config.sys" );
					FileSeek( fp, -10, True );
					Print( FileReadBinary( fp, 10 ));
					Destroy( fp );

      FUNCTION: FileTell

       SUMMARY: Retrieve the position of a file pointer

         USAGE: FileTell( File )

       RETURNS: Current location of file pointer.

   DESCRIPTION: The FileTell function returns the current position of a
   				file's read/write pointer.  The FileSeek function can be
   				used to move this pointer.  FileReadLine, FileReadBinary
   				and FileWrite automatically move the file pointer to the
   				location immediatly following what was just read or written.
   				If the file is opened in append mode, the file pointer is
   				always moved to the end of the file before writing occurs.

      SEE ALSO: File, FileOpen, FileSeek, FileReadLine, FileReadBinary,
      			FileWrite

       EXAMPLE: /*
       			**	Open a file, read a line, and print the current location
       			*/

					fp = File( "c:/config.sys" );
					Line = FileReadLine( fp );
					Print( "Line: ", Line, "\n" );
					Print( "Location: ", FileTell( fp ), "\n" );
					Destroy( fp );

      FUNCTION: FileWrite

       SUMMARY: Write output to a file

         USAGE:	FileWrite( File, Expressions... )

       RETURNS: True  - Output written to file without error
       			False - Error writing to file

   DESCRIPTION:	Send output to a file.  The file must have been created using
   				the FileCreate function.  The FileWrite function is similar to
   				the Print function except that the output is sent directly to
   				a file.

				Each expression is evaluated, converted into a string and then
				written to the file.  Carriage returns ('\n') are not written
				automatically.

      SEE ALSO:	FileCreate, FileOpen, FileReadLine, FileExists, FileSeek,
      			FileTell

      FUNCTION: FillIn

       SUMMARY: String/Variable substitution

         USAGE:	FillIn( String )

       RETURNS: String with variables filled in

   DESCRIPTION:	The FillIn function substitutes variable names within a
   				string with the variables values.  A variable is identified
   				by bracketing percent signs.

      SEE ALSO:	Format, Left, Right, Center, String, Print, Printf, Sprint,
      			Sprintf

       EXAMPLE:	/*
				**	Print out a string with variables replaced
				*/
				
					Now		= CurrentTime();
					Name	= "Some Object's Name";

					Print( FillIn( "Printed %Now% for object %Name%\n" ));

      FUNCTION: Floor

       SUMMARY: Numeric rounding down

         USAGE:	Floor( Number )

       RETURNS: Smallest integer that is less than or equal to 'Number'

   DESCRIPTION:	Smallest integer that is less than or equal to 'Number'.
   				This function only operates on Doubles.

      SEE ALSO:	Ceil

      FUNCTION: For

       SUMMARY: Looped conditional expression execution

         USAGE:	For( InitExpression, CondExpression, ModExpression )
         		{
         			BLOCK;
         		};

       RETURNS: Last value analyzed within the block

   DESCRIPTION:	Executes BLOCK repeatedly.  First, the initialization
				InitExpression is evaluated.  Then, while the conditional
				expression CondExpression evaluates to a True value,
				BLOCK is executed and the loop expression ModExpression
				is evaluated.  When CondExpression becomes False,
				control passes to the statement following the For loop.

				The Break statement can be used to prematurely exit the
				loop.  The Continue statement can be used to prematurely
				jump to the top of the loop and bypass other instructions
				within the block.

      SEE ALSO:	While, Break, Continue, ForEach, ForEachParallel, ForComponent

       EXAMPLE:	/*
       			**	Print out all even numbers from 0 to 100
       			*/
       			
	       			For( Number = 0; Number <= 100; Number += 2 )
	       				Print( Number, "\n" );

      FUNCTION: ForChildren

       SUMMARY: Enumerate the children of a security

         USAGE:	ForChildren(
	         		Child,			// Variable to contain child structure
	         		ValueMethod,	// Value method to enumerate children of
	         		SecTypeFilter,	// Security type to filter for
	         		ValueFilter,	// Value type to filter for
	         		Flags)			// Enumeration flags
				{
         			BLOCK		// Block to execute
				};
         		
       RETURNS: Last value analyzed within the block

    PARAMETERS:	Child 		  - Structure that contains the child information.
							    The structure has the following elements:
									Name		- Name of the child
									Quantity	- Quantity of the child
									Value Type	- Value type used on the child

	   			ValueMethod   - Value method to enumerate the children of.
				   			    Examples of value methods are as follows:
				   					Dollar Price( "Book: B2" )
				   					Price( "Test Option" )

				SecTypeFilter - Security type to filter for.  This can be a
							    string such as 'Currency' or 'Currency Cross',
							    or can be NULL to disable filtering.

				ValueFilter   - Value type to filter for.  This can be a
							    string such as 'Price' or 'Volatility Curve',
							    or can be NULL to disable filtering.

				Flags		  - Enumeration flags added together.  If this
								argument is NULL, then the flags will default
								to TREE.
				
				
				The following enumeration flags are supported:
					_Below Set	- Descend below a set value when enumerating.
					_First Level- Enumerate only the immediate children.
					_Tree		- Descend down the tree and enumerate all of
								  the children.
					_Leaves Only- Enumerate only the bottom-most children
								  (children that don't have any children).
					_External	- Enumerate children that are flagged as
								  external.
					_Prune		-
					_Sorted		- Sort the returned values.


   DESCRIPTION: The ForChildren function is used to obtain the children of
   				a value method on a security.
   				
				The block is executed for each child found that matches the
				'SecTypeFilter', 'ValueFilter' and 'Flags'.

				The 'Child' argument should be the name of the variable that
				will be used by ForChildren to hold the children information.
				The variable will be created if it does not already exist.

				Unlike C, Slang functions always return something.  In the
				case of ForChildren, the return value is that of the last
				function executed within the block.  If the block is never
				executed, then NULL is returned.  In the example below
				the value that ForChildren returns will be NULL because the
				'Print' function always returns NULL.

				For more information consult the SecDb API manual, look under
				SecDbChildEnumFirst and SecDbChildEnumNext.

       EXAMPLE: /*
       			**  Print a list of all currency crosses and their current
       			**	spot rates
       			*/
       
					ForChildren(
							Child,
	       					Dollar Price( "Book: B2" ),
	       					"Currency Cross",
	       					"Price",
	       					Null )
       				{
       					Print( Right( Child.Name, 32 ),
       							"  ",
       							Format( Price( Child.Name ), 10, 4, _Commas ),
       							"\n" );
       				};

      FUNCTION: ForClass

       SUMMARY: Looped evaluation of a block through all object classes

         USAGE:	ForClass( ClassName )
         		{
         			BLOCK;
         		};

       RETURNS: Last value analyzed within the block

   DESCRIPTION:	The ForClass function evaluates a block for each class in
   				SecDb.  The class names are put into the argument 'ClassName'.
				The class names are not in alphabetical order.
   
      SEE ALSO:	For, ForSecurity

       EXAMPLE:	/*
   				**	Print out a list of classes
   				*/

   				ForClass( ClassName )
   					Print( ClassName, "\n" );

      FUNCTION: ForComponent

       SUMMARY: Looped evaluation of a block through all components
       			of an enumerable value

         USAGE:	ForComponent( Component, Structure )
         		{
         			BLOCK;
         		};

       RETURNS: Last value analyzed within the block

   DESCRIPTION:	The ForComponent function evaluates a block for each component
   				in an enumerable value.  The component names are put in the 
   				argument 'Component'.  (An optional third argument is a
   				deprecated usage which has no effect.)

      SEE ALSO:	For, ForEach, Structure

       EXAMPLE:	/*
				**	Print out the name of each component
				**	and its concomitant value
				*/

					ForComponent( Name, Struct )
						Print( Name, " = ", Struct[ Name ], "\n" );

      FUNCTION: ForEach

       SUMMARY: Looped evaluation of a block through each element of a value

         USAGE:	ForEach( [&]Element, EnumerableValue )
         		{
         			BLOCK;
         		};

       RETURNS: Last value analyzed within the block

   DESCRIPTION:	The ForEach function evaluates a block for each element in
				any enumerable value (e.g., array, structure, curve, string,
				etc. ).  The element value is copied into Element at the
				beginning of each iteration.

				When the '&' operator is used, Element is a reference
				variable into EnumerableValue so modifications made to
				Element also affect EnumerableValue.

      SEE ALSO:	For, ForComponent, ForEachParallel, Array

	   EXAMPLE:	/*
	   			**	Print the price of each object in the array
	   			*/
	   			
	   				Objects =
	   				[
	   					"DEM/USD",
	   					"JPY/USD",
	   					"CHF/USD",
	   					"ITL/USD"
	   				];

					ForEach( Object, Objects )
						Print( Object, "  ", Price( Object ), "\n" );

				/*
				**	Square all of the values in a curve
				*/

					Curve = Volatility Curve( "USD/DEM" );
					ForEach( &Knot, Curve )
						Knot.Value *= Knot.Value;

      FUNCTION: ForEachParallel

       SUMMARY: Parallel looped evaluation of a block through each element
       			of an array.

         USAGE:	ForEachParallel( Element, Array )
         		{
         			BLOCK;
         		};

       RETURNS: Array of results corresponding to each element in the array.

   DESCRIPTION:	The ForEachParallel function evaluates a block for each
   				element in an array.  The element value is copied into Element
   				at the beginning of each iteration.
   				
   				If the script is being evaluated on a multiprocessor box, the
   				block is evaluated in parallel with other blocks in the loop.
   				Depending on the number of processors and the operations being
   				performed in the block, the ForEachParallel function can be
   				substantially faster the ForEach function.

				If the script is evaluated on a single processor box, the
				ForEachParallel function will evaluate in the same amount of
				time as the ForEach function.

				ForEachParallel has some limitations that ForEach does not.

				ForEachParallel is not allowed to set or modify any variables
				outside of the block.  Within the block global or scoped
				variables can be read, but no written to.

				The block being evaluated must return a value that is put into
				the array returned by ForEachParallel.  The size of the memory
				used by the returned value shouldn't be more than what can be
				stored in an object in the database.

				Due to the way parallel processing works, it is a good idea
				to avoid requests from the database.  A request from the
				database requires each spawned process to connect to the
				database (obviously taking time.)  If the objects can be
				loaded before calling ForEachParallel, the function will
				operate more efficiently.

	   EXAMPLE:	/*
	   			**	Evaluate a bogus mathematical function in parallel
	   			*/

					TestValues = [
							100000, 200000, 300000, 400000, 500000,
							600000, 700000, 800000, 900000, 1000000 ];
							
					Results = ForEachParallel( Bound, Testvalues )
							{
								Result = 0;
								For( Count = 1; Count < Bound; Count++ )
									Result += Count;
								Return( Result );
							};
									
					Print( Results );

      FUNCTION: ForFile

       SUMMARY: Looped evaluation of a block through file names/info

         USAGE:	ForFile( Variable [,FileSpec [,Detail]] )
         		{
         			BLOCK;
         		};

       RETURNS: Last value analyzed within the block

   DESCRIPTION:	The ForFile function evaluates a block for each file that
   				matches the 'FileSpec'.  If 'FileSpec' is not specified,
   				"*.*" is used.
   				
   				If the 'Detail' argument isn't specified, the 'Variable'
   				will be set to file names.  If 'Detail' is specified,
   				then 'Variable' will be set to a structure with the following
   				components:
   				
   					Executable		- Is file executable
   					File Type		- Type of file, e.g., "Regular File"
   					Name			- Name of the file (without directory)
   					Readable		- Is file readable by current user
   					Size			- Size of the file
   					Time Accessed	- Time file was last accessed
   					Time Created	- Time file was created
   					Time Written	- Time file was last written
   					Writable		- Is file writable by current user

      SEE ALSO:	For

	   EXAMPLE:	/*
	   			**	Print a list of all files with a '.rpt' extension,
	   			**	and the times the files were created
	   			*/
	   			
	   				ForFile( File, "*.rpt", True )
						Print( File.Name, " ", File.Time Created, "\n" );

      FUNCTION: Format

       SUMMARY: Format a number into a string

         USAGE:	Format(
					Number,		// Number to format
	         		Width,		// Width of returned string
					Decimal,	// Number of digits after the decimal
					Flags)		// Formatting flags

       RETURNS: String with 'Number' formatted.

   DESCRIPTION:	The 'Flags' argument consists one or more of the following
				constants added together:
					_Blank Zero	     - Display nothing if number is zero.
					_Cipher		     - Single dash in the center if zero.
					_Commas		     - Add commas.
					_Concise	     - Trim leading and trailing spaces.
					_Pad Zeros	     - Add leading zeros.
					_Parens		     - Put parens around negative numbers.
					_Percent	     - Display as a percent (divide by 100).
					_Plus Sign	     - Add plus sign for positive numbers.
					_Scale		     - Autoscale the number and add a suffix
								       indicating the scale amount.
                    _Trim Leading    - Trim leading spaces.
					_Full Precision  - Display all significant digits.
								  
				When 'Scale' is in effect, the following suffixes are used:
				  	k - Thousand
				  	m - Million
					b - Billion

      SEE ALSO:	Print, Printf, Sprint, Sprintf, Center, Left, Right, To,
      			FillIn

       EXAMPLE:	/*
				**	Print a formatted number
				*/

					Number = -12345.678;
					Print( Format( Number, 20, 10, _Commas + _Parens ), "\n");

      FUNCTION: ForSecurity

       SUMMARY: Looped evaluation of a block through all object name of
       			a specific class (or all object names in the database)

         USAGE:	ForSecurity( SecName, SecType [,Start [,End]] )
				{
         			BLOCK		// Block to execute
				};

       RETURNS: Last value analyzed within the block

   DESCRIPTION: ForSecurity is used to obtain a list of all securities of
   				a specific type within the database.

				The block is evaluated for each object that is of the same
				class as the 'SecType' argument.  If 'SecType' is Null then
				there is no class filter.
				
				The optional 'Start' and 'End' arguments can be used to
				impose a range on the enumeration.  These arguments are
				inclusive.

       EXAMPLE: /*
       			**  Print a list of all currency crosses in the database
       			*/
       
					ForSecurity( Security Name, "Currency Cross" )
						Print( Security Name, "\n" );
						
      FUNCTION: ForSqlQuery

       SUMMARY: Looped evaluation through each row of an SQL query.

         USAGE:	ForSqlQuery( Variable, SqlConnection, Query )
         		{
         			BLOCK		// Block to execute
				};

       RETURNS: Last value analyzed within the block

   DESCRIPTION: The ForSqlQuery is used to iterate through each returned row
   				of an SQL query.  The Variable argument contains a structure
   				with the information about the row.  The structure tags
   				correspond to the SQL column names.

				WARNING: Due to the fact that Sybase locks tables against
						 writing when a read is in progress, this function
						 should be used with caution.  If the query is going
						 to take a long time or has the possiblility of
						 being paused or delay, the SqlQuery function should
						 be used instead.  If there is too much data for the
						 SqlQuery function, select into a temporary table,
						 and then use ForSqlQuery on the temporary table.

      SEE ALSO:	SqlConnect, SqlQuery

      FUNCTION: ForValue

       SUMMARY: Looped evaluate of a block through all value types supported
       			by a specific object (or all value types currently loaded)

         USAGE:	ForValue( Value, Object [,Detail] )
         		{
         			BLOCK;
         		};

   DESCRIPTION:	The ForValue function evaluates a block for each value type
   				supported by a specific object.  The value names are put in
   				the argument 'Value'.

				If the Detail argument is passed, then the Value variable will
				contain a structure instead of the value name.

				Structure components:
					Calculated	- True if valuetype is calculated
					External	- True if valuetype comes from external source
					Flags		- SDB_VALUE_FLAGS or'ed together
					Hidden		- True if valuetype is hidden
					InStream	- True if valuetype is in-stream
					Name		- Name of valuetype
					SetRetained	- True if valuetype is retained
					Static		- True if valuetype doesn't change
					Type		- Datatype of valuetype

				For a better description of valuetype flags, look at the
				SDB_VALUE_FLAGS section of the SecDb API manual.

      SEE ALSO:	For

       EXAMPLE: /*
       			**	Print all the values that an object supports
       			*/
       			
					Object = "DEM";

       				ForValue( Val, Object )
       					Print( Val, " = ", GetValue( Val, Object ), "\n" );


				/*
				**	Print out a list of values and their datatypes
				*/

					ForValue( Val, Object, True )
						Print( Val.Name, "    ", Val.Type, "\n" );

      FUNCTION: FromContinuous

       SUMMARY: Convert an interest rate, or an interest rate curve
       			from continuous to simple

         USAGE:	FromContinuous(
         			Rate,
         			Date,
         			Basis)

				FromContinuous(
					Curve,
					Basis)

       RETURNS: Individual rate if a rate is passed
       			Curve if a curve is passed

   DESCRIPTION:	Convert a continuous interest rate or interest rate curve
   				into a simple rate or simple rate curve.

				Basis is optional and should contain 360 or 365 depending
				upon the rate conversion method required.  If the Basis
				argument is not passed, it is assumed to be 360.

      SEE ALSO:	ToContinuous

      FUNCTION: Func

       SUMMARY: Define a Slang function

   DESCRIPTION:	Functions can be declared in Slang.  A function doesn't
   				really have a name, it is assigned to a variable.  In order
   				to call a function, the @ or @@ function must be used.

				A function can take arguments of any datatype, and return
				a value of any datatype.  When calling a function, the
				caller can pass as many arguments as necessary.  A function
				must handle undefined arguments itself (the Defined function
				is usally used for this purpose).

				Unlike in C, Slang provides no prototyping.  A function must
				be declared before it can be called.

				The @ function calls the function at a new level of variable
				scope.  This means that variables that are used within the
				function are destroyed upon return.
				
				The @@ function calls the function at the same level of
				variable scope.  This means that any variables that are
				accessible to the caller are accessible to the function.
				Variables are not destroyed upon exit (this includes any
				arguments passed to the function).

				Unlike in C, Slang allows the caller to decide if a variable
				is being passed by reference or passed by value.  If a
				variable is prefaced by an ampersand ('&') it is passed
				by reference.  Passing large arrays and structures by
				reference is much faster that passing them by value.

      SEE ALSO:	@, @@, Function, Exec

	   EXAMPLE: /*****************************************************
				**	Routine: Add
				**	Returns: x + y
				**	Action : Add two values together
				*****************************************************/

				Add = Func( x, y )
				{
					return( x + y );
				};


				/*
				**	Test the function
				*/

				Print(	@Add(  5,  4 ),			"\n",
						@Add( 10, 25 ),			"\n",
						@Add( "Test", "This" ),	"\n" );

      FUNCTION: Function

       SUMMARY: Parse expression string into Slang datatype

         USAGE:	Function( String )

       RETURNS: Slang datatype

   DESCRIPTION:	The Function function parses a string into a Slang datatype.
   				The Slang datatype can be evaluated using the Exec function.

				We prefer the use of Func and @@ or @ methods of executing
				functions.  Code created with Func can be profiled, debugged
				and optimized while code that uses Exec cannot.

      SEE ALSO:	Exec, Func

      FUNCTION: GetByInference

       SUMMARY: Get or create a security by inferring it's existence

         USAGE: GetByInference(
         			Security,		// Object created by NewSecurity
         			CreateFlag)		// True to create if object can't be found

       RETURNS: A Security datatype if object was found or created
				Null if object couldn't be found or created

   DESCRIPTION: Before GetByInference can be called, the Security argument
				should be created using the NewSecurity function.  The
				in-stream values of this object should be set using the
				SetValue function.

				GetByInference will try to get the object from the database
				that matches the Security argument's values.  If the object
				cannot be found in the database, GetByInference will try to
				create, name and add a new object to the database.

				GetByInference uses the InferredName name function to
				determine the name of the object to either load or create.
				The GetByInference function is not usefull for classes that
				do not support an inferred name.

      SEE ALSO: GetSecurity, NewSecurity, SetValue, InferredName

      FUNCTION: GetEnv

       SUMMARY: Get the value of an environment variable

         USAGE:	GetEnv(
	         		EnvVarName)		// Name of environment variable

       RETURNS: String which holds the environment vars value
				Null if environment variable not found

   DESCRIPTION:	Get the value of an environment variable.  If the environment
   				variable has not been declared, Null is returned.  For more
   				information look at the getenv C library function.

      SEE ALSO:	PutEnv

       EXAMPLE:	/*
       			**	Print the path environment variable
       			*/

					Print( GetEnv( "PATH" ), "\n" );

      FUNCTION: GetHostByAddress

       SUMMARY: Get information about a host given its tcp/ip address

         USAGE:	GetHostByAddress(
	         		TcpIpAddressString)		// Address of host of interest,
	         								// e.g., "148.86.195.196"

       RETURNS: Structure with the following components:
       
       				Address			Array of tcp/ip addresses for host
       				Address Type	
       				Aliases			Array of alias names for host
       				Name			Full host name
       
				Null is returned if host is unknown.

      SEE ALSO:	GetHostByName, HostName

       EXAMPLE:	/*
       			**	Print the host information
       			*/

					Print( GetHostByAddress( "148.86.195.196" ), "\n" );

      FUNCTION: GetHostByName

       SUMMARY: Get information about a host given its name

         USAGE:	GetHostByName(
	         		HostName)			// Name of host of interest

       RETURNS: Structure with the following components:
       
       				Address			Array of tcp/ip addresses for host
       				Address Type	
       				Aliases			Array of alias names for host
       				Name			Full host name
       
				Null is returned if host is unknown.

      SEE ALSO:	GetHostByAddress, HostName

       EXAMPLE:	/*
       			**	Print the host information
       			*/

					Print( GetHostByName( "lundek" ), "\n" );

      FUNCTION: GetSecurity

       SUMMARY: Get a security from the database

         USAGE:	GetSecurity(
	         		SecName,	// Name of security to get from the database
	         		Flags )		// Optional SDB_GET_FLAGS

       RETURNS: Security datatype if successful
       			Null datatype if security couldn't be loaded

   DESCRIPTION: Securities within SecDb (and hence Slang) are not considered
   				to be 'loaded' unless there is at least one pending reference
   				to the security.  Even though SecDb maintains a deadpool of
   				recently accessed securities, the securities in the deadpool
   				cannot be diddled, have values set or be updated.

				GetSecurity is necessary when trying to set values and update
				securities, because it makes sure that a security is being
				referenced.
				
				The Flags argument controls how the object is found and
				loaded:
				
					SDB_CACHE_ONLY		Fail if not already loaded.
					SDB_REFRESH_CACHE	Get from database even if 
										already loaded.
					SDB_IGNORE_PATH		Only get from parent database.
										Do not get from any databases
										in the search path.  Can be
										combined with SDB_CACHE_ONLY
										or SDB_REFRESH_CACHE since there
										is a separate cache for each
										database in the search path.

				In the example below, the 'Test Option' security is gotten
				from the database, the strike price of the option is modified
				and the security is then updated in the database.  The
				destroy function does not destroy or delete 'Test Option',
				what it does is to destroy the 'Option' variable thus freeing
				the reference to the 'Test Option' security.

	  SEE ALSO: NewSecurity, DeleteSecurity, RenameSecurity, UpdateSecurity,
	  			SetValue, GetSecurityFromSyncPoint, SecDbGetByName

       EXAMPLE:	/*
       			**	Get the 'Test Option' from the database and update
       			**	it's strike price
       			*/

					Option = GetSecurity( "Test Option" );
					If( Option )
					{
						SetValue( Strike( Option ), 35 );
						UpdateSecurity( Option );
						Destroy( Option );
					}
					:
						Print( LastError());

      FUNCTION: GetSecurityFromSyncPoint

       SUMMARY: Get a security from a previous time

         USAGE:	GetSecurityFromSyncPoint(
	         		SecName,			// Name of security to get
	         		SyncPointOffset)	// Number of syncpoints to look back

       RETURNS: Security datatype if successful
       			Null datatype if security couldn't be loaded

   DESCRIPTION: The GetSecurityFromSyncPoint function is used to retrieve a
   				previous version of a security.  A syncpoint is a copy of the
   				database made at some point in the past.  Syncpoints are
   				written on a regular basis.  Syncpoints are very useful when
   				restoring deleted or modified objects.

				If an object can be retrieved from a syncpoint, the object
				read from the syncpoint will automatically be renamed to a
				unique name within the database.  This allows for the current
				version and the syncpoint version of an object to exist 
				simultaneously in memory.

      SEE ALSO: GetSecurity, SecDbGetFromSyncPoint

      FUNCTION: GetUniqueID

       SUMMARY: Get a unique number

         USAGE: GetUniqueID()

       RETURNS: Unique number

   DESCRIPTION: A unique number.  The number is guaranteed unique for a
       			database.

      SEE ALSO: SecDbUniqueID

      FUNCTION: GetValue

       SUMMARY: Get a value from an object

         USAGE:	GetValue(
         			Value Type,
         			Object,
         			Default Value)

       RETURNS: Value from the object
       			Default Value or Null if value not supported

   DESCRIPTION:	The most common way to get a value from an object in Slang
   				is through the following syntax example:
   				
   					Dollar Price( "Test Option" );

				The GetValue function provides an alternate method to the
				one above:

					GetValue( "Dollar Price", "Test Option" );

				The GetValue function is provided as a convenience for such
				tasks as: getting a table of values from an object, getting
				a default value if an object doesn't support the value type,
				etc...

      SEE ALSO:	SetValue, SetDiddle

      FUNCTION: Global

       SUMMARY: Access a global variable

         USAGE:	Global( Variable )

       RETURNS: Value of global variable (if rvalue)

   DESCRIPTION:	There are two types of variable scope within Slang - local
   				and global.  Global scope is the outermost level of a script,
   				local scope is within a function.  As functions are called,
   				variable scope is nested.

				For a function to access the global scope, the DoGlobal and
				Global functions are provided.  The Global function allows
				a global variable to be gotten (rvalue) or set (lvalue).

				THE GLOBAL FUNCTION IS OBSOLETE, THE :: OPERATOR SHOULD BE
				USED INSTEAD.

      SEE ALSO:	DoGlobal, Func, Scope, Scopes, ::

      FUNCTION: HeapInfo

       SUMMARY: Info about allocated memory

         USAGE:	HeapInfo()

       RETURNS: Structure containing information about the heap

   DESCRIPTION:	The HeapInfo function returns a structure that contains
   				information about memory usage.

				Components in returned structure:

					Nodes	- Number of pieces of memory allocated
					Unused	- Amount of memory allocated and currently unused
					Used	- Amount of memory currently in use

      SEE ALSO:	HeapUsed

      FUNCTION: HeapUsed

       SUMMARY: Amount of memory allocated

         USAGE:	HeapUsed()

       RETURNS: Number of bytes allocated

   DESCRIPTION:	Check the validity of the heap, and return the total number
   				of memory allocated.  If the heap is damaged, a number less
   				than or equal to zero will be returned.

      SEE ALSO:	HeapInfo

      FUNCTION: HighLimit

       SUMMARY: Highest value of a datatype

         USAGE:	HighLimit( DataType )

       RETURNS: Highest value of a DataType

   DESCRIPTION:	The HighLimit function returns the highest possible value
   				for a specific datatype.  The HighLimit and LowLimit functions
   				can be very useful when working Index Pos datatypes to set
   				initial values.

      SEE ALSO:	LowLimit

	   EXAMPLE: /*
	   			**	Find the lowest number in an array
	   			*/

					Low Number = HighLimit( "Double" );
					ForEach( Element, Array )
						Low Number = Min( Low Number, Element );
					Print( Low Number, "\n" );

      FUNCTION: HostName

       SUMMARY: Get name of current host

         USAGE:	HostName()

       RETURNS: Name of current host.

      SEE ALSO:	GetHostByAddress, GetHostByName

       EXAMPLE:	/*
       			**	Print the current host name
       			*/

					Print( HostName(), "\n" );

      FUNCTION: If

       SUMMARY: Conditional expression execution

         USAGE:	If(	ConditionExpression )
         			TrueExpression
         		:
         			FalseExpression;

				If( ConditionExpression )
					TrueExpression;

				If( ConditionExpression )
					TrueExpression
				: If( AnotherCondition )
					AnotherTrueExpression
				:
					FalseExpression;

       RETURNS: Value of evaluated expression

   DESCRIPTION:	The If function evaluates the ConditionExpression.  If the
   				result is logically True, the TrueExpression is evaluated.
   				If the result of the ConditionExpression is logically False
   				and there is a FalseExpression, the FalseExpression is
   				evaluated, else Null is returned.

      SEE ALSO:	For, While, Switch

       EXAMPLE:	/*
       			**	Perform an operation if a variable has been defined
       			*/

					If( Defined( Var ))
						Print( "Variable 'Var' = ", Var, "\n" )
					:
						Print( "'Var' is not defined\n" );

      FUNCTION: Include

       SUMMARY: Insert and evaluate the contents of another script

         USAGE:	Include( ScriptName )

       RETURNS: Result of script evaluation

   DESCRIPTION:	Include and evaluate the contents of another script.  This
   				function is used to link in functions and constants from
   				other scripts.  Since Slang is an interpreted language, the
   				script that is included will be immediately parsed and
   				evaluated.
   				
   				The Include function is evaluated at run time while the
   				Link function happens at parse time.  Link is the prefered
   				function.

      SEE ALSO:	Link, Func, Function, Eval, @, @@

      FUNCTION: IndexGet

       SUMMARY: Retrieve data from an index

         USAGE:	IndexGet( IndexPos, GetMethod )

       RETURNS: Name of object matching get operation

   DESCRIPTION:	The IndexGet function retrieves information from an index
   				on the database.  The IndexPos is a cursor into the database
   				that was created with the NewIndexPos function.  The following
   				methods can be used for placing the cursor:
					_Equal		- lookup Equal	
					_First		- lookup First
					_Ge			- lookup Greater than or equal to
					_Greater	- lookup Greater
					_Last		- lookup Last
					_Le			- lookup Less than or equal to
					_Less		- lookup Less
					_Next		- lookup Next
					_Prev		- lookup Prev

      SEE ALSO:	NewIndexPos, IndexInfo, IndexNames

	   EXAMPLE: /*
	   			**	Print positions expiring in the next year
	   			*/

					Start Date	= Current Date( "Security Database" );
					End Date	= Start Date + 365;

				    Index = "Positions by Expiration Date";

    				Index Pos = NewIndexPos( Index );
    				Index Pos.Expiration Date = Start Date;

    				Limit Pos = NewIndexPos( Index );
    				Limit Pos.Expiration Date = End Date;

    				For( Pos Name = IndexGet( Index Pos, _Ge );
                				Pos Name && Index Pos <= Limit Pos;
                				Pos Name = IndexGet( Index Pos, _Next ))
    				{
        				Print(	Left( 32, Pos Name ),				" ",
        						Left( 32, Index Pos.Book Name ),	" ",
        						Index Pos.Expiration Date,			" ",
        						Index Pos.Quantity,					"\n" );
    				};

      FUNCTION: IndexInfo

       SUMMARY: Get information about an index.

         USAGE:	IndexInfo( IndexName )

       RETURNS: Structure containing index information (if found.)
       			Null if index couldn't be found.

   DESCRIPTION:	The IndexInfo function returns a structure with the following
   				components:
   				
   					Classes		- Array of classes (security types) that
   							 	  the index applies to.
   					Name		- Name of the index.
   					Parts		- Array of part structures (detailed below.)


   				Part structures have the following components:

   					ByteWidth	- Width of the field.
   					Flags		- Numeric/Non-numeric, Ascending/Descending.
   					ValueType	- Value type.

      SEE ALSO:	NewIndexPos, IndexGet, IndexNames

       EXAMPLE:	/*
				**	Print the format of the 'Trades by Time' index
				*/

					Print( IndexInfo( "Trades by Time" ));

      FUNCTION: IndexNames

       SUMMARY: Get a list of supported indices.

         USAGE:	IndexNames()

       RETURNS: Array of index names.

   DESCRIPTION:	The IndexNames function returns an array of index names.
   				The IndexInfo function can be used to display the structure
   				of an individual index.

      SEE ALSO:	IndexInfo, IndexGet

       EXAMPLE:	/*
       			**	Print detail on each index
       			*/
       			
       				Indices = IndexNames();
       				ForEach( Index, Indices )
       					Print( IndexInfo( Index ), "\n" );

      FUNCTION: InferredName

       SUMMARY: Get inferred name of an object

         USAGE:	InferredName( Object )

       RETURNS: Name that Object thinks it should be called

   DESCRIPTION:	The InferredName function asks the Object for a name that
   				the Object would like to be called.

      SEE ALSO:	NewSecurity, RenameSecurity, UpdateSecurity

      FUNCTION: Interpolate

       SUMMARY: Interpolate a point on a curve

         USAGE:	Interpolate(
	         		Curve,		// Curve to interpolate point from
	         		Date,		// Date to interpolate on
	         		Method)		// Interpolation method to use (optional)

       RETURNS: Interpolated point

   DESCRIPTION: The Interpolate function always returns the knot value
				if 'Date' refers to a date in the curve.  The 'Method'
				parameter determines how to calculate values between dates
				or outside the date range of the curve.

				Below are the different methods allowed by this function:
					_Extrapolate
						Linear interpolate if the 'Date' argument is within
						the date range of the curve.  If the 'Date' argument
						is not found within the curve, then the value returned
						is an extrapolation of the first two or last two knots.
						This differs from _Interpolate Flat in that the
						slope of the curve outside of the curve limits can be
						non-zero.

					_Interpolate Only
						Linear interpolate if the 'Date' argument is within
						the date range of the curve.  If the 'Date' argument
						is not found within the curve then the constant
						_Error is returned.

					_Interpolate Flat
						Linear interpolate if the 'Date' argument is within
						the date range of the curve.  If the 'date' argument
						is not found within the curve then the value of the
						first knot or of the last knot is returned.

						This is the default method if no 'Method' parameter
						is supplied.  This method and 'Curve[ Date ]' act in
						exactly the same manner.

					_Interpolate Step
						If the 'Date' argument is within the curve, then the
						value of the knot who's date is directly less than or
						equal to the 'Date' argument is returned.  If the
						'date' argument is not found within the curve then the
						value of the first knot or of the last knot is
						returned.

					_Interpolate Prestep
						Similar to _Interpolate Step, except that the value
						of the knot who's date is greater than or equal to the
						'Date' argument is returned.  Again, if the 'Date'
						argument is not found within the curve then the value
						of the first knot or of the last knot is returned.

					_Knots Only
						If the 'date' argument doesn't exactly match one of
						the knots in the curve, then HUGE_VAL is returned,
						otherwise the value of the knot is returned.

      SEE ALSO:	Curve, CurveMerge

       EXAMPLE:	/*
       			**	Print out a years worth of values starting today
				**
				**	Curve[ Date ] can be substituted for the first
				**	interpolate function below.
       			*/

					Curve = Interest Rate Curve( "USD" );
					Today = Current Date( "Security Database" );

					One Year = Today + 365;		// Could use AddDate instead
					For( Date = Today; Date < One Year; Date++ )
						Print( Date, "  ", Interpolate( Curve, Date ), "\n" );


					Curve = Futures Strip( "Commod NG" );
					Today = Current Date( "Security Database" );

					One Year = Today + 365;
					For( Date = Today; Date < One Year; Date++ )
						Print( Date, "  ",
							Interpolate( Curve, Date, _Interpolate Prestep ),
							"\n" );

      FUNCTION: LastError

       SUMMARY: Get the text of the last error encountered

         USAGE:	LastError()

       RETURNS: Last error in string form.

   DESCRIPTION:	The LastError function can be used to obtain error information
   				after some functions fail.  The LastError

      SEE ALSO:	LastErrorNumber, ErrorMessage, ErrorReturn, ErrorMore, Err,
      			ErrMore, ErrorLogOpen

       EXAMPLE:	/*
       			**	Get the 'Test Option' from the database, if the security
       			**	couldn't be loaded, display the error message
       			*/

					If( !GetSecurity( "Test Option" ))
						Print( LastError());

      FUNCTION: LastErrorNumber

       SUMMARY: Get the error number of the last error encountered

         USAGE:	LastErrorNumber()

       RETURNS: Last error number.

   DESCRIPTION:	The LastErrorNumber function can be used to determine the
   				type of error last encountered.  The value returned can be
   				compared against the _ERR_* constants to determine the
   				nature of the failure.

      SEE ALSO:	LastError, ErrorMessage, ErrorReturn, ErrorMore, Err,
      			ErrMore, ErrorLogOpen

      FUNCTION: Left

       SUMMARY: Create a string where the input is left justified

         USAGE:	Left(
	         		Width,	// Width of returned string
					Data)	// Data to left justify

       RETURNS: String with 'Data' left justified within

   DESCRIPTION:	Left justify 'Data' converted into a string.

      SEE ALSO:	Center, Right, Format, Print

       EXAMPLE:	/*
       			**	Output sample
       			*/

					Print(	Left( 20, "Left Justify" ),  	"\n",
							Right( 20, "Right Justify" ),	"\n",
							Center( 20, "Center Justify" ),	"\n" );

      FUNCTION: Link

       SUMMARY: Link in the contents of another script at parse time.

         USAGE:	Link( ScriptName )

   DESCRIPTION:	The Link function is used to include the contents of another
   				script.  Unlike the Include function which is evaluated at
   				run time, the Link function is evaluated at parse time.  This
   				means that the included script is already parsed, and treated
   				as if it is part of the including script.  Each time the
   				Include function is encountered a script had to be parsed,
   				with the Link function parsing occurs only once.

      SEE ALSO:	Include, Func, Function, Eval, @, @@

      FUNCTION: Log

       SUMMARY: Natural logarithm

         USAGE:	Log( Number )

       RETURNS: Natural logarithm of Number.

   DESCRIPTION:	Return natural logarithm of Number.  This function only
   				operates on Doubles.

      SEE ALSO:	Log10, Exp, Pow

      FUNCTION: Log10

       SUMMARY: Logarithm base 10

         USAGE:	Log10( Number )

       RETURNS: Logarithm base 10 of Number.

   DESCRIPTION:	Return logarithm base 10 of Number.  This function only
   				operates on Doubles.

      SEE ALSO:	Log, Exp, Pow

      FUNCTION: LowLimit

       SUMMARY: Lowest value of a datatype

         USAGE:	LowLimit( DataType )

       RETURNS: Lowest value of a datatype

   DESCRIPTION:	The LowLimit function returns the lowest possible value
   				for a specific datatype.  The HighLimit and LowLimit functions
   				can be very useful when working Index Pos datatypes to set
   				initial values.

      SEE ALSO:	HighLimit

	   EXAMPLE: /*
	   			**	Find the highest number in an array
	   			*/

					High Number = LowLimit( "Double" );
					ForEach( Element, Array )
						High Number = Max( High Number, Element );
					Print( High Number, "\n" );

      FUNCTION: Max

       SUMMARY: Return highest value of all arguments

         USAGE:	Max(
         			Expression 1,
         			Expression 2,
         			...,
					Expression N)

       RETURNS: The highest value of all the arguments

   DESCRIPTION:	The Max function compares all the values of the arguments
   				and returns the highest value.  This function works with
   				all datatypes that support greater-than/less-than operators.

      SEE ALSO:	Min, Or

      FUNCTION: Message

       SUMMARY: Display a message

         USAGE:	Message( Text )

       RETURNS: Null

   DESCRIPTION:	Display a temporary message.  A message will be displayed
   				until another message overwrites the current message.
   				If Text is Null, then any existing message is removed.

				Each Slang evaluator (SecView, SecExpr, etc...) provides
				their own message display function.  Many different forms of
				Slang evaluators can be created because certain functions to
				were made implementation specific (e.g. Message, Print,
				Debug, etc... )

      SEE ALSO:	MessageOccasional, ErrorMessage, Print, Printf, Sprint

       EXAMPLE:	/*
       			**	Run through the database displaying a progress
       			**	message every hundred objects
       			*/
       			
				Count = 0;
       			ForSecurity( SecName, Null )
       			{
					If( !Mod( Count, 100 ))
						Message( FillIn( "%Count%: %SecName%" ));
					Count++;
				};

      FUNCTION: MessageOccasional

       SUMMARY: Display a message occasionally

         USAGE:	MessageOccasional( 
         			Text, 			// Message text
         			[Interval] )	// Minimum seconds between messages

       RETURNS: Null

   DESCRIPTION:	Display a temporary message.  A message will be displayed
   				until another message overwrites the current message.
   				If Text is Null, then any existing message is removed.

				Each Slang evaluator (SecView, SecExpr, etc...) provides
				their own message display function.  Many different forms of
				Slang evaluators can be created because certain functions to
				were made implementation specific (e.g. Message, Print,
				Debug, etc... )
				
				If the last call (anywhere) to MessageOccasional was less
				than Interval seconds, no action is taken (and Text is not
				even evaluated).  The default value for Interval is one
				second.

      SEE ALSO:	Message, ErrorMessage, Print, Printf, Sprint

       EXAMPLE:	/*
       			**	Run through the database displaying a progress
       			**	message every two seconds.
       			*/
       			
       			ForSecurity( SecName, Null )
					MessageOccasional( SPrint( "Processing: ", SecName ), 2 );

      FUNCTION: Min

       SUMMARY: Return lowest value of all arguments

         USAGE:	Min(
         			Expression 1,
         			Expression 2,
         			...,
					Expression N)

       RETURNS: The lowest value of all the arguments

   DESCRIPTION:	The Min function compares all the values of the arguments
   				and returns the lowest value.  This function works with
   				all datatypes that support greater-than/less-than operators.

      SEE ALSO:	Max, Or

      FUNCTION: MkDir

       SUMMARY: Create a directory

         USAGE:	MkDir( Directory )

       RETURNS: True  - Directory created (or already exists)
       			False - Directory couldn't be created

   DESCRIPTION:	The MkDir function creates a new directory with the
   				specified Directory name.

      SEE ALSO:	ChDir, RmDir

      FUNCTION: Mod

       SUMMARY: Calculate the floating point remainder

         USAGE:	Mod( x, y )

       RETURNS: The floating point remainder, or 0 if y is 0

   DESCRIPTION:	The Mod function calculates the floating-point remainder f
   				of x / y such that x = i * y + f, where i is an
   				integer, f has the same sign as x, and the absolute value
   				of f is less than the absolute value of y.

				The Mod function only operates on Doubles.

				This function calls the fmod C library function.

      SEE ALSO:	Ceil, Floor, Abs, Sign

      FUNCTION: NameLookup

       SUMMARY: Lookup a security name in a database using search criteria

         USAGE: NameLookup( SecName, SecType, GetType )

       RETURNS: Name of object found
       			Null if object name not found

   DESCRIPTION: The NameLookup function is used to find object names in the
   				database.  The 'SecName' argument is used as the base for
   				the search criteria.
   				
   				If 'SecType' is Null, then all classes are looked at.

				The following GetTypes are supported:

					_Equal		- lookup Equal	
					_First		- lookup First
					_Ge			- lookup Greater than or equal to
					_Greater	- lookup Greater
					_Last		- lookup Last
					_Le			- lookup Less than or equal to
					_Less		- lookup Less
					_Next		- lookup Next
					_Prev		- lookup Prev

      SEE ALSO: ForSecurity, Exist, IndexGet, NameUsed

       EXAMPLE: /*
       			**	Print out entire list of currencies in reverse order
       			*/

					For( Name = NameLookup( "", "Currency", _Last );
						 Name;
						 Name = NameLookup( Name, "Currency", _Less ))
					{
						Print( Name, "\n" );
					};

      FUNCTION: NameUsed

       SUMMARY: See if a security name is used in the database or in memory

         USAGE:	NameUsed( 
         			SecName,		// Name for which to check
         			Flags )			// Optional SDB_IGNORE_PATH flag

       RETURNS: True  - Security exists
       			False - Security does not exist

   DESCRIPTION:	Same as NameLookup( SecName, NULL, _Equal ) 
   				except that all securities that have been
   				created in memory, e.g., with NewSecurity, but not yet
   				written to the database are also checked.
   				Also, all databases in the search path, if one
   				exists, are	checked, again both in memory and
   				in database unless SDB_IGNORE_PATH is set.

      SEE ALSO: ForSecurity, IndexGet, NameLookup, NewSecurity

      FUNCTION: New

       SUMMARY: Create a new instance of a specific datatype

         USAGE:	New(
					DataType)		// Datatype to create

       RETURNS: Value of type 'DataType'

   DESCRIPTION:	The New function is used to create a specific datatype.

				Even though variables within Slang don't have to be
   				explicitly defined, datatypes such as Array and Structure
   				cannot be implicitly created without using the New function.

				An assignment of one variable to another will make the
				variable that is being assigned to have the same data and
				datatype of the variable (or expression) being assigned.

	  SEE ALSO: Destroy

       EXAMPLE:	/*
       			**	Create a structure and set some of the components
				**	The 'Variable = New( "Structure" )' call could also
				**	be implemented as 'Variable = Structure()' (which would
				**	be preferred)
       			*/

       				Variable = New( "Structure" );
       				Variable.Company		= "Goldman, Sachs & Co.";
       				Variable.Address		= "85 Broad Street";
       				Variable.Building Floor	= 5;
       				Variable.Entry Time		= CurrentTime();


				/*
				**	Create an array and set some of the elements.
				**	The size of the 'Variable' will be 8 (elements 0-7)
				**	and the elements that have not been assigned to (1,2,3,4
				**	and 6) will be set to NULL.
				*/
				
					Variable = New( "Array" );	// or Array(), or []
					Variable[ 0 ]		= "Lowest element";
					Variable[ 5 ]		= 5;
					Variable[ 7 ]		= Volatility Curve( "DEM/USD" );

      FUNCTION: NewIndexPos

       SUMMARY: Create a new index position

         USAGE:	NewIndexPos( IndexName )

       RETURNS: An index position (Index Pos) for IndexName
       			Null - IndexName not valid

   DESCRIPTION:	NewIndexPos is used to create a new Index Pos datatype.
   				An Index Pos is a cursor into an index in the database.

				Index Pos datatypes function in many ways like structures.
				To reference field data within an Index Pos, the '.' component
				operator is used.  Components within an Index Pos can be
				accessed and assigned to in the same way as structures.

				The components within an Index Pos are determined by the
				index being used.  The only component that is guaranteed to
				exist in any Index Pos is 'SecName'.

      SEE ALSO:	IndexGet

	   EXAMPLE:	See example for IndexGet

      FUNCTION: NewSecurity

       SUMMARY: Create a new security

         USAGE:	NewSecurity(
					SecType, 	// Type of security to create
	         		SecName) 	// Name of the new security

       RETURNS: Security datatype if successful
       			Null datatype if security couldn't be created

   DESCRIPTION:	NewSecurity is used to create a new security.

   				The 'SecType' argument specifies the type of security to
   				create, trying to create a new security will fail if the
   				security type doesn't exists.

				The 'SecName' argument specifies the name of the new security.
				The name must be unique within a database, NewSecurity will
				fail if the name already exists.  If 'SecName' is a Null, then
				the name of the security is automatically generated by SecDb.
				The general format for these names is 'Security #' where the
				'#' will be a unique numeric value.

				Security names can be changed by using 'RenameSecurity'.

	  SEE ALSO: GetSecurity, DeleteSecurity, RenameSecurity, UpdateSecurity,
	  			SetDiddle, SetValue, SecDbGetByName

       EXAMPLE:	/*
       			**	Create a new option security
       			*/

					Option = NewSecurity( "Option", Null );
					If( Option )
					{
						Today = Current Date( "Security Database" );

						SetValue( Option Style( Option ),		"European" );
						SetValue( Option Type( Option ),		"Call" );
						SetValue( Denominated( Option ),		"DEM" );
						SetValue( Quantity Unit( Option ),		"USD" );
						SetValue( Strike( Option ),				35 );
						SetValue( Expiration Date( Option ),	Today + 7 );

						UpdateSecurity( Option );
						Destroy( Option );
					}
					:
						Print( LastError());

      FUNCTION: Or

       SUMMARY: Return value of first True argument

         USAGE:	Or(
         			Expression 1,
         			Expression 2,
         			...,
					Expression N)

       RETURNS: Value of first expression that evaluates to True

   DESCRIPTION:	The Or function starts evaluation at the first argument
   				and continues evaluating the rest of the arguments until a
   				logically True value is obtained.
   				
				This function and the compare operator (<=>) are provided
				mainly to make sort comparisons faster.

      SEE ALSO:	Sort, Min, Max

	   EXAMPLE:	/*
	   			**	Compare elements of one structure with another
	   			*/

					Compare = Or(
							SortArg1.Name  <=> SortArg2.Name,
							SortArg1.Date  <=> SortArg2.Date,
							SortArg1.Quant <=> SortArg2.Quant );

					If( Compare < 0 )
						Print( "Arg1 is less that Arg2\n" )
					: If( Compare > 0 )
						Print( "Arg1 is greater than Arg2\n" )
					:
						Print( "Arg1 is equal to Arg2\n" );

      FUNCTION: OutputBufferBrowse

       SUMMARY: Allow user to browse though the output buffer.

         USAGE:	OutputBufferBrowse()

       RETURNS: True  - Function supported in context
       			False - Function not supported in context

   DESCRIPTION:	The OutputBuffer functions are context specific.  This means
   				that each evaluator (program that runs slang scripts) can
   				behave differently.  At the time this manual was written,
   				only TAP and SecView support any of the OutputBuffer
   				functions.  For the sake of simplicity, only the behavior of
   				TAP will be described.

				The OutputBufferBrowse function lets a script allow a user
				to view (scroll through) the current output window.  When
				the user hits Escape, the script continues evaluation.

      SEE ALSO:	OutputBufferNew, OutputBufferOld, OutputBufferSave

      FUNCTION: OutputBufferNew

       SUMMARY: Clean out the contents of the output buffer.

         USAGE:	OutputBufferNew( Title )

       RETURNS: True  - Function supported in context
       			False - Function not supported in context

   DESCRIPTION:	The OutputBuffer functions are context specific.  This means
   				that each evaluator (program that runs slang scripts) can
   				behave differently.  At the time this manual was written,
   				only TAP and SecView support any of the OutputBuffer
   				functions.  For the sake of simplicity, only the behavior of
   				TAP will be described.

				The OutputBufferNew function erases the current output buffer.

				The Title argument is used to set the title of the window,
				and is used when saving the output buffer (the title is
				retained.)

      SEE ALSO:	OutputBufferBrowse, OutputBufferOld, OutputBufferSave

      FUNCTION: OutputBufferOld

       SUMMARY: Allow user to select and view and old saved output buffer.

         USAGE:	OutputBufferOld()

       RETURNS: True  - Function supported in context
       			False - Function not supported in context

   DESCRIPTION:	The OutputBuffer functions are context specific.  This means
   				that each evaluator (program that runs slang scripts) can
   				behave differently.  At the time this manual was written,
   				only TAP and SecView support any of the OutputBuffer
   				functions.  For the sake of simplicity, only the behavior of
   				TAP will be described.

				The OutputBufferOld function displays a list of saved output
				buffers and allows the user to pick one for viewing.

      SEE ALSO:	OutputBufferBrowse, OutputBufferNew, OutputBufferSave

      FUNCTION: OutputBufferSave

       SUMMARY: Save the contents of the current output buffer.

         USAGE:	OutputBufferSave()

       RETURNS: True  - Function supported, and evaluated correctly
       			False - Function not supported in context

   DESCRIPTION:	The OutputBuffer functions are context specific.  This means
   				that each evaluator (program that runs slang scripts) can
   				behave differently.  At the time this manual was written,
   				only TAP and SecView support any of the OutputBuffer
   				functions.  For the sake of simplicity, only the behavior of
   				TAP will be described.

				OutputBufferSave saves the contents of the current output
				buffer.  The Title of the output buffer (set with
				OutputBufferNew) is also saved with the report.

				The OutputBufferOld function can be used to view old reports.

      SEE ALSO:	OutputBufferBrowse, OutputBufferNew, OutputBufferOld

      FUNCTION: PageAt

       SUMMARY: Put text into a Page datatype

         USAGE:	PageAt(
         			Page,
         			x,
         			y,
         			Expressions...)

       RETURNS: Null

   DESCRIPTION:	The PageAt function puts text into a Page datatype.  The x, y
   				arguments indicate the starting location within the Page.
   				Each expression is evaluated, converted into a string and
   				written to the Page.

				The PageAt function wraps carriage returns in an intelligent
				manner.  The x argument is viewed as the left margin if there
				are embedded carriage returns in the expressions.

      SEE ALSO:	PageBox, Page, StrWidth, StrHeight, Sheet

	   EXAMPLE:	/*
	   			**	Print list of objects in a columnated format
	   			*/

					MaxColumns	= 4;
					MaxRows		= 60;
					ColWidth	= 20;

					Row = Column = 0;
					Page = Page();
					PageBox( Page, 0, 0,
							MaxColumns * ColWidth + 2,
							MaxRows + 2 );
					ForSecurity( SecName, "Currency Cross" )
					{
						PageAt( Page, 1 + Column * ColWidth, 1+Row, SecName );
						If( Row++ >= MaxRows )
						{
							Row = 0;
							If( ++Column >= MaxColumns )
							{
								Print( Page );
								Row = Column = 0;
								Page = Page();
								PageBox( Page, 0, 0,
										MaxColumns * ColWidth + 2,
										MaxRows + 2 );
							};
						};
					};
					Print( Page );

      FUNCTION: PageBox

       SUMMARY: Draw a box for a Page datatype

         USAGE:	PageBox(
         			Page,
         			Xlow, Ylow,
         			Xhigh, Yhigh,
         			Width)

       RETURNS: Null

   DESCRIPTION:	The PageBox function draw lines and boxes on a Page datatype.

				The Xlow, Ylow and Xhigh, Yhigh arguments contain the corners
				of the box.  If Xlow and Xhigh are the same, a vertical line
				is drawn.  If Ylow and Yhigh are the same, a horizontal line
				is drawn.

   				The Width argument is optional and is 1 for a single line and
   				2 for a double line.

				The PageBox fucntion automatically determines the values for
				intersections between two boxes or lines.

      SEE ALSO:	PageAt, Page, Sheet

	   EXAMPLE:	See example for PageAt function

      FUNCTION: PlayNote

       SUMMARY: Play musical notes

         USAGE:	PlayNote( Note, Tempo )

       RETURNS: Null

   DESCRIPTION:	The PlayNote function is used to play bad square-wave music.

				A note is formed by adding octaves, notes, sharp/flat,
				duration, and duration modifiers together.  The definitions
				of these constants can be found in the 'Music Definitions'
				script.
				
				Notes can be transposed by adding or subtracting the number
				of notes to shift by.

	   EXAMPLE:	/*
	   			**	Play a little tune
	   			*/

					Include( "Music Definitions" );

					Tune =
					[
    					M_NOTE_C + 0         ,
    					M_NOTE_C + 0         ,
    					M_NOTE_D + 0         ,
    					M_NOTE_B + M_QUARTER + M_EIGHTH    ,
    					M_NOTE_C + M_EIGHTH  ,
    					M_NOTE_D     ,
    					M_NOTE_E + 0         ,
    					M_NOTE_E + 0         ,
    					M_NOTE_F + 0         ,
    					M_NOTE_E + M_QUARTER + M_EIGHTH    ,
    					M_NOTE_D + M_EIGHTH  ,
    					M_NOTE_C     ,
    					M_NOTE_D + 0         ,
    					M_NOTE_C + 0         ,
    					M_NOTE_B + 0         ,
    					M_NOTE_C + M_HALF
					];

					Tempo = 30;
					ForEach( Note, Tune )
					{
    					Note += M_OCTAVE_3;
    					PlayNote( Note + M_LEGATO, Tempo );
					};

      FUNCTION: Point3d

       SUMMARY: Set a point within a Chart3d datatype

         USAGE:	Point3d( Chart, x, y [,z] )

       RETURNS: Null if 'z' argument supplied.
       			Value at x, y within Chart if 'z' argument is omitted.

   DESCRIPTION:	The Point3d function is used to set or get the value of a
   				point in a chart3d datatype.  A chart3d datatype has a
   				rectangular grid of points originating at 0, 0.

      SEE ALSO:	Chart3d, Draw3d

	   EXAMPLE:	/*
	   			**	Create a chart and set a grid of points
	   			**	A more complete example can be found in the '3D Demo'
	   			**	script.
	   			*/

					Chart = Chart3d();
					For( y = 0; y < 10; y++ )
						For( x = 0; x < 10; x++ )
							Point3d( Chart, x, y, x * y );
					Draw3d( Chart );

      FUNCTION: Pow

       SUMMARY: Compute Number1 raised to the power of Number2

         USAGE:	Pow( Number1, Number2 )

       RETURNS: Number1 raised to the power of Number2

   DESCRIPTION:	Compute Number1 raised to the power of Number2

      SEE ALSO:	Log, Exp

      FUNCTION: Print

       SUMMARY: Print to the current output device/file

         USAGE:	Print( Args... )

       RETURNS: Always returns Null

   DESCRIPTION:	The Print function takes any number of arguments of any
   				type (they can be mixed).  The arguments are converted into
   				strings.  Since the datatypes of the arguments are known, the
   				format of these strings are determined by the datatype.  The
   				strings are concatenated and then sent to the output device
   				or file.

				The application program determines the output device.

				The Format function is very useful for formatting numbers in
				a pleasant manner.  The Center, Left and Right functions can
				be used to justify the output.

      SEE ALSO:	Format, Center, Left, Right, To, Printf, Sprint, Sprintf,
      			FillIn

       EXAMPLE:	/*
				**	Test the Print function
				*/

					Number = -12345.678;

					Print( Format( Number, 20, 10, _Commas + _Parens ), "\n");
					Print( "Number = ", Number, "\n" );
					Print( Interest Rate Curve( "DEM" ));

      FUNCTION: Printf

       SUMMARY: Formatted conversion of data to current output device/file.

         USAGE:	Printf( Format, ... )

       RETURNS: Null

   DESCRIPTION:	The Printf function is similar the the C printf function.
				Printf takes a format string followed by additional arguments
				to be formatted by the format string.

				For formatting options please refer to the Sprintf function.

      SEE ALSO:	Print, Sprintf, Sprint, FillIn, Right, Left, Center, Format

      FUNCTION: PutEnv

       SUMMARY: Set an environment variable

         USAGE:	PutEnv( EnvString )

       RETURNS: True  - Environment variable set without error
       			False - Error setting environment variable

   DESCRIPTION:	The PutEnv function adds new environment variables or
   				modifies the values of existing environment variables.

				The format for EnvString is:

					varname=string

				Where <varname> is the name of the environment variable
				to be added or modified, and <string> is the variable's
				value.  If <varname> is already part of the environment,
				it is replaced by <string>; otherwise, the new string is
				added to the environment.  A variable can be set to an
				empty value by specifying an empty string.

				This function affects only the environment that is local
				to the currently running process; it cannot be used to enter
				new items in the command-level environment.  When the
				currently running process terminates, the affects of PutEnv
				are removed.

      SEE ALSO:	GetEnv, System

      FUNCTION: Random

       SUMMARY: Generate a random number

         USAGE:	Random( [Seed] )

       RETURNS: Random number between 0 and 1

   DESCRIPTION:	The Random function generates a random number between 0 and 1.
   				The Seed argument is optional, and should only be used once
   				within a script.  If the Seed argument is given, then the
   				random number generator is reinitialized.  If the same Seed
   				number is given to the Random function each time a script
   				is run, the same series of random numbers will be generated.

      SEE ALSO:	RandomGauss

	   EXAMPLE: /*
	   			**	Test the random number generator
	   			*/

					Buckets = [];
					For( Test = 0; Test < 10000; Test++ )
						Buckets[ Random() * 100 ]++;

					For( Bucket = 0; Bucket < Size( Buckets ); Bucket++ )
						Print(	Right( 4, Bucket ), " ",
								Right( 8, Buckets[ Bucket ] ), "\n" );

      FUNCTION: RandomGauss

       SUMMARY: Generate a gaussian distributed random number

         USAGE:	RandomGauss( [Seed] )

       RETURNS: Gaussian distributed random number

   DESCRIPTION: RandomGauss returns a gaussian distributed random number from
   				negative infinity to infinity with a standard deviation of 1.

      SEE ALSO:	Random

      FUNCTION: RCurveToCurve

       SUMMARY: Convert a relative-date curve into a date curve.

         USAGE:	RCurveToCurve(
         			Curve,			// Curve to convert
         			BaseDate,  		// Base date to reference from
         			[Currency1]		// Optional currency for holidays
         			[Currency2])	// Optional currency for holidays

   DESCRIPTION:	The RCurveToCurve function is provided as a method of
   				converting from curves containing relative dates to curves
   				containing fixed dates.  The typical slang nomenclature of
   				RCurve( Curve(...)) is not supported because of the need to
   				supply a BaseDate and optional holidays.

      SEE ALSO:	RCurve, Curve, RDate, Date

      FUNCTION: RDateAdd

       SUMMARY: Add a date and a relative date together

         USAGE: RDateAdd(
         			RDate,			// Relative date
         			Date,			// Date to use as base
         			[Currency1],	// Optional holiday currency code
         			[Currency2])	// Optional holiday currency code

       RETURNS: Date

   DESCRIPTION: The RDateAdd function is used to add a relative amount of
   				time to a date.  The relative date must have been created
   				using the RDate datatype creator.

				The Currency1 and Currency2 parameters if passed indicate
				which holiday tables to use.  If these parameters are not
				passed or they are null, no holiday schedule is used.

      SEE ALSO: RDate, Date, AddDate

       EXAMPLE: /*
       			**	Print the date that is one month from pricing date
       			*/

					OneMonth = RDate( "1m" );
					Print( RDateAdd( OneMonth, PricingDate ), "\n" );

      FUNCTION: RegMatch

       SUMMARY: Regular expression matching

         USAGE: RegMatch(
         			RegEx,		// Regular expression to match
         			String)		// String to test for match

       RETURNS: Array of matching groups if successful
       			Null if couldn't match, or error

   DESCRIPTION: Regular expressions are used to match, extract & substitute
   				string expressions.  Regular expressions are extremely useful
   				when parsing and searching strings.

				The regular expression (RegEx) must first be created using
				the RegEx datatype creator.  A string containing the
				regular expression must be passed to the creator.

				If a match is found by RegMatch, the result of the match
				is returned in an array.  All of the array elements are
				strings.  The 0th element of the array will contain the
				entire string which matched.  Subsequent elements will contain
				the results of group matches.  A group match is defined as
				anything within parenthesis.

      SEE ALSO: RegEx, RegSub, Regular expression guide such as Perl or Grep

       EXAMPLE: /*
       			**	Run through all security names looking for any
       			**	security that has a date in January in its name.
       			**	If a match occurs, m[ 0 ] will contain the whole
       			**	matching string and m[ 1 ] will contain just the
       			**	date.
       			*/

					a = RegEx( "^.*([ 1-3][0-9]Jan[0-9][0-9])" );
					ForSecurity( Sec, Null )
					    if( m = RegMatch( a, Sec ))
					        Print( m );

      FUNCTION: RegSub

       SUMMARY: Regular expression matching & substitution

         USAGE: RegSub(
         			RegEx,		// Regular expression to match
         			Source,		// Source string to try to match
         			Template)	// Template used to format the result

       RETURNS: String containing substituted result if successful
       			Null if couldn't match, or error

   DESCRIPTION: Regular expressions are used to match, extract & substitute
   				string expressions.  Regular expressions are extremely useful
   				when parsing and searching strings.

				The regular expression (RegEx) must first be created using
				the RegEx datatype creator.  A string containing the
				regular expression must be passed to the creator.

				If a match is found by RegSub, the Template parameter is used
				to format the output.  Within the Template everything is taken
				literally except for backslash-number combinations.  The
				backslash-number combinations correspond to matched groups,
				and are substituted.


      SEE ALSO: RegEx, RegSub, Regular expression guide such as Perl or Grep

       EXAMPLE: /*
       			**	Example regular expression substitution
				*/

					a = RegEx( "It's a (girl|boy)!" );

					Print( RegSub( a, "It's a girl!", $$They had a \1$ ));

      FUNCTION: ReloadSecurity

       SUMMARY: Reload a specific object, or all objects

         USAGE:	ReloadSecurity( Object )

       RETURNS: Always 1

   DESCRIPTION:	If Object is Null, all of the objects that are currently
   				loaded are refreshed from the database.  Objects that are
   				unreferenced (in the deadpool) are flushed from memory.
   				
   				If Object is a Security, or the name of a security, then
   				that object is refreshed from the database.

      SEE ALSO:	GetSecurity, UpdateSecurity

      FUNCTION: RemoteDelete

       SUMMARY: Delete an object from a remote database.

         USAGE:	RemoteDelete( DbName, SecName )

       RETURNS: True  - Object deleted without error
       			False - Object not found or couldn't be deleted

   DESCRIPTION:	The RemoteDelete function is used to delete an object in a
   				database that is different than the primary database.

      SEE ALSO:	Delete, RemoteDiskInfo, RemoteGetCopy, RemotePutCopy,
      			DatabaseInfo

       EXAMPLE: /*
       			**	Delete an object from a remote database
				*/

					RemoteDelete( "NYC Test", "Untitled-1" );

      FUNCTION: RemoteDiskInfo

       SUMMARY: Retrieve object disk information from a remote database.

         USAGE:	RemoteDiskInfo( DbName, SecName )

       RETURNS: Structure containing disk information.
       			Null if object couldn't be found.

   DESCRIPTION: Retrieve information about an object in a remote database.

				Components in returned structure:

					DbCreated	- Name of database where object was created
					DbUpdated	- Name of database where object was updated
					Name		- Name of object
					TimeCreated	- Time object was created
					TimeUpdated	- Time object was last modified
					Type		- Object's class name
					UpdateCount	- Number of times object has been updated
					Version		- Version number of object

      SEE ALSO:	DiskInfo, RemoteDelete, RemoteGetCopy, RemotePutCopy

       EXAMPLE:	/*
       			**	Print the disk information from an object in a remote
       			**	database
       			*/

					Print( RemoteDiskInfo( "NYC Test", "Untitled-1" ));

      FUNCTION: RemoteGetCopy

       SUMMARY: Copy an object into current database from a remote database.

         USAGE:	RemoteGetCopy( DbName, SecName )

       RETURNS: True  - Copied without error.
       			False - Object not found, or couldn't be copied.

   DESCRIPTION: The RemoteGetCopy function copies an object from a remote
   				database into the current database.

      SEE ALSO:	RemotePutCopy, RemoteDiskInfo

       EXAMPLE:	/*
       			**	Copy an object from a remote database
       			*/

					RemoteGetCopy( "NYC Test", "Untitled-1" );

      FUNCTION: RemotePutCopy

       SUMMARY: Copy an object into a remote database from the current
       			database.

         USAGE:	RemotePutCopy( DbName, SecName )

       RETURNS: True  - Copied without error.
       			False - Object not found, or couldn't be copied.

   DESCRIPTION: The RemotePutCopy function copies an object from the current
   				database to a remote database.

      SEE ALSO:	RemoteGetCopy, RemoteDiskInfo

       EXAMPLE:	/*
       			**	Copy an object to a remote database
       			*/

					RemoteGetCopy( "NYC Test", "Untitled-1" );

      FUNCTION: RemoveFromDeadPool

       SUMMARY: Remove an object from the deadpool

         USAGE:	RemoveFromDeadPool( 
         			Object,		// Name of object to discard (or NULL)
         			Flags )		// Optional SDB_IGNORE_PATH flag

       RETURNS: True  - Object removed from deadpool without error
       			False - Object wasn't in deadpool, or is currently referenced

   DESCRIPTION:	Remove an unreferenced object, or all unreferenced objects
   				from the deadpool.  If the database has a search path
   				the reference(s) will be removed from each database
   				in the search path unless SDB_IGNORE_PATH is set.
   				
				Object can be either a String or Null.  If Object is set
				to Null the entire deadpool is flushed.  If the database
				has a search path, the object (or all objects) are flushed
				from any deadpool in the path unless the SDB_IGNORE_PATH
				flag is set.

   				The deadpool in SecDb is a caching mechanism that allows
   				unreferenced objects to stay around for a period of time to
   				increase speed.  For more information about the deadpool
   				look in the SecDb API manual.

      SEE ALSO:	GetSecurity, Destroy

      FUNCTION: RenameSecurity

       SUMMARY: Change the name of a security

         USAGE:	RenameSecurity(
	         		Security,	// Security or name of security to rename
	         		NewName) 	// New name for the security

       RETURNS: True  - The object was renamed
       			False - There was a problem

   DESCRIPTION:	RenameSecurity is used to change the name of a security.

   				The 'Security' argument can either be a security that
   				was loaded using 'GetSecurity' or it can be the name of
   				a security.

				The 'NewName' argument can either be a string that contains
				the new name for the security, or NULL if the security class
				is supposed to determine the name.

	  SEE ALSO: NewSecurity, GetSecurity, DeleteSecurity, UpdateSecurity,
	  			SetValue, SecDbRename

       EXAMPLE:	/*
       			**	Create a new option security, and let the option
       			**	security class determine it's name
       			*/

					Option = NewSecurity( "Option", Null );
					If( Option )
					{
						Today = Current Date( "Security Database" );

						SetValue( Option Style( Option ),		"European" );
						SetValue( Option Type( Option ),		"Call" );
						SetValue( Denominated( Option ),		"DEM" );
						SetValue( Quantity Unit( Option ),		"USD" );
						SetValue( Strike( Option ),				35 );
						SetValue( Expiration Date( Option ),	Today + 7 );

						// Let the option security class pick a name
						if( !RenameSecurity( Option, Null ))
							Print( LastError());
						else						
							UpdateSecurity( Option );
					}
					:
						Print( LastError());

      FUNCTION: Restore

       SUMMARY: Remove diddles within scope

         USAGE:	Restore( ValueMethod )

       RETURNS: True  - Diddles removed
       			False - Couldn't restore diddles

   DESCRIPTION:	A diddle is a temporary override of an object's value.

				The Restore function removes diddles on a specific value
   				method.  Diddles that are set from within an Eval block are
   				automatically removed when the block is exited.

				A diddle in Slang is done using the following syntax:
				
					Value( Object ) = DiddledValue;

				Other assignment operators can be used (+=, -=, *=, /=).
				A diddle on the same value, on the same object, at the same
				level of scope overrides the previous diddle.

				If ValueMethod is Null, all diddles on all objects at the
				current level of diddle scope are removed.

      SEE ALSO:	Eval

      FUNCTION: Return

       SUMMARY: Flow control - Return from a function

         USAGE:	Return( Expression )

   DESCRIPTION:	Terminates execution of the function in which it appears
				and returns control (and the value of Expression if given)
				to the calling function.

      SEE ALSO:	Func

       EXAMPLE: See example for Func

      FUNCTION: Right

       SUMMARY: Create a string where the input is right justified

         USAGE:	Right(
	         		Width,	// Width of returned string
					Data)	// Data to right justify

       RETURNS: String with 'Data' right justified within

   DESCRIPTION:	Right justify 'Data' converted into a string.

      SEE ALSO:	Center, Left, Format, Print

       EXAMPLE:	/*
       			**	Output sample
       			*/

					Print(	Right( 20, "Right Justify" ),  	"\n",
							Right( 20, "Right Justify" ),	"\n",
							Center( 20, "Center Justify" ),	"\n" );

      FUNCTION: RmDir

       SUMMARY: Remove a directory

         USAGE:	RmDir( DirectoryName )

       RETURNS: True  - Directory removed without error
       			False - Directory not found, or couldn't be removed

   DESCRIPTION:	Remove a directory.  Only empty directories can be removed.

      SEE ALSO:	MkDir, ChDir

      FUNCTION: Round

       SUMMARY: Round a number to a specified number of decimal places.

         USAGE:	Round( Number [,Decimals] )

       RETURNS: Rounded number
       			
   DESCRIPTION:	The Round function rounds a number to a specified number of
   				decimal places.  If the Decimals argument is omitted, the
   				number will be rounded to an integer.

      SEE ALSO:	RoundSignificant, Floor, Ceil

      FUNCTION: RoundSignificant

       SUMMARY: Round a number to a specified number of significant digits.

         USAGE:	RoundSignificant( Number, Precision )

       RETURNS: Rounded number
       			
   DESCRIPTION:	The RoundSignificant function rounds a number to a specified
   				number of digits of precision.

      SEE ALSO:	Round, Floor, Ceil

      FUNCTION: Scope

       SUMMARY: Access a variable from a named scope

         USAGE:	Scope( ScopeName, VarName )

       RETURNS: Reference to variable within scope.
       			
   DESCRIPTION:	The :: operator is used to conveniently reference variables
   				from within a scope.  The Scope function differs from the ::
   				operator in that the VarName argument is actually a variable
   				itself, while :: takes only constant string expressions.

				The usage of the :: operator and Scope function is as follows:
				
					Global::Foo = 10;
					Print( Scope( "Global", "Foo" ), "\n" );
					NewScope::Var1 = CurrentTime();
					Scope( "NewScope", "Var2" ) = CurrentGMTime();

      SEE ALSO:	Scopes, ScopeSetSticky, ::

      FUNCTION: Scopes

       SUMMARY: Get an array of scope names.

         USAGE:	Scopes()

       RETURNS: Array of scope names.
       			
   DESCRIPTION:	By default, Slang supports a Global scope, a local scope and
   				a sticky scope.  In addition to the default scopes, scripts
   				can create their own scopes.  The Scopes function provides a
   				list of these scopes (not including the local scope.)

				The Scope function and :: operator can be used to explicitly
				reference a variable within a scope.

      SEE ALSO:	Scope, ScopeSetSticky, ::

       EXAMPLE: /*
       			**	Print the list of scopes
       			*/
       			
       				Print( Scopes());

      FUNCTION: ScopeSetSticky

       SUMMARY: Set a named scope to be sticky (not destroyed upon exit)

         USAGE:	ScopeSetSticky( ScopeName, StickyValue )

       RETURNS: Null
       			
   DESCRIPTION:	When a scope is set to sticky, it will not be automatically
   				cleared when the evaluator goes away.  This allows values to
   				be stored and referenced whenever the evaluator is active.
				By default a new scope is not sticky.
				
				If the ScopeName doesn't exist, the scope will be created.

      SEE ALSO:	Scope, Scopes, ::

      FUNCTION: SecType

       SUMMARY: Get the security type (the class)

         USAGE:	SecType(
	         		Object)		// Security or security name

       RETURNS: Type of security in string form

   DESCRIPTION:	The SecType function returns a string which contains the
   				class name that the Object belongs to.  The complete list
   				of classes can be obtained from the ForClass function.

      SEE ALSO:	DiskInfo, ForClass

       EXAMPLE:	/*
       			**	Display the name and type of each object
       			**	in the database
       			*/

					ForSecurity( Name, Null )
						Print( Left( 32, Name ), " ", SecType( Name ), "\n" );

      FUNCTION: SetDiddle

       SUMMARY: Diddle a value of a security

         USAGE:	SetDiddle(
	         		ValueMethodName,// Value method to diddle
	         		Security,		// Security to act on
    	     		Value)			// Actual value to diddle value method to

       RETURNS: TRUE

   DESCRIPTION:	The SetDiddle function is used to diddle values within a 
   				security.  The function is provided as an alternative to 
   				the usual diddle syntax in Slang.  The following are
   				equivalent:
   				
   					Dollar Price( "DMV1" ) = 100000000;
   					
   					SetDiddle( "Dollar Price", "DMV1", 100000000 );
   					
   				The SetDiddle function is useful when the value method name
   				is determined programatically.  Both ways of setting diddles
   				have the same scope and are removed by the Restore function
   				or the end of an enclosing Eval block.

	  SEE ALSO: Eval, Restore, SetValue, Value Methods and Diddles,
	  			SecDbSetDiddle

      FUNCTION: SetValue

       SUMMARY: Set a value of a security

         USAGE:	SetValue(
	         		ValueMethod,	// Value method to set the value of
    	     		Value)			// Actual value to set value method to
    	     		
    	     	or
    	     	
    	     	SetValue(
    	     		ValueMethodName,// Name of value
    	     		Security,		// Security to act on
    	     		Value)			// Actual value to set value method to

       RETURNS: TRUE if the value was set
       			FALSE if there was a problem

   DESCRIPTION:	The SetValue function is used to set values within a security.
				The security should first be loaded or created by using the
				'GetSecurity' or 'NewSecurity' functions.

	  SEE ALSO: NewSecurity, GetSecurity, UpdateSecurity,
	  			SecDbSetValue

       EXAMPLE:	/*
       			**	Get the 'Test Option' from the database and update
       			**	it's strike price
       			*/

					Option = GetSecurity( "Test Option" );
					If( Option )
					{
						SetValue( Strike( Option ), 35 );
						UpdateSecurity( Option );
						Destroy( Option );
					}
					:
						Print( LastError());

      FUNCTION: SheetBox

       SUMMARY: Draw a box around a group of cells in a sheet

         USAGE: SheetBox(
					Sheet,			// Spreadsheet to use
 					Column1,   		// Starting column of range
 					Row1,			// Starting row of range
 					Column2,   		// Ending column of range
 					Row2)			// Ending row of range

       RETURNS: Null

   DESCRIPTION: Draw a box around a group of cells in a sheet.

      SEE ALSO: Sheet, SheetAttr, SheetAttrRange

      FUNCTION: SheetColumnWidth

       SUMMARY: Set the width of a column of cells in a sheet

         USAGE: SheetColumnWidth(
					Sheet,			// Spreadsheet to use
 					Column,   		// Column number
 					Width)			// Width of column

       RETURNS: Null

   DESCRIPTION: The SheetColumnWidth function sets the width of a column
   				in a sheet.  The Width parameter is treated as 10ths of
   				an inch when the output is done as postscript, and as
   				characters when the sheet is converted into a string.

				The default column width is 10 (1 inch.)

      SEE ALSO: Sheet, SheetPostscript

      FUNCTION: SheetPostscript

       SUMMARY: Output a sheet in postscript format

         USAGE: SheetPostscript(
					Sheet,			// Spreadsheet to use
         			Orientation,	// "Landscape" ...
					OutputFile,		// Output file
					AppendFlag)		// True to append

       RETURNS: Null

   DESCRIPTION: The SheetPostsript functions converts a sheet datatype into
   				postscript, and then outputs the results to a printer or a
   				file.

				Orientation can be one of the following values:
					"Landscape"		- Page is horizontally oriented.
					"Portrait"		- Page is vertically oriented.
					"EPS Landscape"	- Encapsulated postscript horizontal.
					"EPS Portrait"	- Encapsulated postscript vertical.
				
				Orientation defaults to "Portrait" if not supplied.

				If OutputFile isn't supplied, the output will be sent to
				the printer using the 'ps' utility.

      SEE ALSO: Sheet

      FUNCTION: ShowFKeys

       SUMMARY: Display function key table

         USAGE:	ShowFKeys( FKeyArray )
         		{
         			BLOCK;
         		};

       RETURNS: Null

   DESCRIPTION:	The ShowFKeys function is used to display a function key
   				map.  The function keys are visible only when the block is
   				being evaluated.  The block is only evaluated once.
   				
   				The FKeyArray argument should contain an array of arrays.
   				Each sub-array should contain up to 4 elements, where the
   				first element contains the key, the second contains the first
   				line's description, the third contains the second line's
   				description and the fourth is the enabled/disabled state.

				Calls to the ShowFKeys function can be nested.  If FKeyArray
				is Null, no function keys are displayed.

	   EXAMPLE:	/*
	   			**	Display function keys and take input
	   			*/

					FKeys = [
							[ "F1 ",	"  Show",	"   Window",	True ],
							[ "F2 ",	"  Hide",	"   Window",	True ],
							[ "F3 ",	" Print",	" Contents",	True ],
							[],
							[],
							[],
							[],
							[ "ESC",	" Abort",	"         ",	True ]
							];

					ShowFKeys( FKeys )
					{
						while( WK_ESC != (Key = W_GetKey()))
						{
							// Key processing goes here
						};
					};

      FUNCTION: ShowSecurity

       SUMMARY: Display an object in a dialog

         USAGE:	ShowSecurity( Object )

       RETURNS: Null

   DESCRIPTION:	The ShowSecurity function displays a window of information
   				about the Object specfied.  This function calls the
   				SecViewShowSecurity function, which is the screen you get
   				when running SecView and selecting a security with the ENTER
   				key.

      SEE ALSO:	EditSecurity

      FUNCTION: Sign

       SUMMARY: Numeric sign of a value -1,0,1

         USAGE:	Sign( Number )

       RETURNS: Numeric sign of Number

   DESCRIPTION:	Numeric sign of Number:
       				-1 if Number < 0
       				 0 if Number == 0
       				 1 if Number > 0

				This function only operates on Doubles.

      SEE ALSO:	<=>, Abs

      FUNCTION: Sin

       SUMMARY: Arithmetic sine

         USAGE:	Sin( Number )

       RETURNS: Sine of the Number specified

   DESCRIPTION:	Trigonometric function to return the sine of a number.
   				'Number' is expressed in radians.  This function only
   				operates on Doubles.

      SEE ALSO:	Cos, Tan

      FUNCTION: Size

       SUMMARY: Determine the size of an argument

         USAGE:	Size( Arg )

       RETURNS: A number which is the size of the argument.

   DESCRIPTION:	When Size is used on strings it returns the number
   				of characters in the string (strlen), when used on curves
   				it returns the number of knots in the curve.

				Each datatype supports the Size function in their own way.
   				Read the section on datatypes to determine what Size will
   				return for each of the datatypes.

      SEE ALSO: Datatypes

       EXAMPLE:	/*
				**	Print the sizes of various types of data
				*/

					Curve = Interest Rate Curve( "DEM" );
					Print( "Number of knots = ", Size( Curve ), "\n" );

					Array =
					[
						"Lowest element",
						5,
						Volatility Curve( "DEM/USD" )
					];
					Print( "Number of elements = ", Size( Array ), "\n" );

					Struct = Structure();
       				Struct.Company			= "Goldman, Sachs & Co.";
       				Struct.Address			= "85 Broad Street";
       				Struct.Building Floor	= 5;
       				Struct.Entry Time		= CurrentTime();
       				Print( "Number of components = ", Size( Struct ), "\n" );

					String = "This is a test string";
					Print( "String length = ", Size( String ), "\n" );

      FUNCTION: Sleep

       SUMMARY: Delay for a specified time interval

         USAGE:	Sleep( Seconds )

       RETURNS: Null

   DESCRIPTION:	The Sleep function allows a program to pause for a given
   				amount of time.  The Seconds argument can contain fractional
   				number of seconds to pause.

	   EXAMPLE: /*
	   			**	Demonstrate Sleep function
	   			*/

					Print( "Wait for 3.5 seconds..." );
					Sleep( 3.5 );
					Print( "Done\n" );

      FUNCTION: SocketAccept

       SUMMARY: Accept a new tcp/ip connection

         USAGE:	SocketAccept( 
         			Socket )		// Socket being listened to

       RETURNS: New socket

   DESCRIPTION:	SocketAccept is the last step in establishing a connection
   				between two processes (typically on two different hosts).
   				The server creates a master socket with SocketListen, then
   				the client calls SocketConnect, then the server accepts the
   				client with SocketAccept.  The new socket is now available
   				for reading and writing.
   				
   				SocketAccept blocks while waiting for a client to apply
   				for a connection.  To avoid blocking, the server can
   				first call SocketPollInput on the master socket to see
   				if any clients are waiting for an accept.

      SEE ALSO:	SocketListen, SocketConnect, SocketPollInput,
      			SocketReadBinary, SocketReadLine, SocketReadResult, 
      			SocketWrite, SocketMsgRead, SocketMsgWrite

       EXAMPLE:	/*
       			**	Listen on a port 1234 and accept any clients,
       			**	Keep sending current time to each client
       			*/
       			
       			MasterSocket = SocketListen( 1234 );
       			
       			ClientList = [];
       			while( TRUE )
       			{
       				if( SocketPollInput( MasterSocket, 0 ))
       					ClientList &= SocketAccept( MasterSocket );
       				
       				ForEach( Client, ClientList )
       					SocketMsgWrite( Client, 1, CurrentTime());
       					
       				sleep( 1 );
       			};

      FUNCTION: SocketConnect

       SUMMARY: Connect to a listening host

         USAGE:	SocketConnect( 
         			Server,			// Host to which to connect
         			Port )			// Port which foreign host is listening to

       RETURNS: New socket

   DESCRIPTION:	SocketConnect is the client side step in establishing a
   				connection between two processes (typically on two different
   				hosts).  The server creates a master socket with SocketListen, then
   				the client calls SocketConnect, then the server accepts the
   				client with SocketAccept.  The new socket is now available
   				for reading and writing.  Alternatively, the server, instead
   				of SocketListen and SocketAccept can use the SockMsgServer
   				api.
   				
   				SocketConnects blocks while waiting for the server to
   				accept the connection.
   				
   				The port argument can either be the port number, e.g., 1234,
   				or a service name which is resolved to a port number through
   				the tcp/ip services database.  See your system administrator
   				for setting up new services.

      SEE ALSO:	SocketListen, SocketAccept,
      			SocketReadBinary, SocketReadLine, SocketReadResult, 
      			SocketWrite, SocketMsgRead, SocketMsgWrite

       EXAMPLE:	/*
       			**	Connect to host "foo.jany.gs.com" on service "foo-time"
       			**	Keep getting current time from foo
       			**	(see example for SocketAccept)
       			*/
       			
       			Socket = SocketConnect( "foo.jany.gs.com", "foo-time" );
       			
       			while( TRUE )
       			{
       				SocketMsgRead( Socket, Msg, MsgData );
       				if( Msg == 1 )	// we've agreed that Msg 1 is cur time
       					Message( "Time difference (from foo)\n"
       							+ String( MsgData - CurrentTime()));
       			};

      FUNCTION: SocketListen

       SUMMARY: Listen for new tcp/ip connection requests

         USAGE:	SocketListen( 
         			Port )		// Port to listen to

       RETURNS: New master socket

   DESCRIPTION:	SocketListen is the first step in establishing a connection
   				between two processes (typically on two different hosts).
   				The server creates a master socket with SocketListen, then
   				the client calls SocketConnect, then the server accepts the
   				client with SocketAccept.  The new socket is now available
   				for reading and writing.  Alternatively, the server, instead
   				of SocketListen and SocketAccept can use the SockMsgServer
   				api.
   				
   				The port argument can either be the port number, e.g., 1234,
   				or a service name which is resolved to a port number through
   				the tcp/ip services database.  See your system administrator
   				for setting up new services.
   				
      SEE ALSO:	SocketAccept, SocketConnect, SocketMsgServerLoopSwitch

       EXAMPLE:	/*
       			**	Listen on service "foo-time" and accept any clients,
       			**	Keep sending current time to each client
       			*/
       			
       			MasterSocket = SocketListen( "foo-time" );
       			
       			ClientList = [];
       			while( TRUE )
       			{
       				if( SocketPollInput( MasterSocket, 0 ))
       					ClientList &= SocketAccept( MasterSocket );
       				
       				ForEach( Client, ClientList )
       					SocketMsgWrite( Client, 1, CurrentTime());
       					
       				sleep( 1 );
       			};

      FUNCTION: SocketMsgClose

       SUMMARY: Close a client connection

         USAGE:	SocketMsgClose( 
         			Socket )		// Connection to close

       RETURNS: True/False

   DESCRIPTION:	SocketMsgDestroy closes a client connection that
   				was previously provided by SocketMsgServerLoopSwitch.
				This allows the server to hang up on a client.
				Unlike SocketMsgDestroy, SocketMsgClose actually
				closes the socket immediately. 
   				
   				Any pending messages on the connection that have not been
   				sent will be flushed with timeout of LingerTimeout
   				seconds.
   				
      SEE ALSO:	SocketMsgServerLoopSwitch, SocketMsgServerShutdown,
      			SocketMsgLinger

      FUNCTION: SocketMsgDestroy

       SUMMARY: Unmanage a client connection

         USAGE:	SocketMsgDestroy( 
         			Socket )		// Connection to destroy

       RETURNS: Nothing

   DESCRIPTION:	SocketMsgDestroy disconnects a client connection that
   				was previously provided by SocketMsgServerLoopSwitch.
   				For instance, if a client notifies the server of its
   				intent to disconnect, the server can throw the connection
   				away without generating a SOCK_MSG_ERROR by calling
   				SocketMsgDestroy.
   				
   				Any pending messages on the connection that have not been
   				sent will be flushed with timeout of LingerTimeout
   				seconds.
   				
      SEE ALSO:	SocketMsgServerLoopSwitch, SocketMsgServerShutdown,
      			SocketMsgLinger

       EXAMPLE:	/*
       			**	Server side of simple client/server app
       			*/
       			
       			Enum(
       				MSG_TIME,
       				MSG_DISCONNECT
       			);
       			
       			ClientList = [];
       			SocketMsgServerLoopSwitch( Socket, "foo-time", 1 )
       			{
       				SOCK_MSG_NEW,
       					ClientList &= Client;
       					
       				SOCK_MSG_READ,
       				{
       					SockMsgRead( Socket, Msg, MsgData );
       					if( Msg == MSG_DISCONNECT )
       						SocketMsgDestroy( Socket );
       				};
       				
       				SOCK_MSG_TIMER,
       					ForEach( Client, ClientList )
	       					SocketMsgWrite( Client, MSG_TIME, CurrentTime());
       			};

      FUNCTION: SocketMsgLinger

       SUMMARY: Set/get how long to try flushing pending write messages

         USAGE:	SocketMsgLinger( 
         			[LingerTimeout] )		// New value (in sec.)

       RETURNS: Old value

   DESCRIPTION:	Any pending messages or pieces of messages written with
   				SocketMsgWrite that have not yet been sent will be
   				flushed by SocketMsgDestroy or SocketMsgServerShutdown.
   				The timeout for sending these remaining messages is
   				determined by the LingerTimeout.  The LingerTimeout
   				is initially 10 seconds but can be changed by calling
   				SocketMsgLinger.  Even a value of zero will make one
   				non-blocking attempt to flush the buffers.
   				
      SEE ALSO:	SocketMsgDestroy, SocketMsgServerShutdown

       EXAMPLE:	/*
       			**	Change LingerTimeout to two seconds
       			*/
       			
       			NewValue = 2.0;
       			OldValue = SocketMsgLinger( NewValue );
       			Print( "Changed LingerTimeout from ", OldValue, " to ",
       					NewValue, "\n" );

      FUNCTION: SocketMsgRead

       SUMMARY: Recieve an entire message from a socket

         USAGE:	SocketMsgRead( 
         			Socket,				// Connection to recieve from
         			MsgVariable,		// Variable to put message type in
         			MsgDataVariable 	// Variable to put data value in
         			[, Timeout] )		// Timeout in seconds (-1 to block)
         			

       RETURNS: TRUE	on success
       			FALSE	on failure or timeout

   DESCRIPTION:	SocketMsgRead recieves a message sent by the other side
   				of the connection with SocketMsgWrite.  The message
   				consists of an integer message type and a message body.
   				These are assigned by SocketMsgRead to the variables
   				passed in to it.  The message body can be of any datatype
   				or omitted entirely (in which case, MsgDataVariable is set
   				to NULL by SocketMsgRead) but must be streamable (i.e.,
   				Binary( Value ) succeeds).
   				
   				SocketMsgRead may receive a message in more than one tcp
   				packet.  However, it automatically assembles the packets
   				and doesn't return TRUE until the entire message has
   				arrived.  If SocketMsgRead times out (either when no
   				message has arrived or only part of it has arrived within
   				the given Timeout) it returns FALSE, but sets
   				LastErrorNumber() to ERR_INCOMPLETE.  Timeout of -1 waits
   				forever and this is the default value outside of
   				SocketMsgServerLoopSwitch.
   				
      SEE ALSO:	SocketMsgWrite

       EXAMPLE:	/*
       			**	Connect to host "foo.jany.gs.com" on service "foo-time"
       			**	Keep getting current time from foo
       			**	(see example for SocketAccept)
       			*/
       			
       			Socket = SocketConnect( "foo.jany.gs.com", "foo-time" );
       			
       			while( TRUE )
       			{
       				SocketMsgRead( Socket, Msg, MsgData );
       				if( Msg == 1 )	// we've agreed that Msg 1 is cur time
       					Message( "Time difference (from foo)\n"
       							+ String( MsgData - CurrentTime()));
       			};

      FUNCTION: SocketMsgServerLoopSwitch

       SUMMARY: Dispatch server events

         USAGE:	SocketMsgServerLoopSwitch( SocketVariable, Port, Timer )
         		{
         			SOCK_MSG_NEW,
         			{
         				// Start using socket in SocketVariable
         			};
         			
         			SOCK_MSG_READ,
         			{
         				// Call SocketMsgRead( SocketVariable, Msg, MsgData )
         			};
         			
         			SOCK_MSG_ERROR,
         			{
         				// Report LastError() and stop using socket
         			};
         			
         			SOCK_MSG_TIMER,
         			{
         				// Something to do every Timer seconds
         			};
         		};
         			

       RETURNS: TRUE	- Success and clean exit with SocketMsgServerShutdown
       			FALSE	- Failure

   DESCRIPTION:	SocketMsgServerLoopSwitch manages the communication aspects
   				for a server in a client/server application.  It performs
   				the following tasks:
   				
   				1) Opens a master socket listening on the given port.
   					
   				2) Polls for and accepts all new client connections.  For
   				each new client, creates a socket and dispatches the block
   				of code labeled SOCK_MSG_NEW.
   				
   				3) Opportunistically sends messages to clients that have
   				been queued with calls to SocketMsgWrite.
   				
   				4) Opportunistically reads all messages from clients and
   				dispatches them to the block of code labeled SOCK_MSG_READ.
   				
   				5) Reports any communication errors by destroying the
   				connection and dispatching the block of code labeled
   				SOCK_MSG_ERROR.

				6) Occasionally executes server code by dispatching the
				block of code labeled SOCK_MSG_TIMER.  This is done every
				Timer seconds.
   				
      SEE ALSO:	SocketMsgDestroy, SocketMsgServerShutdown,
      			SocketMsgLinger, SocketMsgRead, SocketMsgWrite

       EXAMPLE:	/*
       			**	Server side of simple client/server app
       			*/
       			
       			Enum(
       				MSG_TIME,
       				MSG_DISCONNECT
       			);
       			
       			ClientList	= [];
       			StartTime	= CurrentTime();
       			Sts = SocketMsgServerLoopSwitch( Socket, "foo-time", 1 )
       			{
       				SOCK_MSG_NEW,
       					ClientList &= Client;
       					
       				SOCK_MSG_READ,
       				{
       					SockMsgRead( Socket, Msg, MsgData );
       					if( Msg == MSG_DISCONNECT )
       						SocketMsgDestroy( Socket );
       				};
       				
       				SOCK_MSG_TIMER,
       				{
       					UpTime = CurrentTime() - StartTime;
       					if( UpTime > 50000 )
       						SocketMsgServerShutdown( "foo-time" );
       						
       					ForEach( Client, ClientList )
	       					SocketMsgWrite( Client, MSG_TIME, CurrentTime());
	       			};
	       					
	       			SOCK_MSG_ERROR:
	       			{
	       				Print( "Error on ", Double( Socket ), ": ", 
	       						LastError(), "\n" );
	       				
	       				// Get rid of bad client from ClientList
	       				NewList = [];
	       				ForEach( Client, ClientList )
	       					if( Client != Socket )
		       					NewList &= Client;
		       			ClientList = NewList;
		       		};
       			};
       			
       			if( !Sts )
       				Print( "FAILED: ", LastError(), "\n" );

      FUNCTION: SocketMsgServerShutdown

       SUMMARY: Exit SocketMsgServerLoopSwitch

         USAGE:	SocketMsgServerShutdown( 
         			Port )				// Port of server

       RETURNS: Nothing

   DESCRIPTION:	Calling SocketMsgServerShutdown is preferred means
   				for breaking from SocketMsgServerLoopSwitch.
   				
   				Any pending messages on each connection that have not been
   				sent will be flushed with timeout of LingerTimeout
   				seconds for each connection.
   				
      SEE ALSO:	SocketMsgServerLoopSwitch, SocketMsgLinger

       EXAMPLE:	/*
       			**	Server side of simple client/server app
       			*/
       			
       			Enum(
       				MSG_TIME,
       				MSG_DISCONNECT
       			);
       			
       			ClientList	= [];
       			StartTime	= CurrentTime();
       			Sts = SocketMsgServerLoopSwitch( Socket, "foo-time", 1 )
       			{
       				SOCK_MSG_NEW,
       					ClientList &= Client;
       					
       				SOCK_MSG_READ,
       				{
       					SockMsgRead( Socket, Msg, MsgData );
       					if( Msg == MSG_DISCONNECT )
       						SocketMsgDestroy( Socket );
       				};
       				
       				SOCK_MSG_TIMER,
       				{
       					UpTime = CurrentTime() - StartTime;
       					if( UpTime > 50000 )
       						SocketMsgServerShutdown( "foo-time" );
       						
       					ForEach( Client, ClientList )
	       					SocketMsgWrite( Client, MSG_TIME, CurrentTime());
	       			};
	       					
	       			SOCK_MSG_ERROR:
	       			{
	       				Print( "Error on ", Double( Socket ), ": ", 
	       						LastError(), "\n" );
	       				
	       				// Get rid of bad client from ClientList
	       				NewList = [];
	       				ForEach( Client, ClientList )
	       					if( Client != Socket )
		       					NewList &= Client;
		       			ClientList = NewList;
		       		};
       			};
       			
       			if( !Sts )
       				Print( "FAILED: ", LastError(), "\n" );

      FUNCTION: SocketMsgWrite

       SUMMARY: Write an entire message to a socket

         USAGE:	SocketMsgWrite( 
         			Socket,				// Connection to send to
         			Msg,				// Message type (integer)
         			[, MsgData]		 	// Data value (body of message)
         			[, Timeout] )		// Timeout in seconds (-1 to block)
         			

       RETURNS: TRUE	on success
       			FALSE	on failure or timeout

   DESCRIPTION:	SocketMsgWrite sends a message to the other side
   				of the connection which will read it with SocketMsgRead.
   				The message consists of an integer message type and a
   				message body.  The message body can be of any datatype
   				or omitted entirely (in which case, SocketMsgRead gets
   				NULL) but must be streamable (i.e.,	Binary( Value )
   				succeeds).
   				
   				SocketMsgWrite may send a message in more than one tcp
   				packet.  It will send as many packets as possible until
   				it times out.  Any remaining packets will be flushed
   				by subsequent calls to SocketMsgWrite, by
   				SocketMsgServerLoopSwitch, or by SocketMsgDestroy or
   				when there are no more references to the socket.
   				Timeout of -1 waits	forever and this is the default value
   				outside of SocketMsgServerLoopSwitch.
   				
      SEE ALSO:	SocketMsgRead

       EXAMPLE:	/*
       			**	Listen on a port 1234 and accept any clients,
       			**	Keep sending current time to each client
       			*/
       			
       			MasterSocket = SocketListen( 1234 );
       			
       			ClientList = [];
       			while( TRUE )
       			{
       				if( SocketPollInput( MasterSocket, 0 ))
       					ClientList &= SocketAccept( MasterSocket );
       				
       				ForEach( Client, ClientList )
       					SocketMsgWrite( Client, 1, CurrentTime());
       					
       				sleep( 1 );
       			};

      FUNCTION: Sort

       SUMMARY: Sort an array

         USAGE:	Sort( Array, SortFunction )

       RETURNS: Null

   DESCRIPTION:	Sort the contents of an array.  The SortFunction is passed
   				two arguments - SortArg1 and SortArg2.  These variables
   				contain values from the array to be compared.
   				
   				The SortFunction must return:
   				
   					Negative number	- SortArg1 <  SortArg2
   					Zero			- SortArg1 == SortArg2
   					Positive number - SortArg1 >  SortArg2
   				
				If the SortFunction is not supplied, a generic sort function
				that compares SortArg1 with SortArg2 is used.

				The Or function, and the compare (<=>) operator are very
				useful when creating sort functions.

      SEE ALSO:	Function, SortTable

       EXAMPLE:	/******************************************************
				**  Routine: List Objects by Time
				**  Returns: None
				**  Action : Print list of object sorted by time
				******************************************************/

				List Objects by Time = Func(
    				Class       // Object class to use
				)
				{
    				Print( Class," objects sorted by modification",
    						"/creation time\n\n" );


				/*
				**  Run through all of the slang scripts
				*/

    				ByDate = [];
    				SecInfo = Structure();
    				ForSecurity( SecName, Class )
    				{
        				SecInfo.SecName = SecName;
        				If( Time Modified( SecName ))
        				{
            				SecInfo.LastTime = Time Modified( SecName );
            				SecInfo.TimeType = "Updated";
        				}
        				:
        				{
            				SecInfo.LastTime = Time Created( SecName );
            				SecInfo.TimeType = "Created";
        				};

        				ByDate &= SecInfo;
    				};


				/*
				**  Sort and display by time
				*/

    				Sort( ByDate, "SortArg2.LastTime <=> SortArg1.LastTime" );
    				ForEach( SecInfo, ByDate )
        				Print(	SecInfo.LastTime,	" ",
        						SecInfo.TimeType,	" ",
        						SecInfo.SecName,	"\n" );
				};

      FUNCTION: SortTable

       SUMMARY: Sort an array of structures by structure component.

         USAGE: SortTable(
         			Array,		// Array to sort
         			Components)	// Array of structure component names

       RETURNS: Null

   DESCRIPTION: The SortTable function is used to sort an array of structures.
   				The SortTable and Sort functions are similiar to each other,
   				but the SortTable function is usually easier to use for most
   				purposes.

				The Array argument should contain an array of structures that
				are similiar (each structure should have at least the
				components found in the Components argument.)

      SEE ALSO: Sort, TableInit

       EXAMPLE:	/******************************************************
				**  Routine: List Objects by Time
				**  Returns: None
				**  Action : Print list of object sorted by time
				******************************************************/

				List Objects by Time = Func(
    				Class       // Object class to use
				)
				{
    				Print( Class," objects sorted by modification",
    						"/creation time\n\n" );


				/*
				**  Run through all of the slang scripts
				*/

    				ByDate = [];
    				SecInfo = Structure();
    				ForSecurity( SecName, Class )
    				{
        				SecInfo.SecName = SecName;
        				If( Time Modified( SecName ))
        				{
            				SecInfo.LastTime = Time Modified( SecName );
            				SecInfo.TimeType = "Updated";
        				}
        				:
        				{
            				SecInfo.LastTime = Time Created( SecName );
            				SecInfo.TimeType = "Created";
        				};

        				ByDate &= SecInfo;
    				};


				/*
				**  Sort and display by time
				*/

    				SortTable( ByDate, [ "LastTime" ] );
    				ForEach( SecInfo, ByDate )
        				Print(	SecInfo.LastTime,	" ",
        						SecInfo.TimeType,	" ",
        						SecInfo.SecName,	"\n" );
				};

      FUNCTION: Sprint

       SUMMARY: Convert and concatenate all arguments into a string.

         USAGE: Sprint( Arg1, ... ArgN )

       RETURNS: String of all arguments.

   DESCRIPTION: Convert each argument into a string and append them to the
   				returned result string.

      SEE ALSO: Sprintf, Print, Printf, FillIn, Format, String

      FUNCTION: Sprintf

       SUMMARY: Formatted conversion of data into string form.

         USAGE: Sprintf( Format, ... )

       RETURNS: Formatted string.

   DESCRIPTION: The Slang Sprintf function supports most of the standard C
				format specifiers and some extensions to the '%s' format.
				The '%s' format works for all datatypes and supports
				additional format modifier characters for the Double
				and some other datatypes.  The 'l' (long) and 'h' (short)
				modifiers are not allowed.

				  Modifier		
				  Character		Meaning

					( or )		_Parens
					,			_Commas
					@			_Scale
					&			_Percent
					^			_Center
					+			_Plus
					?			_Cipher
					#			Trim trailing zeros after decimal point
					-			Left justify
					>			Right justify (default)
					<           _Trim Leading (i.e. no surrounding spaces even with '#')
					_           _Blank Zero
					
				Additional formats are also supported:
				
					%v			Provide something meaningful in the provided space,
								e.g. SPrintf( "%20v", Curve ) gives a twenty character
								or less description of the curve.
								
					%m			Mush compatible string (if different than String cast).
								This is provided for portable and backward-compatible
								hash codes in SecDb tradable security names.

      SEE ALSO: Sprint, Print, Printf, FillIn, Format, String

	   EXAMPLE:	/*
	   			**	Test the Sprintf function
	   			*/

					n = _Pi * -1000;
					
					s = Sprintf( "%,10.3s", n );	// Format with commas
					s = Sprintf( "%<10.2s", n );	// Left justify
					s = Sprintf( "%10.2e",  n );	// Scientific format
					s = Sprintf( "0x%08x",  n );	// Hex, leading zeros
					s = Sprintf( "String: '%s'\nNumber: %d\n",
								 "Test String",
								 1234 );			// Mixed string & number

      FUNCTION: SqlConnect

       SUMMARY: Connect to an SQL server

         USAGE: SqlConnect(
         			Server,		// Name of server to connect to
         			User,		// User name to connect as
         			Password,	// Password associated with user
         			HostName )	// Host name (optional)

       RETURNS: SqlConnection datatype if connected without error
       			Null if connection failed

   DESCRIPTION: The SqlConnect function is used to obtain a handle to an
   				SQL server.  The handle (SqlConnection datatype) can then
   				be used by the SqlQuery and ForSqlQuery functions.

      SEE ALSO: ForSqlQuery, SqlQuery

       EXAMPLE: /*
       			**	Connect to an SQL server and print the list of users
       			*/
       			
       				If( Conn = SqlConnect( "Server", "User", "" ))
       					Print( SqlQuery( "sp_who" ))
       				:
       					Print( "Connection failed!" );

      FUNCTION: SqlQuery

       SUMMARY: Query an SQL server and return the results

         USAGE: SqlQuery(
         			SqlConnection,	// Connection to the server
         			Query )			// SQL query in text form

       RETURNS: Array of results if no error (array can be empty)
       			Null if query is invalid, or causes an error

   DESCRIPTION: The SqlQuery function is used to communicate with an SQL
   				server.  A connection with the SQL server must first be
   				established using the SqlConnect function.

				The results of a successful query are placed in an array
				of structures.  Each row of the result corresponds to an
				element of the array.  The structure component tags
				correspond to the name of the column.
				
				The SqlQuery function can be used to issue any SQL query,
				not just select commands.  In the example below, there is
				one query that just sets the rowcount to 20, no results are
				expected from this query.  Stored procedures can also be
				executed with the SqlQuery function.

				For extremely large queries, the ForSqlQuery function should
				be used.

      SEE ALSO: ForSqlQuery, SqlConnect

       EXAMPLE: /*
       			**	Connect to an SQL server and display the first 20
       			**	lines of the results of a query.
       			*/

					ColWidth = 10;

					Conn = SqlConnect( "Server", "User", "" );
					SqlQuery( Conn, "set rowcount 20" );

					Results = SqlQuery( Conn, "select * from users" );
					ForEach( Row, Results )
					{
						ForComponent( ColName, Row )
							Print( Left( ColWidth, Row[ ColName ] ), " " );
						Print( "\n" );
					};

      FUNCTION: Sqrt

       SUMMARY: Square root

         USAGE:	Sqrt( Number )

       RETURNS: Square root of Number

   DESCRIPTION:	Square root of Number.  Sqrt will abort with an error if
       			Number is negative.  This function only operates on Doubles.

      SEE ALSO:	Exp, Log, Pow

      FUNCTION:	Stats

       SUMMARY:	Calculates Mean, Min, Max, StdDev, AvgDev, Variance,
       			Skewness, Kurtosis of an array of numbers.

         USAGE:	Stats( Array )

       RETURNS:	Structure containing calculated statistical values.
       
   DESCRIPTION:	The Stats function takes an array of two or more numbers
   				and returns a structure with the following components:
   				
   					Mean		- Arithmetic Mean
   					Min			- Minimum Value
   					Max			- Maximum Value
   					StdDev		- Standard Deviation
   					AvgDev		- Average Absolute Deviation 
   					Variance	- Variance
					Skewness	- Skewness
					Kurtosis	- Kurtosis
				
      SEE ALSO:	Min, Max

      FUNCTION: Sticky

       SUMMARY: Access a sticky variable

         USAGE:	Sticky( Variable )

       RETURNS: Value of Sticky variable (if rvalue)

   DESCRIPTION:	There are three types of variable scope within Slang - local,
				global and sticky.  Sticky scope is a protected scope that is
				public to all functions.  Variables in the sticky scope stay
				around after a slang script has run.

				The Sticky function allows a sticky variable to be gotten
				(rvalue) or set (lvalue).

				THE STICKY FUNCTION IS OBSOLETE, THE :: OPERATOR SHOULD BE
				USED INSTEAD.

      SEE ALSO:	Global, StickyDiddle, Scope, Scopes, ScopeSetSticky, ::

       EXAMPLE: /*
       			**	Set a sticky variable
				*/

					Sticky( Default Trader Name ) = "DUBNOM";


				/*
				**	Access a sticky variable
				*/

					Print( "Trader ", Sticky( Default Trader Name ), "\n" );


				/*
				**	Destroy a sticky variable
				*/

					Destroy( Sticky( Default Trader Name ));

      FUNCTION: StickyDiddle

       SUMMARY: Create or modify diddles that stay around after a script has
       			finished running.

         USAGE: StickyDiddle
         		{
         			BLOCK;
         		};

       RETURNS: Returned value of BLOCK

   DESCRIPTION: It is sometimes useful for a script to keep diddles around
   				even after evaluation has finished.  The StickyDiddle function
   				maintains a diddle scope outside of the usual diddle scope.

				Diddles done within the BLOCK (except for further nesting with
				the Eval operator) go into the sticky diddle scope.

      SEE ALSO: Sticky

       EXAMPLE: /*
       			**	Change the spot of DEM/USD
       			*/

					StickyDiddle
					{
						Spot( "DEM/USD" ) = 1.70;
					};


				/*
				**	Remove the sticky diddle
				*/

					StickyDiddle
					{
						Restore( Spot( "DEM/USD" ));
					};

      FUNCTION: StrBegins

       SUMMARY: Does String begin with SubString?

         USAGE: StrBegins( String, SubString )

       RETURNS: True/False

   DESCRIPTION: Check if String begins with SubString.  Same as
				StrPos( String, SubString ) == 0.

      SEE ALSO: StrContains, StrEnds, StrPos

       EXAMPLE: StrBegins( "FooBar", "Foo" )

      FUNCTION: StrChrCount

       SUMMARY: Count characters in String

         USAGE: StrChrCount(
					String,		// String
					CharSet,	// Set of characters to match
					Start,		// Starting offset (default: 0)
					End			// Ending offset (default: Size( String ))
				)

       RETURNS: Count

   DESCRIPTION: Count the number of times characters from CharSet appear
				in String.

       EXAMPLE: StrChrCount( "FooBar", "oa", 2 ) == 2

      FUNCTION: StrContains

       SUMMARY: Does String contain with SubString?

         USAGE: StrBegins( String, SubString )

       RETURNS: True/False

   DESCRIPTION: Check if String contains SubString.  Same as
				StrPos( String, SubString ) >= 0.

      SEE ALSO: StrBegins, StrEnds, StrPos

       EXAMPLE: StrContains( "FooBar", "oob" )

      FUNCTION: StrEnds

       SUMMARY: Does String end with SubString?

         USAGE: StrEnds( String, SubString )

       RETURNS: True/False

   DESCRIPTION: Check if String ends with SubString.  Same as
				StrPos( String, SubString ) == Size( String ) - Size( SubString ).

      SEE ALSO: StrBegins, StrContains, StrPos

       EXAMPLE: StrEnds( "FooBar", "bAR" )

      FUNCTION: StrField

       SUMMARY: Single space-separated field in String

         USAGE: StrField(
					String,		// The String
					FieldNum	// Optional index (negative starts from end)
				)

       RETURNS: The Field or ""

   DESCRIPTION: Treat string as a space separated set of fields.  If FieldNum is
				negative, indexing will be from end of string.

      SEE ALSO: StrSplit

       EXAMPLE: StrField( "Foo Bar"       ) == "Foo";
				StrField( "Foo Bar",    1 ) == "Bar";
				StrField( "Foo Bar",   -1 ) == "Bar";
				StrField( "Foo Bar",   -1 ) == "Bar";
				StrField( "  Foo Bar",  1 ) == "Bar";
				StrField( "Foo Bar  ", -1 ) == "Bar";

      FUNCTION: StrHeight

       SUMMARY: Height of a multiline string

         USAGE:	StrHeight( String )

       RETURNS: One plus the number of '\n' in String

   DESCRIPTION:	The StrHeight function returns the number of lines that a
   				string would need in order to be printed.  In other words,
   				StrHeight returns one plus the number of carriage returns
   				in a string.

				This function is useful when generating reports, and when
				working with the Page datatype.

      SEE ALSO:	StrWidth, Size, String

      FUNCTION: StrJoin

       SUMMARY: Join an array of strings into a single string

         USAGE: StrJoin(
         			Glue,			// Inserted between each array element
         			Parts)			// List of strings to join

       RETURNS: String concatenation of Parts with Glue in between each

   DESCRIPTION: Join all of the strings in the Parts array, with the Glue
				string in between each part. To join strings with nothing
				in between them, use "" for the Glue parameter.

				Instead of repeatedly appending to a string with += it is
				faster to add elements to an array of string parts, and then
				join all the parts when you are done.

      SEE ALSO: StrSplit

       EXAMPLE: Result = StrJoin( ":", [ "Name", "Rank", "Serial Number" ] );

      FUNCTION: StrLower

       SUMMARY: Convert string to lower case

         USAGE:	StrLower( String )

       RETURNS: Copy of 'String' converted to lower case

   DESCRIPTION:	Return a copy of 'String' converting all upper case
   				characters to lower case.  This function only operates
   				on Strings.

      SEE ALSO:	StrUpper

      FUNCTION: StrPos

       SUMMARY: Position of one string within another

         USAGE:	StrPos( String1, String2 )

       RETURNS: First position of String2 within String1
       			-1 if String2 not found within String1

   DESCRIPTION:	Find the first location of String2 within String1.  If String2
   				is not contained within String1, return -1.

      SEE ALSO:	SubStr, String

	   EXAMPLE:	/*
	   			**	Count the number of objects that have 'DEM' in their names
	   			*/

					Count = 0;
					ForSecurity( SecName, Null )
						If( -1 != StrPos( SecName, "DEM" ))
							Count++;
					Print( "DEM found in ", Count, " object names\n" );

      FUNCTION: StrRepeat

       SUMMARY: Replicate a string n-times

         USAGE: StrRepeat(
         			String,		// String to replicate
         			Count)		// Number of times to replicate

       RETURNS: A new string consisting of Count instances of String

   DESCRIPTION: The StrRepeat function is used to replicate a single string
   				many times.  This is useful when printing separators for
   				reports.

				The output string is limited to 10 Megabytes.

       EXAMPLE: /*
       			**	Print a line separator
       			*/

					Print( StrRepeat( "*-", 39 ), "\n" );

      FUNCTION: StrSplit

       SUMMARY: Split a string into an array of strings

         USAGE: StrSplit(
         			String,			// String to split
         			SplitChar,		// Character to split on
         			[FilterBlanks])	// True to filter out blank entries

       RETURNS: Array of substrings

   DESCRIPTION: Split 'String' into an array of substrings where 'SplitChar'
   				is used as the delimiter.  The delimiter is not included in
   				the substrings.

      SEE ALSO: StrPos, StrJoin, RegEx, RegMatch, RegSub

       EXAMPLE: /*
       			**	Convert comma delimited data into individual fields
       			*/

					Data = "Option,Call,Usd,Dem,1.7,23Aug94";
					Print( StrSplit( Data, "," ));

      FUNCTION: StructureUnion

       SUMMARY: Create a union between two structures.

         USAGE:	StructureUnion( LValue, Value )

       RETURNS: Null

   DESCRIPTION: Create a union between two structures.  The LValue structure
   				receives components from the Value structure that it doesn't
   				already have.

      SEE ALSO: Structure

      FUNCTION: StrUpper

       SUMMARY: Convert string to upper case

         USAGE:	StrUpper( String )

       RETURNS: Copy of 'String' converted to upper case

   DESCRIPTION:	Return a copy of 'String' converting all lower case
   				characters to upper case.  This function only operates
   				on Strings.

      SEE ALSO:	StrLower, String

      FUNCTION: StrWidth

       SUMMARY: Return the largest line width of a multiline string

         USAGE:	StrWidth( String )

       RETURNS: Largest line width of 'String'

   DESCRIPTION:	The StrWidth function operates on strings with embedded
   				carraige returns ('n').  It returns the length of the longest
   				line within a multiline string.

				This function is useful when generating reports, and when
				working with the Page datatype.

      SEE ALSO:	StrHeight, Size, String

      FUNCTION: SubStr

       SUMMARY: Return a portion of a string

         USAGE:	SubStr( String, Start, End )

       RETURNS: Portion of a string between Start and End inclusive

   DESCRIPTION:	The SubStr function returns the portion of String between
   				the Start and End arguments inclusive.  If the End argument
   				isn't specified, or if it exceeds the length of the string,
   				then the length of the string is used.

      SEE ALSO:	String, StrPos

      FUNCTION: Sve*

       SUMMARY: SecViewEditor functions

   DESCRIPTION:	The SecViewEditor is configurable with Slang scripts.  The
   				following functions operate on the Sve datatype:

					SveBrowseOutput			- Browse output window.
					SveBufferUse			- Select buffer to edit.
					SveChangeMark			- Change mark type.
					SveCopy					- Copy a block from a buffer.
					SveCut					- Cut a block from a buffer.
					SveDeleteChar			- Delete a char from a buffer.
					SveDeleteEOL			- Delete to end of line.
					SveDeleteLine			- Delete an entire line.
					SveDropMark				- Start a marked region.
					SveEvaluateBuffers		- Evaluate buffer(s).
					SveGetColors			- Get a buffer's colors.
					SveGetCurrentSve		- Get current buffer ID.
					SveGetLastKey			- Get last keystroke entered.
					SveGetLine				- Get line from a buffer.
					SveGetMark				- Get mark information.
					SveGetPos				- Get cursor position.
					SveGetSveInfo			- Get buffer information.
					SveGetSveList			- Get list of buffers.
					SveInsert				- Insert text into a buffer.
					SveKeyExpression		- Register a key expression.
					SveKeyMapPop			- Pop a keymap.
					SveKeyMapPush			- Push a keymap.
					SveKeyProcess			- Process keystrokes.
					SveKeyRegister			- Register a key function.
					SvePaste				- Paste into a buffer.
					SvePos					- Position the cursor.
					SveRaiseMark			- Remove a mark.
					SveRefOff				- Turn buffer refresh off.
					SveRefOn				- Turn buffer refresh on.
					SveRPos					- Relative position the cursor.
					SveSetColors			- Set a buffer's colors.
					SveShiftLines			- Shift lines to left or right.
					SveShowConstants		- Window of constants.
					SveShowDataTypes		- Window of datatypes.
					SveShowElapsedTime		- Window of elapsed eval time.
					SveShowFunctions		- Window of slang functions.
					SveShowProfilerOutput	- Show last profiler output.
					SveShowVariables		- Window of variables.
					SveShowVariableScopes	- Window of variable scopes.
					SveUndo					- Undo last operation.

      FUNCTION: Switch

       SUMMARY: Matched conditional expression execution

         USAGE:	Switch( MatchExpression,
         			CaseExpression 1,	EvalExpression 1,
         			CaseExpression 2,	EvalExpression 2,
         			.
         			.
         			.
         			CaseExpression N,	EvalExpression N,
         			[ DefaultEvalExpression ] )

       RETURNS: Result of matching EvalExpression

   DESCRIPTION:	Evaluate the MatchExpression, match results with each
   				CaseExpression.  If a match is found, execute the related
   				EvalExpression.  If no match is found, and a
   				DefaultEvalExpresion exists, execute the default expression.

				Return the result of the evaluated EvalExpression.

      SEE ALSO:	If

       EXAMPLE:	/*
       			**	The first Switch function converts a numeric value
       			**	into a string.  The second displays different things
       			**	based upon the type of data
       			*/

					Numeric Value = 2;
					String Value = Switch( Numeric Value,
							1,	"One",		
							2,	"Two",		
							3,	"Three"	);

					Print( Switch( TypeOf( Value ),
							"Double",	Format( Value, 20, 4, _Commas ),
							"String",	Left( 20, Value ),
							"Curve",	"Curve",
							"Array",	"Array",
							"Date",		Value,
							"Time",		Value,
										Value ));	// Last is default

      FUNCTION: System

       SUMMARY: Execute an operating system command

         USAGE:	System( Command )

       RETURNS: Result passed back from command interpreter

   DESCRIPTION:	The System function passes the Command to the command
   				interpreter which executes the command as an operating
   				system command.  The function waits for the command
   				to finish, and then returns the result.

       EXAMPLE: /*
				**	Print a 'Yow' message
				*/

					System( "yow > yow.tmp" );
					File = FileOpen( "yow.tmp" );
					While( Line = FileReadLine( File ))
						Print( Line, "\n" );
					Destroy( File );
					System( "del yow.tmp" );

      FUNCTION: ProcessID

       SUMMARY: Get process id of slang session

         USAGE:	ProcessID()

       RETURNS: Process id returned from the OS in a DtDouble

   DESCRIPTION:	Gets the id of the process in which the current slang
				session is running.

       EXAMPLE: /*
				**	Kill self
				*/

					ProcessKill( ProcessID() );

      FUNCTION: ProcessCpuTime

       SUMMARY: Get CPU used by slang session

         USAGE:	ProcessCpuTime()

       RETURNS: DtDouble or DtNull

   DESCRIPTION:	Return a DtDouble with the *user* CPU usage in seconds
				of the current slang process (CPU time while in system
				calls in NOT included). Returns DtNull on error.

       EXAMPLE: If( ( CpuTime = ProcessCpuTime() ) == Null )
				{
					Print( LastError() );
				}:
				{
					Print( "CPU usage so far = ", CpuTime, "\n" );
				};

      FUNCTION: Tan

       SUMMARY: Arithmetic tangent

         USAGE:	Tan( Number )

       RETURNS: Tangent of the Number specified

   DESCRIPTION:	Trigonometric function to return the tangent of a number.
   				'Number' is expressed in radians.  This function only
   				operates on Doubles.

      SEE ALSO:	Sin, Tan

      FUNCTION: TableInit

       SUMMARY: Initialize an array of structures

         USAGE:	TableInit( Array )

       RETURNS: Array of initialized structures

   DESCRIPTION:	The TableInit function is used to initialize an array of
   				structures.  The Array argument contains an array of arrays.
   				The first sub-array contains the component names for the
   				structures.  Each subsequent sub-array contains the values
   				for the structures.

				The TableInit function is very useful for setting up dialogs.

      SEE ALSO:	Array, Structure, Dialog

       EXAMPLE: /*
       			**	Initialize a table of structures
       			*/

					List = TableInit( [
							[ "Name",	"Priority"	],
							[ "Low",	0			],
							[ "Medium",	1			],
							[ "High",	2			]
							] );

      FUNCTION: TeePrintToFile

       SUMMARY: Send print output to print device and to a file

         USAGE:	TeePrintToFile( FileName, AppendFlag )
         		{
         			BLOCK;
         		};

   DESCRIPTION:	The output of the Print function can be sent to a file in
   				addition to wherever Print is already sending output.
				The FileName specifies the name of a file to send the ouput
				to.  The AppendFlag indicates whether the output should be
				appended to the end of the file if the file already exists.

				The TeePrintToFile function can be nested to allow sending
				output to more than one file.

      SEE ALSO:	Print

	   EXAMPLE: /*
	   			**	Save output to a file (don't append)
	   			*/
	   			
	   			TeePrintToFile( "output.log", False )
	   			{
	   				Print(	"This text will be both displayed and saved\n",
	   						"to the output.log file." );
	   			};

      FUNCTION: To

       SUMMARY: Convert an argument to a specified datatype

         USAGE:	To(
					NewType,	// Datatype to convert the argument to
	         		Arg)		// Argument to convert

       RETURNS:	Argument converted into the specified datatype.

   DESCRIPTION:	All expressions, functions and variables anayalyze to some
   				value of some datatype.  The To function is used to convert
   				these values into a specific data type.

				The original datatype of the argument determines the way
   				the argument is converted.  Not all datatypes can be
   				converted into other datatypes, that is dependent upon
   				the implementation of the datatype.

				As a general rule, all datatypes have the ability to convert
				to strings, but aren't necessarily able to convert from
				strings.

				In general the To function should not be used.  Each datatype
				can perform the same functionality as the To function by
				using the name of the datatype as a function.  The examples
				below demonstrate date conversion:
				
					Test Date One = Date( "11Jan93" );
					Test Date Two = Date( 19920101 );
					
				The format above is recommended over the use of the To
				function due to speed and readability issues.

      SEE ALSO: Datatypes

       EXAMPLE:	/*
				**	Test the To function
				*/

					Test Date One = To( "Date", "11Jan93" );
					Test Date Two = To( "Date", 19920101 );
					Today = Current Date( "Security Database" );
					Date As Number= To( "Double", Today );

					Print(	Test Date One, " ",
							Test Date Two, " ",
							Today, " ",
							Date As Number, "\n" );

      FUNCTION: ToContinuous

       SUMMARY: Convert an interest rate, or an interest rate curve
       			from simple to conitnuous

         USAGE:	ToContinuous(
         			Rate,
         			Date)

         		ToContinuous(
         			Curve)

       RETURNS: Individual rate if a rate is passed
       			Curve is a curve is passed

   DESCRIPTION:	Convert a simple interest rate or interest rate curve
   				into a continuous rate or continuous rate curve.

      SEE ALSO:	FromContinuous

      FUNCTION: TradeModifyPriorDay

       SUMMARY: Generate prior-day ammendment trades

         USAGE: TradeModifyPriorDay( Trade )

       RETURNS: True	- Trade modified without error
       			False	- Trade modification failed

   DESCRIPTION: Modifies a prior day trade by putting in two new trades--
   				one that backs out the effects of the given trade and
   				another that puts in the correct effects.  This is the
   				functionality that Tap uses to modify a prior day trade
   				and is the behavior needed to support P&L and the Real
   				Time Book.
   														
   				The re-book trade has all the modified values and:
   				
   					Trade Time			Current time
   					Trade ID			New unique id
   					Reference Trade		Original trade
   					Reference Type		"Prior day re-book"
   					Trade States		Behave specially for back-office
   					Comments			Original trade + ", Prior day re-book"
   					
   				The backout trade has all the values of the original
   				trade except:
   				
   					Quantity			Original quantity * -1
   					Trade Time			Current time
   					Trade ID			New unique id
   					Reference Trade		Original trade
   					Reference Type		"Prior day backout"
   					Trade States		"Ignore"
   					Comments			Original trade + ", Prior day backout"
   					
   				The original trade is modified only in the following values:
   				
   					Reference Trade		Re-book trade
   					Reference Type		"Modified by Prior Day Amend"
   					Trade States		"Ignore"

      SEE ALSO: UpdateSecurity

       EXAMPLE: /*
       			**	Modify the expiration date of trade to 3May94.
       			*/
       			
       			Trade = GetSecurity( Argv[ 0 ] );
       			SetValue( Expiration Date( Trade ), Date( "3May94" ));
       			
       			if( Date( Trade Time( Trade )) < Date( CurrentGMTime( ))
       				Status = TradeModifyPriorDay( Trade )
       			:
       				Status = UpdateSecurity( Trade );
       			if( !Status )
    				Print( LastError(), "\n" );


      FUNCTION: Transaction

       SUMMARY: Transactionally protect database operations within a block

         USAGE: Transaction( DescriptionText [,Force] )
         		{
         			BLOCK
         		};	

       RETURNS: True	- Transaction committed without error
       			False	- Transaction failed

   DESCRIPTION: The Transaction function is used to insure that all database
   				operations within a block commit or fail together.  This
   				prevents two or more operations that depend on one another
   				to be out of sync.

				The TransactionAbort function can be used within the block
				to abort the transaction, exit the block, and return False
				from Transaction.

				The Transaction function can be nested.

				An example of transactional protection can be found in the
				implementation of trades.  A trade will update one or more
				positions.  The positions must be updated along with the
				trade for the database to remain consistant.

      SEE ALSO: TransactionAbort, TransLogDetail, TransLogHeader,
      			TransLogLast

       EXAMPLE: /*
       			**	Delete two securities (or none if either can't
       			**	be deleted)
       			*/

					Success = Transaction( "Demo Transaction" )
					{
						DeleteSecurity( "Bogus 1" );
						DeleteSecurity( "Bogus 2" );
					};
					
					If( Success )
						Print( "Securities deleted without error" )
					:		
						Print( "Couldn't delete because:\n", LastError());

      FUNCTION: TransactionAbort

       SUMMARY: Abort a Transaction that is in progress

         USAGE: TransactionAbort()

       RETURNS: None

   DESCRIPTION: The TransactionAbort function is used to break from within
   				the block of a Transaction statement.
   				
				For more information about transactions please refer to the
				Transaction function.

      SEE ALSO: Transaction, TransLogDetail, TransLogHeader, TransLogLast

      FUNCTION: TransLogDetail

       SUMMARY: Retrieve the detail associated with a transaction

         USAGE: TransLogDetail( TransID [,RawMemory] )

       RETURNS: Array of structure containing transaction detail
       			Null if transaction detail can't be retrieved

   DESCRIPTION:	Any time a database is modified (something added, deleted,
   				modified, index built, etc...) a transaction is created.
   				A transaction consists of a header and detail.  The header
   				record contains general information about the transaction,
   				and can be obtained by using the TransLogHeader function.
   				The TransLogDetail function retrieves the detail portion of
   				a transaction, the detail contains the actual list of the
   				actions that modified the database.
   
				The TransLogDetail function returns an array of structures.
				Each structure corresponds to an event within the transaction
				that modified the database.
				
				The structures can have one or more of the following
				components:

					OldSdbDisk		- Structure of old object's disk
									  information.
					Stored Object	- Structure/Memory block containing
									  the object's in-stream values.  If the
									  RawMemory argument is passed to the
									  TransLogDetail function, then a block
									  of memory will be returned, otherwise a
									  structure of the object's in-stream
									  value will be returned.
					Index Name		- Name of index.
					Part Count		- Number of parts in an index update.
					SecName			- Name of object.
					Type			- Type of operation (listed below)
					Values			- Table of values in an index update.
					Direction		- Direction of an incremental update.
					Msg Mem			- Memory block passed to the server's
									  incremental function.
					Msm Mem Size	- Size of the memory block passed to a 
									  server's incremental function.
					SdbDisk
				
				Types:
					Insert				- Insert an object into the database.
					Update				- Update an object within the database
					Delete				- Delete an object from the database.
					Rename				- Change an object's name.
					Index Insert		- Insert an object into an index.
					Index Update		- Update an object within an index.
					Index Delete		- Delete an object from an index.
					Index Rename		- Rename an object within an index.
					Index Create		- Create a new index.
					Index Destroy		- Destroy an old index.
					Incremental			- Incremental update of an object.
					Index Incremental	- Incremental update of an object
										  within an index.

      SEE ALSO: TransLogHeader, TransLogLast, Transaction, TransactionAbort

       EXAMPLE: /*
       			**	Print the transaction header and detail for the
       			**	last transaction 
       			*/

					TransID = TransLogLast();
					Print(	TransLogHeader( TransID ),
							"\n\n",
							TransLogDetail( TransID ));

      FUNCTION: TransLogHeader

       SUMMARY: Retrieve the header associated with a transaction

         USAGE: TransLogHeader( TransID )

       RETURNS: Structure containing transaction header
       			Null if transaction header can't be retrieved

   DESCRIPTION:	Any time a database is modified (something added, deleted,
   				modified, index built, etc...) a transaction is created.
   				A transaction consists of a header and detail.  The header
   				record contains general information about the transaction,
   				and can be obtained by using the TransLogHeader function.
   				The TransLogDetail function retrieves the detail portion of
   				a transaction, the detail contains the actual list of the
   				actions that modified the database.
   
   				The returned structure consists of the following components:

					Application Name	- Name of the application that added
										  the transaction.
					Database			- Database where the transaction was
										  initially created.  This is usefull
										  when dealing with synchronized
										  databases.
					Detail Bytes		- Number of bytes in the transaction
										  detail record.
					Detail Key1			- Key used by the database driver.
					Detail Key2			- Key used by the database driver.
					Detail Parts		- Number of parts in the detail
										  record.  Each part corresponds to
										  a structure in the array returned
										  by TransLogDetail.
					GM Time				- Greenwich Mean Time that the
										  ransaction was added.
					Network Address		- IP address of the machine that added
										  the transaction.  Some database
										  drivers do not support this field.
					SecName				- Description of the transaction.
					SecType				- Optional security type.
					Source Trans ID		- If the transaction came from a
										  synchronized database, then this
										  field will contain the transaction
										  ID from the original database.
					Trans ID			- Transaction ID of this transaction.
					Trans Type			- Type of transaction (detailed below)
					Type				- Commit/Abort
					User Name			- Name of the user who committed the
										  transaction.


				Transaction Types (Trans Type):

					'Insert'
					'Update'
					'Delete'
					'Rename'
					


      SEE ALSO: TransLogDetail, TransLogLast, Transaction, TransactionAbort

       EXAMPLE: /*
       			**	Print the transaction log header for the last transaction
       			*/

					Print( TransLogHeader( TransLogLast()));

      FUNCTION: TransLogLast

       SUMMARY: Retrieve the TransID of the last transaction in the database

         USAGE: TransLogLast()

       RETURNS: TransID of the last transaction in the database

   DESCRIPTION: The TransLogLast function returns the number of the last
   				transaction in the database.  This number can be used to
   				run backwards through the transaction log looking for
   				transactions of interest.

      SEE ALSO: TransLogHeader, TransLogDetail, Transaction, TransactionAbort

       EXAMPLE: /*
       			**	Print the transaction log header for the last transaction
       			*/

					Print( TransLogHeader( TransLogLast()));

      FUNCTION: Trim

       SUMMARY: Remove trailing white space from a string

         USAGE:	Trim( String )

       RETURNS: String without trailing white space

   DESCRIPTION:	Return a copy of String with trailing white space removed.

      SEE ALSO:	SubStr, String, Left, Right, Center

      FUNCTION: Tsdb

       SUMMARY: Evaluate a time-series database expression

         USAGE:	Tsdb(
         			TsdbExpression,
         			StartDate,
         			EndDate)

       RETURNS: Time Series if successful
       			Null if TsdbExpression cannot be evaluated

   DESCRIPTION:	This function evaluates the TsdbExpression using the Time-
   				Series Database Functions (Plot tool expressions).  The result
   				of this function is a Time Series (datatype) if successful.

				StartDate and EndDate are optional.  If StartDate is omitted,
				the first possible date is used.  If EndDate is omitted, then
				today's date is used.

				For more information about TSDB and TSDB functions, read the
				TSDB manual.

      SEE ALSO:	TsdbUpdate

       EXAMPLE:	/*
       			**	Evaluate an tsdb expression and print the results.
       			*/

					Start Date = Current Date( "Security Database" ) - 365;
					End Date   = Current Date( "Security Database" );

					Sym = Tsdb( "m1=avg(dm,7)", Start Date, End Date );
					For( Day = Start Date; Day <= End Date; Day++ )
						Print( Day, "  ", Sym[ Day ], "\n" );

      FUNCTION: TsdbLastPoint

       SUMMARY: Last point of a tsdb symbol

         USAGE: TsdbLastPoint(
         			Symbol)		// Symbol (not expression) to use

       RETURNS: Structure containing last point information
       			Null if symbol couldn't be found

   DESCRIPTION: The TsdbLastPoint function provides a simple mechanism for
   				retrieving the last point of a symbol.  The real-time symbols
   				are searched before the daily symbols.

				The returned structure consists of the following components:
				
					Date	- Date of last point (daily data)
					Time	- Time of last point (real-time data)
					Value	- Value of last point

				TsdbLastPoint takes the name of a symbol as an argument, not
				a tsdb expression.

      SEE ALSO: Tsdb, Time Series

       EXAMPLE: /*
       			**	Display the current price of ibm
       			*/
       			
       				Print( TsdbLastPoint( "ibm" ));

      FUNCTION: TsdbUpdate

       SUMMARY: Update a time-series database symbol

         USAGE:	TsdbUpdate(
         			Symbol,
         			Date,
         			Value)
         			
					or

         		TsdbUpdate(
         			Symbol,
         			Curve)

       RETURNS: True/False

   DESCRIPTION:	The TsdbUpdate function is used to update points within a
   				tsdb symbol (time series).  The point or points specified
   				will override corresponding points within the tsdb symbol.

      SEE ALSO:	Tsdb

      FUNCTION: TypeOf

       SUMMARY: Determine the type of an argument

         USAGE:	TypeOf(
	         		Arg)	// Argument to determine the type of

       RETURNS:	String representation of the datatype of the argument

   DESCRIPTION:	All expressions, functions and variables anayalyze to some
   				value of some datatype.  The TypeOf function is used to
   				determine the datatype of a value.

				TypeOf returns the string representation for the name of
				the datatype.

				A list of the intrinsic datatypes supported by Slang can
				be found in the Datatypes section of this manual.

      SEE ALSO: Datatypes

       EXAMPLE:	/*
				**	Print the types of some values
				*/

					Curve = Interest Rate Curve( "DEM" );
					Today = Current Date( "Security Database" );


					Print( TypeOf( 5 * 7 + 10 ), "\n" );
					Print( TypeOf( Curve ), "\n" );
					Print( TypeOf( Today ), "\n" );

      FUNCTION: UpdateSecurity

       SUMMARY: Update a security within the database

         USAGE:	UpdateSecurity(
	         		Security)	// Security or name of security to update

       RETURNS: TRUE if the security was updated without problems
       			FALSE if there was a problem

   DESCRIPTION:	The UpdateSecurity function is used to write a new security,
   				or the changes made to an existing security to the database.
				The function automatically determines if the security should
				be added or updated in the database.

				The UpdateSecurity function will fail if the security was
				updated somewhere else before your call to UpdateSecurity.
				In other words between the GetSecurity and UpdateSecurtiy a
				different application updated the security.  If this happens
				an application can just re-get the security, make the changes
				again and then re-update the security.

	  SEE ALSO: NewSecurity, GetSecurity, DeleteSecurity, RenameSecurity,
	  			SetValue, SecDbAdd, SecDbUpdate

       EXAMPLE:	See the examples for NewSecurity and GetSecurity

      FUNCTION: UseDatabase

       SUMMARY: Use a specific database within a block

         USAGE: UseDatabase( Database )
         		{
         			BLOCK;
         		};

       RETURNS: Results of the block

   DESCRIPTION: The UseDatabase function is used to operate on a specific
   				database.

      SEE ALSO: Database datatype

       EXAMPLE: /*
       			**	Get a security from the NYC BACKUP database
       			*/
       			
       			Db = Database( "Nyc Backup" );
       			UseDatabase( Db )
       			{
       				OldVersion = GetSecurity( "dem" );
       			};

      FUNCTION: Validate

       SUMMARY: Validate an object

         USAGE:	Validate( Object )

       RETURNS: True  - Object is valid
       			False - Object is not valid

   DESCRIPTION:	The Validate function determines if an object considers itself
   				to be valid.  Each object within SecDb is required to support
   				a validation message.  The meaning of 'valid' is determined
   				by the class of object being validated.

				For more information about validation, consult the SecDb API
				and SecDb OBJECT manuals.

      FUNCTION: Variables

       SUMMARY: Retrieve a list of variables within a scope

         USAGE: Variables( ScopeName )

       RETURNS: Array of strings of variable names

   DESCRIPTION: The Variables function returns an array of the variable names
   				that are defined within a scope.

      SEE ALSO: Scope, Scopes, ScopeSetSticky, ::

       EXAMPLE: /*
       			**	Print the list of variables defined in the global scope
       			*/

					Print( Variables( "Global" ));

      FUNCTION: W_Attach

       SUMMARY: Attach the scrolling of two windows together.

         USAGE: W_Attach(
         			Parent,		// Parent window
         			Child,		// Child window
         			Method)		// Synchronization method

       RETURNS: Null

   DESCRIPTION: The W_Attach function allows two or more windows to operate
   				in a synchronized fashion.  This means that motion in one
   				window will cause motion in another window.  This function is
   				useful when making interfaces with column headings that should
   				remain visible while rows of data are scrolled.

				A linked list of windows can be synchronized by specifying the
				correct Parent/Child combinations.

				The W_Detach function should be called before any of the linked
				windows are destroyed.  This will prevent links to undefined
				windows.

				The Method can be any of the following constants added
				together:
				
					SYNC_X		- Synchronize horizontal scrolling
					SYNC_Y		- Synchronize vertical scrolling
					SYNC_CURSOR	- Synchronize line cursor
					SYNC_BOTH	- Synchronize horizontal & vertical scrolling
   
      SEE ALSO: W_Detach, W_Pick

      FUNCTION: W_Color

       SUMMARY: Set the current printing color for a window.

         USAGE: W_Color(
         			Window,		// Window to operate on
         			Foreground,	// Foreground color (color of the text)
         			Background)	// Background color

       RETURNS: Null

   DESCRIPTION: The W_Color function sets the color that is used by the
   				W_Print function.

				The following color constants are defined:
					EIC_BLACK				EIC_BROWN
					EIC_BLUE				EIC_CYAN
					EIC_BRIGHT_BLUE			EIC_DARK_GREY
					EIC_BRIGHT_CYAN			EIC_GREEN
					EIC_BRIGHT_GREEN		EIC_MAGENTA
					EIC_BRIGHT_MAGENTA		EIC_RED
					EIC_BRIGHT_RED			EIC_WHITE
					EIC_BRIGHT_WHITE		EIC_YELLOW

      SEE ALSO: W_Print, Window

       EXAMPLE: /*
       			**	Set the current color to white on blue
       			*/
       			
					Wnd = Window();
       				W_Color( Wnd, EIC_WHITE, EIC_BLUE );
       				W_Print( Wnd, "Hello World!" );

      FUNCTION: W_Del

       SUMMARY: Delete lines from a window.

         USAGE:	W_Del(
         			Window,		// Window to delete lines from
         			Line,		// Line number to start deleting from
         			Count)		// Number of lines to delete

       RETURNS: Null

   DESCRIPTION:	Delete lines from a window.

      SEE ALSO:	W_Ins, W_GetLine, W_Print, Window

      FUNCTION: W_Detach

       SUMMARY: Detach windows that have been attached with W_Attach.

         USAGE: W_Detach(
         			Parent,		// Parent window
         			Method)		// Method being detached

       RETURNS: Null

   DESCRIPTION: Detach windows that have been attached with W_Attach.

      SEE ALSO: W_Attach

      FUNCTION: W_GetKey

       SUMMARY: Get a key from the keyboard

         USAGE:	W_GetKey()

       RETURNS: Double containing keystroke value

   DESCRIPTION:	The key mapping constants are defined at startup.  Use
				Alt-F4 in the SecView Slang editor to view WK_ constants.

      FUNCTION: W_GetLine

       SUMMARY: Get a string from a window

         USAGE:	W_GetLine(
         			Window,		// Window to get line from
         			Line)		// Line number to read from

       RETURNS: String containing data from Line in Window
	   			Null if Line is invalid or unallocated
       
   DESCRIPTION:	Get the contents of a line from a window.

      SEE ALSO:	W_Del, W_Ins, W_Print, Window

      FUNCTION: W_Hide

       SUMMARY: Hide a window

         USAGE: W_Hide( Window )

       RETURNS: Null

   DESCRIPTION: A window can be made invisible by using the W_Hide function.
   				The contents of the window are not lost, they are simply
   				hidden from view until a W_Show function is executed.

      SEE ALSO: W_Show, Window

      FUNCTION: W_Ins

       SUMMARY: Insert blank lines into a window

         USAGE:	W_Ins(
         			Window,		// Window to insert lines into
         			Line,		// Line number to insert from
         			Count)		// Number of lines to insert

       RETURNS: Null

   DESCRIPTION:	Insert blank lines into a window.

      SEE ALSO:	W_Del, W_GetLine, W_Print, Window

      FUNCTION: W_LineCursor

       SUMMARY: Set the location of the line cursor within a window

         USAGE: W_LineCursor(
         			Window,		// Window to operate on
         			Line)		// Line number to set

       RETURNS: Null

   DESCRIPTION: Set the location of the line cursor.

      SEE ALSO: W_Pos, W_MakeVis, Window

      FUNCTION: W_MakeVis

       SUMMARY: Make a region of a window visible

         USAGE: W_MakeVis(
         			Window,		// Window to operate on
         			x,			// Column
         			y,			// Line
         			Width,		// Width of region
         			Length)		// Length of region

       RETURNS: Null

   DESCRIPTION: The data within a window can be much larger than the viewport
   				displayed on the screen.  The W_MakeVis function makes a
   				region within a window appear in the viewport on the screen.

      SEE ALSO: W_Pos

      FUNCTION: W_Pick

       SUMMARY: Allow the user to pick through a window

         USAGE: W_Pick( Window [,MinLine [,MaxLine [,SmartScroll]]] )

       RETURNS: Value of key last hit.

   DESCRIPTION: The W_Pick function is used to allow a user to scroll around
   				a window.  Any key not understood by the W_Pick function will
   				cause the function to terminate and return the key value.
   				
   				The MinLine and MaxLine arguments are used to restrict the
   				range of the cursor.
   				
   				The SmartScroll argument allows text search name matching
   				similiar to the main security picking screen in SecView.

      SEE ALSO: W_LineCursor, W_Pos, W_Print, W_GetLine, Window

       EXAMPLE: /*
       			**	Display a list of indices and let the user
       			**	scroll through and pick one
       			*/

					Wnd = Window();
					W_Relocate( Wnd, 15, 10, 60, 30 );
					W_Print( Wnd, IndexNames() );
					While( True )
					{
						Key = W_Pick( Wnd );
						If( Key == WK_ESC )
							Break;
						If( Key == WK_ENTER )
						{
							Print( W_GetLine( Wnd, Wnd.l_cursor ), "\n" );
							Break;
						};
					};
					Destroy( Wnd );

      FUNCTION: W_Pos

       SUMMARY: Position the character cursor within a window

         USAGE: W_Pos(
         			Window,		// Window to operate on
         			x_cur,		// x location in window
         			y_cur)		// y location in window

       RETURNS: Null

   DESCRIPTION: The character cursor determines the location within a window
   				where W_Print will print next.  The W_Pos function is used
   				to set the location of the character cursor.
   				
   				The W_Print function will move the character cursor to the
   				location immediatly following the character last printed.

      SEE ALSO: W_Print, W_LineCursor, Window

       EXAMPLE: /*
       			**	Print 10 numbers at column 5 into a window
       			*/
       			
       				Wnd = Window();
       				For( y = 0; y < 10; y++ )
       				{
       					W_Pos( Wnd, 5, y );
       					W_Print( Wnd, y );
       				};	
					W_Pick( Wnd );
					Destroy( Wnd );

      FUNCTION: W_Print

       SUMMARY: Print text into a window

         USAGE:	W_Print( Window, Args... )

       RETURNS: Null

   DESCRIPTION:	Print text into a window.

      SEE ALSO:	W_GetLine, W_Del, W_Ins, W_MakeVis, Window

      FUNCTION: W_RefOff

       SUMMARY: Turn screen refreshing off

         USAGE:	W_RefOff()

       RETURNS: Null

   DESCRIPTION:	Disable screen refreshing for the purpose of performing
   				multiple window updates in a clean fashion.  The W_RefOn
   				function must be called to resume screen refreshing.

				Calls to W_RefOff and W_RefOn can be nested as long as the
				total number of calls to W_RefOff are balanced with the total
				number of calls to W_RefOn.

      SEE ALSO:	W_RefOn

      FUNCTION: W_RefOn

       SUMMARY: Turn screen refreshing on

         USAGE:	W_RefOn()

       RETURNS: Null

   DESCRIPTION:	Disable screen refreshing for the purpose of performing
   				multiple window updates in a clean fashion.  The W_RefOn
   				function must be called to resume screen refreshing.

				Calls to W_RefOff and W_RefOn can be nested as long as the
				total number of calls to W_RefOff are balanced with the total
				number of calls to W_RefOn.

      SEE ALSO:	W_RefOff

      FUNCTION: W_Relocate

       SUMMARY: Change the location of a window on the screen.

         USAGE: W_Relocate(
         			Window,		// Window to relocate
         			x_low,		// x low location of window on screen
         			y_low,		// y low location of window on screen
         			x_high,		// x high location of window on screen
         			y_high)		// y high location of window on screen

       RETURNS: Null

   DESCRIPTION: The W_Relocate function moves a window to a new location on 
   				the screen.  The coordinates given are screen coordinates
   				where the upper left corner is 0, 0.

      SEE ALSO: W_Pos, W_MakeVis, W_Show, W_Hide, W_Select, Window

       EXAMPLE: /*
       			**	Create a window and move it to the upper left corner
       			*/
       			
       				Wnd = Window();
       				W_Relocate( Wnd, 1, 1, 30, 6 );
       				W_Print( Wnd, "I'm in the upper left corner!" );
       				W_Pick( Wnd );
       				Destroy( Wnd );

      FUNCTION: W_Select

       SUMMARY: Bring a window to the top of all the other windows

         USAGE: W_Select( Window )

       RETURNS: Null

   DESCRIPTION: Windows can appear on top of each other.  The W_Select
   				function brings the Window specified to the top of all
   				the windows.  This will insure that the entire window
   				will be visible (not obscured by any other window).

				It is advisable to W_Select a window before W_Pick to
				assure that the entire window is visible.

      SEE ALSO: W_Show, W_Hide, Window

      FUNCTION: W_Show

       SUMMARY: Display a window that was hidden by W_Hide

         USAGE: W_Show( Window )

       RETURNS: Null

   DESCRIPTION: A window can be made invisible by using the W_Hide function.
   				The contents of the window are not lost, they are simply
   				hidden from view until a W_Show function is executed.

      SEE ALSO: W_Hide, W_Select, Window

      FUNCTION: W_Title

       SUMMARY: Set the title and subtitle for a window

         USAGE: W_Title( Window, Title [,Subtitle] )

       RETURNS: Null

   DESCRIPTION: The W_Title function is used to set the title and optionally
   				the subtitle text.

      SEE ALSO: Window

       EXAMPLE: /*
       			**	Create a window and set the title
       			*/
       			
       				Wnd = Window();
       				W_Title( Wnd, "New Title" );
       				W_Print( Wnd, "Wow, a window with a title!" );
       				W_Pick( Wnd );
       				Destroy( Wnd );

      FUNCTION: WaitMessage

       SUMMARY: Display a message and wait for a key before continuing

         USAGE: WaitMessage( Text )

       RETURNS: Null

   DESCRIPTION: Display a message and wait for the user to acknowledge before
   				continuing.

      SEE ALSO: Message

      FUNCTION: Weekday

       SUMMARY: Return three letter day of week description.

         USAGE:	Weekday( Date )

       RETURNS: String containing three letter day of the week description.

   DESCRIPTION:	Return three letter day of week description.

      SEE ALSO:	Date

	   EXAMPLE: /*
	   			**	Print the current day of the week
	   			*/

					Print( Weekday( Current Date( "Security Database" )));

      FUNCTION: While

       SUMMARY: Looped conditional expression execution

         USAGE:	While( ConditionExpression )
         		{
         			BLOCK;
         		};

   DESCRIPTION:	Execute BLOCK until ConditionExpression evaluates False.

      SEE ALSO:	For, Break, Continue

       EXAMPLE:	/*
       			**	Perform operation while condition is true
       			*/

					While( In < Out )
					{
						Print( Queue[ In ], "\n" );
						In++;
					};

